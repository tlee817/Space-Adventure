{
  "version": 3,
  "sources": ["../../three-mesh-bvh/src/core/Constants.js", "../../three-mesh-bvh/src/core/build/geometryUtils.js", "../../three-mesh-bvh/src/core/build/computeBoundsUtils.js", "../../three-mesh-bvh/src/utils/ArrayBoxUtilities.js", "../../three-mesh-bvh/src/core/build/splitUtils.js", "../../three-mesh-bvh/src/core/MeshBVHNode.js", "../../three-mesh-bvh/src/core/build/sortUtils.generated.js", "../../three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js", "../../three-mesh-bvh/src/core/utils/nodeBufferUtils.js", "../../three-mesh-bvh/src/core/build/buildUtils.js", "../../three-mesh-bvh/src/core/build/buildTree.js", "../../three-mesh-bvh/src/math/SeparatingAxisBounds.js", "../../three-mesh-bvh/src/math/MathUtilities.js", "../../three-mesh-bvh/src/math/ExtendedTriangle.js", "../../three-mesh-bvh/src/math/OrientedBox.js", "../../three-mesh-bvh/src/utils/PrimitivePool.js", "../../three-mesh-bvh/src/utils/ExtendedTrianglePool.js", "../../three-mesh-bvh/src/core/utils/BufferStack.js", "../../three-mesh-bvh/src/core/cast/shapecast.js", "../../three-mesh-bvh/src/core/cast/closestPointToPoint.js", "../../three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js", "../../three-mesh-bvh/src/utils/TriangleUtilities.js", "../../three-mesh-bvh/src/core/utils/iterationUtils.generated.js", "../../three-mesh-bvh/src/core/cast/refit.generated.js", "../../three-mesh-bvh/src/core/utils/intersectUtils.js", "../../three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js", "../../three-mesh-bvh/src/core/cast/raycast.generated.js", "../../three-mesh-bvh/src/core/cast/raycastFirst.generated.js", "../../three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js", "../../three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js", "../../three-mesh-bvh/src/core/cast/refit_indirect.generated.js", "../../three-mesh-bvh/src/core/cast/raycast_indirect.generated.js", "../../three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js", "../../three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js", "../../three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js", "../../three-mesh-bvh/src/utils/BufferUtils.js", "../../three-mesh-bvh/src/core/cast/bvhcast.js", "../../three-mesh-bvh/src/core/MeshBVH.js", "../../three-mesh-bvh/src/objects/MeshBVHHelper.js", "../../three-mesh-bvh/src/debug/Debug.js", "../../three-mesh-bvh/src/utils/ExtensionUtilities.js", "../../three-mesh-bvh/src/gpu/VertexAttributeTexture.js", "../../three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js", "../../three-mesh-bvh/src/utils/StaticGeometryGenerator.js", "../../three-mesh-bvh/src/gpu/BVHShaderGLSL.js", "../../three-mesh-bvh/src/gpu/glsl/common_functions.glsl.js", "../../three-mesh-bvh/src/gpu/glsl/bvh_distance_functions.glsl.js", "../../three-mesh-bvh/src/gpu/glsl/bvh_ray_functions.glsl.js", "../../three-mesh-bvh/src/gpu/glsl/bvh_struct_definitions.glsl.js", "../../three-mesh-bvh/src/index.js", "../../three-gpu-pathtracer/src/core/utils/BufferAttributeUtils.js", "../../three-gpu-pathtracer/src/core/utils/mergeGeometries.js", "../../three-gpu-pathtracer/src/core/utils/GeometryPreparationUtils.js", "../../three-gpu-pathtracer/src/utils/bufferToHash.js", "../../three-gpu-pathtracer/src/core/utils/MeshDiff.js", "../../three-gpu-pathtracer/src/core/utils/convertToStaticGeometry.js", "../../three-gpu-pathtracer/src/core/utils/BakedGeometry.js", "../../three-gpu-pathtracer/src/core/utils/StaticGeometryGenerator.js", "../../three-gpu-pathtracer/src/core/PathTracingSceneGenerator.js", "../../three/examples/jsm/postprocessing/Pass.js", "../../three-gpu-pathtracer/src/materials/MaterialBase.js", "../../three-gpu-pathtracer/src/materials/fullscreen/BlendMaterial.js", "../../three-gpu-pathtracer/src/shader/rand/sobol.glsl.js", "../../three-gpu-pathtracer/src/utils/SobolNumberMapGenerator.js", "../../three-gpu-pathtracer/src/objects/PhysicalCamera.js", "../../three-gpu-pathtracer/src/uniforms/PhysicalCameraUniform.js", "../../three-gpu-pathtracer/src/utils/TextureUtils.js", "../../three-gpu-pathtracer/src/uniforms/EquirectHdrInfoUniform.js", "../../three-gpu-pathtracer/src/uniforms/LightsInfoUniformStruct.js", "../../three-gpu-pathtracer/src/uniforms/FloatAttributeTextureArray.js", "../../three-gpu-pathtracer/src/uniforms/AttributesTextureArray.js", "../../three-gpu-pathtracer/src/core/utils/sceneUpdateUtils.js", "../../three-gpu-pathtracer/src/uniforms/MaterialsTexture.js", "../../three-gpu-pathtracer/src/uniforms/RenderTarget2DArray.js", "../../three-gpu-pathtracer/src/uniforms/stratified/StratifiedSampler.js", "../../three-gpu-pathtracer/src/uniforms/stratified/StratifiedSamplerCombined.js", "../../three-gpu-pathtracer/src/uniforms/StratifiedSamplesTexture.js", "../../three-gpu-pathtracer/src/textures/blueNoise/utils.js", "../../three-gpu-pathtracer/src/textures/blueNoise/BlueNoiseSamples.js", "../../three-gpu-pathtracer/src/textures/blueNoise/BlueNoiseGenerator.js", "../../three-gpu-pathtracer/src/textures/BlueNoiseTexture.js", "../../three-gpu-pathtracer/src/shader/structs/camera_struct.glsl.js", "../../three-gpu-pathtracer/src/shader/structs/equirect_struct.glsl.js", "../../three-gpu-pathtracer/src/shader/structs/lights_struct.glsl.js", "../../three-gpu-pathtracer/src/shader/structs/material_struct.glsl.js", "../../three-gpu-pathtracer/src/shader/structs/surface_record_struct.glsl.js", "../../three-gpu-pathtracer/src/shader/sampling/equirect_sampling_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/sampling/light_sampling_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/sampling/shape_sampling_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/common/fresnel_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/common/math_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/common/shape_intersection_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/common/texture_sample_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/common/util_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/rand/pcg.glsl.js", "../../three-gpu-pathtracer/src/shader/rand/stratified.glsl.js", "../../three-gpu-pathtracer/src/shader/bsdf/bsdf_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/bsdf/fog_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/bsdf/ggx_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/bsdf/iridescence_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/bsdf/sheen_functions.glsl.js", "../../three-gpu-pathtracer/src/shader/bvh/inside_fog_volume_function.glsl.js", "../../three-gpu-pathtracer/src/materials/pathtracing/glsl/attenuate_hit_function.glsl.js", "../../three-gpu-pathtracer/src/materials/pathtracing/glsl/camera_util_functions.glsl.js", "../../three-gpu-pathtracer/src/materials/pathtracing/glsl/direct_light_contribution_function.glsl.js", "../../three-gpu-pathtracer/src/materials/pathtracing/glsl/get_surface_record_function.glsl.js", "../../three-gpu-pathtracer/src/materials/pathtracing/glsl/render_structs.glsl.js", "../../three-gpu-pathtracer/src/materials/pathtracing/glsl/trace_scene_function.glsl.js", "../../three-gpu-pathtracer/src/materials/pathtracing/PhysicalPathTracingMaterial.js", "../../three-gpu-pathtracer/src/core/PathTracingRenderer.js", "../../three-gpu-pathtracer/src/textures/ProceduralEquirectTexture.js", "../../three-gpu-pathtracer/src/textures/GradientEquirectTexture.js", "../../three-gpu-pathtracer/src/materials/fullscreen/ClampedInterpolationMaterial.js", "../../three-gpu-pathtracer/src/utils/CubeToEquirectGenerator.js", "../../three-gpu-pathtracer/src/core/WebGLPathTracer.js", "../../three-gpu-pathtracer/src/objects/EquirectCamera.js", "../../three-gpu-pathtracer/src/objects/PhysicalSpotLight.js", "../../three-gpu-pathtracer/src/objects/ShapedAreaLight.js", "../../three-gpu-pathtracer/src/utils/BlurredEnvMapGenerator.js", "../../three-gpu-pathtracer/src/materials/fullscreen/DenoiseMaterial.js", "../../three-gpu-pathtracer/src/materials/surface/FogVolumeMaterial.js"],
  "sourcesContent": ["// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n", "import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo, range ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = range ? range : geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo, range ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo, range );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = range ? range : geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry, range ) {\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry, range )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n", "import { FLOAT32_EPSILON } from '../Constants.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, target = null, offset = null, count = null ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst normalized = posAttr.normalized;\n\tlet triangleBounds;\n\tif ( target === null ) {\n\n\t\ttriangleBounds = new Float32Array( triCount * 6 );\n\t\toffset = 0;\n\t\tcount = triCount;\n\n\t} else {\n\n\t\ttriangleBounds = target;\n\t\toffset = offset || 0;\n\t\tcount = count || triCount;\n\n\t}\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n", "export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n", "import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n", "export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n", "/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n", "/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n", "export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n", "import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { IS_LEAF } from '../utils/nodeBufferUtils.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst stride4Offset = byteOffset / 4;\n\tconst stride2Offset = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tconst buffer = node.buffer;\n\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\n\n\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\n\n\t\t\t\tconst offset2 = offset / 2;\n\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\n\n\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteOffset + buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = node.left;\n\t\tconst right = node.right;\n\t\tconst splitAxis = node.splitAxis;\n\n\t\tlet nextUnusedPointer;\n\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t}\n\n\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\n\n\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\treturn nextUnusedPointer;\n\n\t}\n\n}\n", "import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t// epxand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafTris,\n\t\tstrategy,\n\t\tonProgress,\n\t\tindirect,\n\t} = options;\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t// generate intermediate variables\n\tconst totalTriangles = getTriCount( geometry );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new MeshBVHNode();\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry, options.range ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\tconst triangleBounds = computeTriangleBounds( geometry );\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry, options.range ) : getRootIndexRanges( geometry, options.range );\n\tbvh._roots = geometryRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n", "import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n", "import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n", "import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\tconst tempPoint = new Vector3();\n\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t// find the edge that intersects the other triangle plane\n\t\tconst points = tri.points;\n\t\tlet count = 0;\n\t\tlet startPointIntersection = - 1;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst { start, end } = edge;\n\t\t\tstart.copy( points[ i ] );\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\tedge.delta( dir );\n\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\tcount = 2;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\ttempPoint.copy( start );\n\n\t\t\t}\n\n\t\t\t// ignore the end point\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t// the start point if necessary\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcount ++;\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n", "import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n", "export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n", "import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n", "class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n", "import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n", "import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n", "import { Vector3, Vector2, Triangle, DoubleSide, BackSide, REVISION } from 'three';\n\nconst IS_GT_REVISION_169 = parseInt( REVISION ) >= 169;\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\tif ( distance < near || distance > far ) return null;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tconst barycoord = new Vector3();\n\t\tTriangle.getBarycoord( _intersectionPoint, _vA, _vB, _vC, barycoord );\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t\tif ( IS_GT_REVISION_169 ) {\n\n\t\t\tintersection.barycoord = barycoord;\n\n\t\t}\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections, near, far ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n", "\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract barycoord\n\tconst barycoord = target && target.barycoord ? target.barycoord : new Vector3();\n\tTriangle.getBarycoord( point, tempV1, tempV2, tempV3, barycoord );\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\t\ttarget.barycoord = barycoord;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv,\n\t\t\tbarycoord: barycoord,\n\t\t};\n\n\t}\n\n}\n", "import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n", "import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n", "/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray, near, far ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\treturn tmin <= far && tmax >= near;\n\n}\n", "import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n", "import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, side, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n", "import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, side, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t// eslint-disable-next-line no-unreachable\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n", "import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n", "import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n", "import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n", "import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, side, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n", "import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, side, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n", "import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n", "import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n", "export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n", "import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\n\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool( () => new Box3() );\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\n\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet offset1 = 0;\n\tlet offset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\toffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ j ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\toffset1 += roots[ i ].length;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexByteOffset = 0,\n\tnode2IndexByteOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n", "import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafTris: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n\trange: null\n};\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects, near, far );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray, near, far );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n", "import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry, Mesh, Matrix4 } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst matrix = /* @__PURE__ */ new Matrix4();\n\nclass MeshBVHRootHelper extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tgetVertexPosition( ...args ) {\n\n\t\t// implement this function so it works with Box3.setFromObject\n\t\treturn Mesh.prototype.getVertexPosition.call( this, ...args );\n\n\t}\n\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootHelper';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.bvh = bvh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.bvh;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHHelper extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t// handle bvh, depth signature\n\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\tdepth = bvh || 10;\n\t\t\tbvh = mesh;\n\t\t\tmesh = null;\n\n\t\t}\n\n\t\t// handle mesh, depth signature\n\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\tdepth = bvh;\n\t\t\tbvh = null;\n\n\t\t}\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHHelper';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.bvh = bvh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis.objectIndex = 0;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tlet bvh = this.bvh || mesh.geometry.boundsTree || null;\n\t\tif ( mesh.isBatchedMesh && mesh.boundsTrees && ! bvh ) {\n\n\t\t\t// get the bvh from a batchedMesh if not provided\n\t\t\t// TODO: we should have an official way to get the geometry index cleanly\n\t\t\tconst drawInfo = mesh._drawInfo[ this.objectIndex ];\n\t\t\tif ( drawInfo ) {\n\n\t\t\t\tbvh = mesh.boundsTrees[ drawInfo.geometryIndex ] || bvh;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.bvh = bvh;\n\t\t\troot.depth = depth;\n\t\t\troot.displayParents = displayParents;\n\t\t\troot.displayEdges = displayEdges;\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst mesh = this.mesh;\n\t\tconst parent = this.parent;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t.invert()\n\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// handle batched and instanced mesh bvhs\n\t\t\tif ( mesh.isInstancedMesh || mesh.isBatchedMesh ) {\n\n\t\t\t\tmesh.getMatrixAt( this.objectIndex, matrix );\n\t\t\t\tthis.matrix.multiply( matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrix.decompose(\n\t\t\t\tthis.position,\n\t\t\t\tthis.quaternion,\n\t\t\t\tthis.scale,\n\t\t\t);\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\t\tthis.bvh = source.bvh;\n\t\tthis.opacity = source.opacity;\n\t\tthis.color.copy( source.color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport class MeshBVHVisualizer extends MeshBVHHelper {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t}\n\n}\n\nexport { MeshBVHHelper };\n", "import { Box3, Vector3 } from 'three';\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\n\nconst _box1 = /* @__PURE__ */ new Box3();\nconst _box2 = /* @__PURE__ */ new Box3();\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\nfunction getPrimitiveSize( el ) {\n\n\tswitch ( typeof el ) {\n\n\t\tcase 'number':\n\t\t\treturn 8;\n\t\tcase 'string':\n\t\t\treturn el.length * 2;\n\t\tcase 'boolean':\n\t\t\treturn 4;\n\t\tdefault:\n\t\t\treturn 0;\n\n\t}\n\n}\n\nfunction isTypedArray( arr ) {\n\n\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\treturn regex.test( arr.constructor.name );\n\n}\n\nfunction getRootExtremes( bvh, group ) {\n\n\tconst result = {\n\t\tnodeCount: 0,\n\t\tleafNodeCount: 0,\n\n\t\tdepth: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\ttris: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\tsplits: [ 0, 0, 0 ],\n\t\tsurfaceAreaScore: 0,\n\t};\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\tresult.nodeCount ++;\n\t\tif ( isLeaf ) {\n\n\t\t\tresult.leafNodeCount ++;\n\n\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\tresult.tris.min = Math.min( count, result.tris.min );\n\t\t\tresult.tris.max = Math.max( count, result.tris.max );\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n\n\t\t} else {\n\n\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t}\n\n\t}, group );\n\n\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\tif ( result.tris.min === Infinity ) {\n\n\t\tresult.tris.min = 0;\n\t\tresult.tris.max = 0;\n\n\t}\n\n\tif ( result.depth.min === Infinity ) {\n\n\t\tresult.depth.min = 0;\n\t\tresult.depth.max = 0;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getBVHExtremes( bvh ) {\n\n\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n}\n\nfunction estimateMemoryInBytes( obj ) {\n\n\tconst traversed = new Set();\n\tconst stack = [ obj ];\n\tlet bytes = 0;\n\n\twhile ( stack.length ) {\n\n\t\tconst curr = stack.pop();\n\t\tif ( traversed.has( curr ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\ttraversed.add( curr );\n\n\t\tfor ( let key in curr ) {\n\n\t\t\tif ( ! Object.hasOwn( curr, key ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tbytes += getPrimitiveSize( key );\n\n\t\t\tconst value = curr[ key ];\n\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( isSharedArrayBufferSupported() && value instanceof SharedArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbytes += getPrimitiveSize( value );\n\n\t\t\t}\n\n\n\t\t}\n\n\t}\n\n\treturn bytes;\n\n}\n\nfunction validateBounds( bvh ) {\n\n\tconst geometry = bvh.geometry;\n\tconst depthStack = [];\n\tconst index = geometry.index;\n\tconst position = geometry.getAttribute( 'position' );\n\tlet passes = true;\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tdepth,\n\t\t\tisLeaf,\n\t\t\tboundingData,\n\t\t\toffset,\n\t\t\tcount,\n\t\t};\n\t\tdepthStack[ depth ] = info;\n\n\t\tarrayToBox( 0, boundingData, _box1 );\n\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\tif ( isLeaf ) {\n\n\t\t\t// check triangles\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst triIndex = bvh.resolveTriangleIndex( i );\n\t\t\t\tlet i0 = 3 * triIndex;\n\t\t\t\tlet i1 = 3 * triIndex + 1;\n\t\t\t\tlet i2 = 3 * triIndex + 2;\n\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t\t}\n\n\t\t\t\tlet isContained;\n\n\t\t\t\t_vec.fromBufferAttribute( position, i0 );\n\t\t\t\tisContained = _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i1 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i2 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\n\t\t\t\tpasses = passes && isContained;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parent ) {\n\n\t\t\t// check if my bounds fit in my parents\n\t\t\tarrayToBox( 0, boundingData, _box2 );\n\n\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\tpasses = passes && isContained;\n\n\t\t}\n\n\t} );\n\n\treturn passes;\n\n}\n\n// Returns a simple, human readable object that represents the BVH.\nfunction getJSONStructure( bvh ) {\n\n\tconst depthStack = [];\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tbounds: arrayToBox( 0, boundingData, new Box3() ),\n\t\t};\n\n\t\tif ( isLeaf ) {\n\n\t\t\tinfo.count = count;\n\t\t\tinfo.offset = offset;\n\n\t\t} else {\n\n\t\t\tinfo.left = null;\n\t\t\tinfo.right = null;\n\n\t\t}\n\n\t\tdepthStack[ depth ] = info;\n\n\t\t// traversal hits the left then right node\n\t\tconst parent = depthStack[ depth - 1 ];\n\t\tif ( parent ) {\n\n\t\t\tif ( parent.left === null ) {\n\n\t\t\t\tparent.left = info;\n\n\t\t\t} else {\n\n\t\t\t\tparent.right = info;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn depthStack[ 0 ];\n\n}\n\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };\n", "import { Ray, Matrix4, Mesh, Vector3, Sphere, BatchedMesh, REVISION } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst IS_REVISION_166 = parseInt( REVISION ) >= 166;\nconst ray = /* @__PURE__ */ new Ray();\nconst direction = /* @__PURE__ */ new Vector3();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\nconst origBatchedRaycastFunc = BatchedMesh.prototype.raycast;\nconst _worldScale = /* @__PURE__ */ new Vector3();\nconst _mesh = /* @__PURE__ */ new Mesh();\nconst _batchIntersects = [];\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.isBatchedMesh ) {\n\n\t\tacceleratedBatchedMeshRaycast.call( this, raycaster, intersects );\n\n\t} else {\n\n\t\tacceleratedMeshRaycast.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nfunction acceleratedBatchedMeshRaycast( raycaster, intersects ) {\n\n\tif ( this.boundsTrees ) {\n\n\t\t// TODO: remove use of geometry info, instance info when r170 is minimum version\n\t\tconst boundsTrees = this.boundsTrees;\n\t\tconst drawInfo = this._drawInfo || this._instanceInfo;\n\t\tconst drawRanges = this._drawRanges || this._geometryInfo;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\t_mesh.material = this.material;\n\t\t_mesh.geometry = this.geometry;\n\n\t\tconst oldBoundsTree = _mesh.geometry.boundsTree;\n\t\tconst oldDrawRange = _mesh.geometry.drawRange;\n\n\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t_mesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\t// TODO: provide new method to get instances count instead of 'drawInfo.length'\n\t\tfor ( let i = 0, l = drawInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( ! this.getVisibleAt( i ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// TODO: use getGeometryIndex\n\t\t\tconst geometryId = drawInfo[ i ].geometryIndex;\n\n\t\t\t_mesh.geometry.boundsTree = boundsTrees[ geometryId ];\n\n\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\n\t\t\tif ( ! _mesh.geometry.boundsTree ) {\n\n\t\t\t\tthis.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );\n\t\t\t\tthis.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );\n\n\t\t\t\tconst drawRange = drawRanges[ geometryId ];\n\t\t\t\t_mesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\n\t\t\t}\n\n\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersect.batchId = i;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_batchIntersects.length = 0;\n\n\t\t}\n\n\t\t_mesh.geometry.boundsTree = oldBoundsTree;\n\t\t_mesh.geometry.drawRange = oldDrawRange;\n\t\t_mesh.material = null;\n\t\t_mesh.geometry = null;\n\n\t} else {\n\n\t\torigBatchedRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nfunction acceleratedMeshRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\t\tdirection.copy( ray.direction ).multiply( _worldScale );\n\n\t\tconst scaleFactor = direction.length();\n\t\tconst near = raycaster.near / scaleFactor;\n\t\tconst far = raycaster.far / scaleFactor;\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material, near, far ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material, near, far );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options = {} ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n\nexport function computeBatchedBoundsTree( index = - 1, options = {} ) {\n\n\tif ( ! IS_REVISION_166 ) {\n\n\t\tthrow new Error( 'BatchedMesh: Three r166+ is required to compute bounds trees.' );\n\n\t}\n\n\tif ( options.indirect ) {\n\n\t\tconsole.warn( '\"Indirect\" is set to false because it is not supported for BatchedMesh.' );\n\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tindirect: false,\n\t\trange: null\n\t};\n\n\tconst drawRanges = this._drawRanges || this._geometryInfo;\n\tconst geometryCount = this._geometryCount;\n\tif ( ! this.boundsTrees ) {\n\n\t\tthis.boundsTrees = new Array( geometryCount ).fill( null );\n\n\t}\n\n\tconst boundsTrees = this.boundsTrees;\n\twhile ( boundsTrees.length < geometryCount ) {\n\n\t\tboundsTrees.push( null );\n\n\t}\n\n\tif ( index < 0 ) {\n\n\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\toptions.range = drawRanges[ i ];\n\t\t\tboundsTrees[ i ] = new MeshBVH( this.geometry, options );\n\n\t\t}\n\n\t\treturn boundsTrees;\n\n\t} else {\n\n\t\tif ( index < drawRanges.length ) {\n\n\t\t\toptions.range = drawRanges[ index ];\n\t\t\tboundsTrees[ index ] = new MeshBVH( this.geometry, options );\n\n\t\t}\n\n\t\treturn boundsTrees[ index ] || null;\n\n\t}\n\n}\n\nexport function disposeBatchedBoundsTree( index = - 1 ) {\n\n\tif ( index < 0 ) {\n\n\t\tthis.boundsTrees.fill( null );\n\n\t} else {\n\n\t\tif ( index < this.boundsTree.length ) {\n\n\t\t\tthis.boundsTrees[ index ] = null;\n\n\t\t}\n\n\t}\n\n}\n", "import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) ) || 1;\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\tconst originalNormalized = attr.normalized;\n\t\tattr.normalized = false;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tattr.normalized = originalNormalized;\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n", "import {\n\tDataTexture,\n\tFloatType,\n\tUnsignedIntType,\n\tRGBAFormat,\n\tRGIntegerFormat,\n\tNearestFilter,\n\tBufferAttribute,\n} from 'three';\nimport {\n\tFloatVertexAttributeTexture,\n\tUIntVertexAttributeTexture,\n} from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport {\n\tBOUNDING_DATA_INDEX,\n\tCOUNT,\n\tIS_LEAF,\n\tRIGHT_NODE,\n\tOFFSET,\n\tSPLIT_AXIS,\n} from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\n\nexport class MeshBVHUniformStruct {\n\n\tconstructor() {\n\n\t\tthis.index = new UIntVertexAttributeTexture();\n\t\tthis.position = new FloatVertexAttributeTexture();\n\t\tthis.bvhBounds = new DataTexture();\n\t\tthis.bvhContents = new DataTexture();\n\t\tthis._cachedIndexAttr = null;\n\n\t\tthis.index.overrideItemSize = 3;\n\n\t}\n\n\tupdateFrom( bvh ) {\n\n\t\tconst { geometry } = bvh;\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t// dereference a new index attribute if we're using indirect storage\n\t\tif ( bvh.indirect ) {\n\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tif (\n\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t) {\n\n\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\tthis._cachedIndexAttr = new BufferAttribute( array, 1, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t} else {\n\n\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\tif ( index ) index.dispose();\n\t\tif ( position ) position.dispose();\n\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t}\n\n}\n\nfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\tconst unpacked = target.array;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t}\n\n\t}\n\n}\n\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\tconst roots = bvh._roots;\n\n\tif ( roots.length !== 1 ) {\n\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t}\n\n\tconst root = roots[ 0 ];\n\tconst uint16Array = new Uint16Array( root );\n\tconst uint32Array = new Uint32Array( root );\n\tconst float32Array = new Float32Array( root );\n\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t// the width so we can expand the row by two and still have a square texture\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t}\n\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t} else {\n\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t}\n\n\t}\n\n\tboundsTexture.image.data = boundsArray;\n\tboundsTexture.image.width = boundsDimension;\n\tboundsTexture.image.height = boundsDimension;\n\tboundsTexture.format = RGBAFormat;\n\tboundsTexture.type = FloatType;\n\tboundsTexture.internalFormat = 'RGBA32F';\n\tboundsTexture.minFilter = NearestFilter;\n\tboundsTexture.magFilter = NearestFilter;\n\tboundsTexture.generateMipmaps = false;\n\tboundsTexture.needsUpdate = true;\n\tboundsTexture.dispose();\n\n\tcontentsTexture.image.data = contentsArray;\n\tcontentsTexture.image.width = contentsDimension;\n\tcontentsTexture.image.height = contentsDimension;\n\tcontentsTexture.format = RGIntegerFormat;\n\tcontentsTexture.type = UnsignedIntType;\n\tcontentsTexture.internalFormat = 'RG32UI';\n\tcontentsTexture.minFilter = NearestFilter;\n\tcontentsTexture.magFilter = NearestFilter;\n\tcontentsTexture.generateMipmaps = false;\n\tcontentsTexture.needsUpdate = true;\n\tcontentsTexture.dispose();\n\n}\n", "import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new BufferGeometry() ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst attributes = {};\n\n\tlet offset = 0;\n\n\ttargetGeometry.clearGroups();\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\tattributes[ name ] = [];\n\n\t\t\t}\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\tif ( isIndexed ) {\n\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\tlet indexCount = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// merge attributes\n\tfor ( const name in attributes ) {\n\n\t\tconst attrList = attributes[ name ];\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\tlet count = 0;\n\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t}\n\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\tconst attr = attrList[ i ];\n\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n\treturn targetGeometry;\n\n}\n\nfunction checkTypedArrayEquality( a, b ) {\n\n\tif ( a === null || b === null ) {\n\n\t\treturn a === b;\n\n\t}\n\n\tif ( a.length !== b.length ) {\n\n\t\treturn false;\n\n\t}\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nfunction invertGeometry( geometry ) {\n\n\tconst { index, attributes } = geometry;\n\tif ( index ) {\n\n\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\n\n\t\t\tconst v0 = index.getX( i );\n\t\t\tconst v2 = index.getX( i + 2 );\n\t\t\tindex.setX( i, v2 );\n\t\t\tindex.setX( i + 2, v0 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attr = attributes[ key ];\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tconst v0 = attr.getComponent( i, j );\n\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\n\t\t\t\t\tattr.setComponent( i, j, v2 );\n\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n\n\tconstructor( mesh ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.boneMatrices = null;\n\t\tthis.primitiveCount = - 1;\n\t\tthis.mesh = mesh;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\tthis.primitiveCount = primitiveCount;\n\n\t\tif ( skeleton ) {\n\n\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t}\n\n\t\t\tskeleton.update();\n\n\t\t\t// copy data if possible otherwise clone it\n\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = null;\n\n\t\t}\n\n\t}\n\n\tdidChange() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( meshes ) {\n\n\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\tmeshes = [ meshes ];\n\n\t\t}\n\n\t\tconst finalMeshes = [];\n\t\tmeshes.forEach( object => {\n\n\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tthis.meshes = finalMeshes;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\n\t\tthis._diffMap = new WeakMap();\n\n\t}\n\n\tgetMaterials() {\n\n\t\tconst materials = [];\n\t\tthis.meshes.forEach( mesh => {\n\n\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t}\n\n\t\t} );\n\t\treturn materials;\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tlet skipAttributes = [];\n\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdiff.update();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tskipAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( _intermediateGeometry.length === 0 ) {\n\n\t\t\t// if there are no geometries then just create a fake empty geometry to provide\n\t\t\ttargetGeometry.setIndex( null );\n\n\t\t\t// remove all geometry\n\t\t\tconst attrs = targetGeometry.attributes;\n\t\t\tfor ( const key in attrs ) {\n\n\t\t\t\ttargetGeometry.deleteAttribute( key );\n\n\t\t\t}\n\n\t\t\t// create dummy attributes\n\t\t\tfor ( const key in this.attributes ) {\n\n\t\t\t\ttargetGeometry.setAttribute( this.attributes[ key ], new BufferAttribute( new Float32Array( 0 ), 4, false ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\t}\n\n\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\tconst attributes = geometry.attributes;\n\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t// initialize the attributes if they don't exist\n\t\tif ( ! targetGeometry.index && geometry.index ) {\n\n\t\t\ttargetGeometry.index = geometry.index.clone();\n\n\t\t}\n\n\t\tif ( ! targetAttributes.position ) {\n\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t}\n\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t}\n\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t}\n\n\t\t// ensure the attributes are consistent\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\tif ( includeNormal ) {\n\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t}\n\n\t\tif ( includeTangent ) {\n\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t}\n\n\t\t// generate transformed vertex attribute data\n\t\tconst position = attributes.position;\n\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\tconst normalMatrix = new Matrix3();\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\t// copy the index\n\t\tif ( geometry.index ) {\n\n\t\t\ttargetGeometry.index.array.set( geometry.index.array );\n\n\t\t}\n\n\t\t// copy and apply other attributes\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t}\n\n\t\t\t// apply morph target transform\n\t\t\tif ( morphInfluences ) {\n\n\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// apply bone transform\n\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the vectors of the attributes\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// copy other attributes over\n\t\tfor ( const i in this.attributes ) {\n\n\t\t\tconst key = this.attributes[ i ];\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t}\n\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t}\n\n\t\tif ( mesh.matrixWorld.determinant() < 0 ) {\n\n\t\t\tinvertGeometry( targetGeometry );\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n}\n", "export * from './glsl/common_functions.glsl.js';\nexport * from './glsl/bvh_distance_functions.glsl.js';\nexport * from './glsl/bvh_ray_functions.glsl.js';\nexport * from './glsl/bvh_struct_definitions.glsl.js';\n", "export const common_functions = /* glsl */`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n", "// Distance to Point\nexport const bvh_distance_functions = /* glsl */`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, maxDistance, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, maxDistance, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point, float maxDistance,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = maxDistance * maxDistance;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n", "export const bvh_ray_functions = /* glsl */`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n", "// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nexport const bvh_struct_definitions = /* glsl */`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n", "export { MeshBVH } from './core/MeshBVH.js';\nexport { MeshBVHHelper } from './objects/MeshBVHHelper.js';\nexport { CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED } from './core/Constants.js';\nexport { getBVHExtremes, estimateMemoryInBytes, getJSONStructure, validateBounds } from './debug/Debug.js';\nexport * from './utils/ExtensionUtilities.js';\nexport { getTriangleHitPointInfo } from './utils/TriangleUtilities.js';\nexport * from './math/ExtendedTriangle.js';\nexport * from './math/OrientedBox.js';\nexport * from './gpu/MeshBVHUniformStruct.js';\nexport * from './gpu/VertexAttributeTexture.js';\nexport * from './utils/StaticGeometryGenerator.js';\nexport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\n\n// backwards compatibility\nimport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\nexport const shaderStructs = BVHShaderGLSL.bvh_struct_definitions;\nexport const shaderDistanceFunction = BVHShaderGLSL.bvh_distance_functions;\nexport const shaderIntersectFunction = `\n\t${ BVHShaderGLSL.common_functions }\n\t${ BVHShaderGLSL.bvh_ray_functions }\n`;\n", "import { BufferAttribute } from 'three';\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nexport function copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nexport function createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// Confirms that the two provided attributes are compatible. Returns false if they are not.\nexport function validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn true;\n\n\t}\n\n\tif ( Boolean( attr1 ) !== Boolean( attr2 ) ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\treturn false;\n\n\t}\n\n\treturn true;\n\n}\n", "import { BufferAttribute, BufferGeometry } from 'three';\nimport { copyAttributeContents, createAttributeClone } from './BufferAttributeUtils.js';\n\nfunction validateMergeability( geometries ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tif ( ! geometries[ 0 ].getAttribute( 'position' ) ) {\n\n\t\tthrow new Error( 'StaticGeometryGenerator: position attribute is required.' );\n\n\t}\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have the same number of attributes.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction getTotalIndexCount( geometries ) {\n\n\tlet result = 0;\n\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\n\n\t\tresult += geometries[ i ].getIndex().count;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getTotalAttributeCount( geometries ) {\n\n\tlet result = 0;\n\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\n\n\t\tresult += geometries[ i ].getAttribute( 'position' ).count;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction trimMismatchedAttributes( target, indexCount, attrCount ) {\n\n\tif ( target.index && target.index.count !== indexCount ) {\n\n\t\ttarget.setIndex( null );\n\n\t}\n\n\tconst attributes = target.attributes;\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.count !== attrCount ) {\n\n\t\t\ttarget.deleteAttribute( key );\n\n\t\t}\n\n\t}\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nexport function mergeGeometries( geometries, options = {}, targetGeometry = new BufferGeometry() ) {\n\n\tconst {\n\t\tuseGroups = false,\n\t\tforceUpdate = false,\n\t\tskipAssigningAttributes = [],\n\t\toverwriteIndex = true,\n\t} = options;\n\n\t// check if we can merge these geometries\n\tvalidateMergeability( geometries );\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst totalIndexCount = isIndexed ? getTotalIndexCount( geometries ) : - 1;\n\tconst totalAttributeCount = getTotalAttributeCount( geometries );\n\ttrimMismatchedAttributes( targetGeometry, totalIndexCount, totalAttributeCount );\n\n\t// set up groups\n\tif ( useGroups ) {\n\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\n\n\t\t\tconst geometry = geometries[ i ];\n\n\t\t\tlet primitiveCount;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tprimitiveCount = geometry.getIndex().count;\n\n\t\t\t} else {\n\n\t\t\t\tprimitiveCount = geometry.getAttribute( 'position' ).count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, primitiveCount, i );\n\t\t\toffset += primitiveCount;\n\n\t\t}\n\n\t}\n\n\t// generate the final geometry\n\t// skip the assigning any attributes for items in the above array\n\tif ( isIndexed ) {\n\n\t\t// set up the index if it doesn't exist\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( totalIndexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( forceUpdateIndex || overwriteIndex ) {\n\n\t\t\t// copy the index data to the target geometry\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tconst targetIndex = targetGeometry.getIndex();\n\t\t\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.getIndex();\n\t\t\t\tconst skip = ! forceUpdate && ! forceUpdateIndex && skipAssigningAttributes[ i ];\n\t\t\t\tif ( ! skip ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset + j, index.getX( j ) + indexOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttargetOffset += index.count;\n\t\t\t\tindexOffset += geometry.getAttribute( 'position' ).count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// copy all the attribute data over\n\tconst attributes = Object.keys( geometries[ 0 ].attributes );\n\tfor ( let i = 0, l = attributes.length; i < l; i ++ ) {\n\n\t\tlet forceUpdateAttr = false;\n\t\tconst key = attributes[ i ];\n\t\tif ( ! targetGeometry.getAttribute( key ) ) {\n\n\t\t\tconst firstAttr = geometries[ 0 ].getAttribute( key );\n\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( firstAttr, totalAttributeCount ) );\n\t\t\tforceUpdateAttr = true;\n\n\t\t}\n\n\t\tlet offset = 0;\n\t\tconst targetAttribute = targetGeometry.getAttribute( key );\n\t\tfor ( let g = 0, l = geometries.length; g < l; g ++ ) {\n\n\t\t\tconst geometry = geometries[ g ];\n\t\t\tconst skip = ! forceUpdate && ! forceUpdateAttr && skipAssigningAttributes[ g ];\n\t\t\tconst attr = geometry.getAttribute( key );\n \t\t\tif ( ! skip ) {\n\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n}\n", "import { BufferAttribute } from 'three';\n\nexport function updateMaterialIndexAttribute( geometry, materials, allMaterials ) {\n\n\tconst indexAttr = geometry.index;\n\tconst posAttr = geometry.attributes.position;\n\tconst vertCount = posAttr.count;\n\tconst totalCount = indexAttr ? indexAttr.count : vertCount;\n\tlet groups = geometry.groups;\n\tif ( groups.length === 0 ) {\n\n\t\tgroups = [ { count: totalCount, start: 0, materialIndex: 0 } ];\n\n\t}\n\n\tlet materialIndexAttribute = geometry.getAttribute( 'materialIndex' );\n\tif ( ! materialIndexAttribute || materialIndexAttribute.count !== vertCount ) {\n\n\t\t// use an array with the minimum precision required to store all material id references.\n\t\tlet array;\n\t\tif ( allMaterials.length <= 255 ) {\n\n\t\t\tarray = new Uint8Array( vertCount );\n\n\t\t} else {\n\n\t\t\tarray = new Uint16Array( vertCount );\n\n\t\t}\n\n\t\tmaterialIndexAttribute = new BufferAttribute( array, 1, false );\n\t\tgeometry.deleteAttribute( 'materialIndex' );\n\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\n\n\t}\n\n\tconst materialArray = materialIndexAttribute.array;\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst start = group.start;\n\t\tconst count = group.count;\n\t\tconst endCount = Math.min( count, totalCount - start );\n\n\t\tconst mat = Array.isArray( materials ) ? materials[ group.materialIndex ] : materials;\n\t\tconst materialIndex = allMaterials.indexOf( mat );\n\n\t\tfor ( let j = 0; j < endCount; j ++ ) {\n\n\t\t\tlet index = start + j;\n\t\t\tif ( indexAttr ) {\n\n\t\t\t\tindex = indexAttr.getX( index );\n\n\t\t\t}\n\n\t\t\tmaterialArray[ index ] = materialIndex;\n\n\t\t}\n\n\t}\n\n}\n\nexport function setCommonAttributes( geometry, attributes ) {\n\n\tif ( ! geometry.index ) {\n\n\t\t// TODO: compute a typed array\n\t\tconst indexCount = geometry.attributes.position.count;\n\t\tconst array = new Array( indexCount );\n\t\tfor ( let i = 0; i < indexCount; i ++ ) {\n\n\t\t\tarray[ i ] = i;\n\n\t\t}\n\n\t\tgeometry.setIndex( array );\n\n\t}\n\n\tif ( ! geometry.attributes.normal && ( attributes && attributes.includes( 'normal' ) ) ) {\n\n\t\tgeometry.computeVertexNormals();\n\n\t}\n\n\tif ( ! geometry.attributes.uv && ( attributes && attributes.includes( 'uv' ) ) ) {\n\n\t\tconst vertCount = geometry.attributes.position.count;\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\n\n\t}\n\n\tif ( ! geometry.attributes.uv2 && ( attributes && attributes.includes( 'uv2' ) ) ) {\n\n\t\tconst vertCount = geometry.attributes.position.count;\n\t\tgeometry.setAttribute( 'uv2', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\n\n\t}\n\n\tif ( ! geometry.attributes.tangent && ( attributes && attributes.includes( 'tangent' ) ) ) {\n\n\t\t// compute tangents requires a uv and normal buffer\n\t\tif ( geometry.attributes.uv && geometry.attributes.normal ) {\n\n\t\t\tgeometry.computeTangents();\n\n\t\t} else {\n\n\t\t\tconst vertCount = geometry.attributes.position.count;\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( vertCount * 4 ), 4, false ) );\n\n\t\t}\n\n\t}\n\n\tif ( ! geometry.attributes.color && ( attributes && attributes.includes( 'color' ) ) ) {\n\n\t\tconst vertCount = geometry.attributes.position.count;\n\t\tconst array = new Float32Array( vertCount * 4 );\n\t\tarray.fill( 1.0 );\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( array, 4 ) );\n\n\t}\n\n}\n", "// https://www.geeksforgeeks.org/how-to-create-hash-from-string-in-javascript/\n// https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\nexport function bufferToHash( buffer ) {\n\n\tlet hash = 0;\n\n\tif ( buffer.byteLength !== 0 ) {\n\n\t\tconst uintArray = new Uint8Array( buffer );\n\t\tfor ( let i = 0; i < buffer.byteLength; i ++ ) {\n\n\t\t\tconst byte = uintArray[ i ];\n\t\t\thash = ( ( hash << 5 ) - hash ) + byte;\n\t\t\thash |= 0;\n\n\t\t}\n\n\t}\n\n\treturn hash;\n\n}\n", "import { Matrix4 } from 'three';\nimport { bufferToHash } from '../../utils/bufferToHash.js';\n\nfunction getGeometryHash( geometry ) {\n\n\tlet hash = geometry.uuid;\n\tconst attributes = Object.values( geometry.attributes );\n\tif ( geometry.index ) {\n\n\t\tattributes.push( geometry.index );\n\t\thash += `index|${ geometry.index.version }`;\n\n\t}\n\n\tconst keys = Object.keys( attributes ).sort();\n\tfor ( const key of keys ) {\n\n\t\tconst attr = attributes[ key ];\n\t\thash += `${ key }_${ attr.version }|`;\n\n\t}\n\n\treturn hash;\n\n}\n\nfunction getSkeletonHash( mesh ) {\n\n\tconst skeleton = mesh.skeleton;\n\tif ( skeleton ) {\n\n\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\tskeleton.computeBoneTexture();\n\n\t\t}\n\n\t\t// we can't use the texture version here because it will change even\n\t\t// when the bones haven't\n\t\tconst dataHash = bufferToHash( skeleton.boneTexture.image.data.buffer );\n\t\treturn `${ dataHash }_${ skeleton.boneTexture.uuid }`;\n\n\t} else {\n\n\t\treturn null;\n\n\t}\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nexport class MeshDiff {\n\n\tconstructor( mesh = null ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.skeletonHash = null;\n\t\tthis.primitiveCount = - 1;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tthis.updateFrom( mesh );\n\n\t\t}\n\n\t}\n\n\tupdateFrom( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = getGeometryHash( geometry );\n\t\tthis.primitiveCount = primitiveCount;\n\t\tthis.skeletonHash = getSkeletonHash( mesh );\n\n\t}\n\n\tdidChange( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === getGeometryHash( geometry ) &&\n\t\t\tthis.skeletonHash === getSkeletonHash( mesh ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n", "import { BufferGeometry, Matrix3, Matrix4, Vector3, Vector4 } from 'three';\nimport { copyAttributeContents, createAttributeClone, validateAttributes } from './BufferAttributeUtils.js';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// inverts the geometry in place\nfunction invertGeometry( geometry ) {\n\n\tconst { index, attributes } = geometry;\n\tif ( index ) {\n\n\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\n\n\t\t\tconst v0 = index.getX( i );\n\t\t\tconst v2 = index.getX( i + 2 );\n\t\t\tindex.setX( i, v2 );\n\t\t\tindex.setX( i + 2, v0 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attr = attributes[ key ];\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tconst v0 = attr.getComponent( i, j );\n\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\n\t\t\t\t\tattr.setComponent( i, j, v2 );\n\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\nexport function convertToStaticGeometry( mesh, options = {}, targetGeometry = new BufferGeometry() ) {\n\n\toptions = {\n\t\tapplyWorldTransforms: true,\n\t\tattributes: [],\n\t\t...options\n\t};\n\n\tconst geometry = mesh.geometry;\n\tconst applyWorldTransforms = options.applyWorldTransforms;\n\tconst includeNormal = options.attributes.includes( 'normal' );\n\tconst includeTangent = options.attributes.includes( 'tangent' );\n\tconst attributes = geometry.attributes;\n\tconst targetAttributes = targetGeometry.attributes;\n\n\t// strip any unused and unneeded attributes\n\tfor ( const key in targetGeometry.attributes ) {\n\n\t\tif ( ! options.attributes.includes( key ) || ! ( key in geometry.attributes ) ) {\n\n\t\t\ttargetGeometry.deleteAttribute( key );\n\n\t\t}\n\n\t}\n\n\t// initialize the attributes if they don't exist\n\tif ( ! targetGeometry.index && geometry.index ) {\n\n\t\ttargetGeometry.index = geometry.index.clone();\n\n\t}\n\n\tif ( ! targetAttributes.position ) {\n\n\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t}\n\n\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t}\n\n\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t}\n\n\t// ensure the attributes are consistent\n\tvalidateAttributes( geometry.index, targetGeometry.index );\n\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\tif ( includeNormal ) {\n\n\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t}\n\n\tif ( includeTangent ) {\n\n\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t}\n\n\t// generate transformed vertex attribute data\n\tconst position = attributes.position;\n\tconst normal = includeNormal ? attributes.normal : null;\n\tconst tangent = includeTangent ? attributes.tangent : null;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphNormal = geometry.morphAttributes.normal;\n\tconst morphTangent = geometry.morphAttributes.tangent;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst morphInfluences = mesh.morphTargetInfluences;\n\tconst normalMatrix = new Matrix3();\n\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t// copy the index\n\tif ( geometry.index ) {\n\n\t\ttargetGeometry.index.array.set( geometry.index.array );\n\n\t}\n\n\t// copy and apply other attributes\n\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t_positionVector.fromBufferAttribute( position, i );\n\t\tif ( normal ) {\n\n\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t}\n\n\t\tif ( tangent ) {\n\n\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t}\n\n\t\t// apply morph target transform\n\t\tif ( morphInfluences ) {\n\n\t\t\tif ( morphPosition ) {\n\n\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t}\n\n\t\t\tif ( morphNormal ) {\n\n\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t}\n\n\t\t\tif ( morphTangent ) {\n\n\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply bone transform\n\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\tif ( normal ) {\n\n\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update the vectors of the attributes\n\t\tif ( applyWorldTransforms ) {\n\n\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t}\n\n\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\tif ( normal ) {\n\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t}\n\n\t\tif ( tangent ) {\n\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t}\n\n\t}\n\n\t// copy other attributes over\n\tfor ( const i in options.attributes ) {\n\n\t\tconst key = options.attributes[ i ];\n\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t}\n\n\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t}\n\n\tif ( mesh.matrixWorld.determinant() < 0 ) {\n\n\t\tinvertGeometry( targetGeometry );\n\n\t}\n\n\treturn targetGeometry;\n\n}\n", "import { BufferGeometry } from 'three';\nimport { MeshDiff } from './MeshDiff.js';\nimport { convertToStaticGeometry } from './convertToStaticGeometry.js';\nimport { validateAttributes } from './BufferAttributeUtils.js';\n\nexport class BakedGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.version = 0;\n\t\tthis.hash = null;\n\t\tthis._diff = new MeshDiff();\n\n\t}\n\n\t// returns whether the passed mesh is compatible with this baked geometry\n\t// such that it can be updated without resizing attributes\n\tisCompatible( mesh, attributes ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\n\n\t\t\tconst key = attributes[ i ];\n\t\t\tconst attr1 = geometry.attributes[ key ];\n\t\t\tconst attr2 = this.attributes[ key ];\n\t\t\tif ( attr1 && ! validateAttributes( attr1, attr2 ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tupdateFrom( mesh, options ) {\n\n\t\tconst diff = this._diff;\n\t\tif ( diff.didChange( mesh ) ) {\n\n\t\t\tconvertToStaticGeometry( mesh, options, this );\n\t\t\tdiff.updateFrom( mesh );\n\t\t\tthis.version ++;\n\t\t\tthis.hash = `${ this.uuid }_${ this.version }`;\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n}\n", "import { BufferAttribute, BufferGeometry, Mesh, MeshBasicMaterial } from 'three';\nimport { mergeGeometries } from './mergeGeometries.js';\nimport { setCommonAttributes } from './GeometryPreparationUtils.js';\nimport { BakedGeometry } from './BakedGeometry.js';\n\nexport const NO_CHANGE = 0;\nexport const GEOMETRY_ADJUSTED = 1;\nexport const GEOMETRY_REBUILT = 2;\n\n// iterate over only the meshes in the provided objects\nfunction flatTraverseMeshes( objects, cb ) {\n\n\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\tconst object = objects[ i ];\n\t\tobject.traverseVisible( o => {\n\n\t\t\tif ( o.isMesh ) {\n\n\t\t\t\tcb( o );\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\n// return the set of materials used by the provided meshes\nfunction getMaterials( meshes ) {\n\n\tconst materials = [];\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\tconst mesh = meshes[ i ];\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tmaterials.push( ...mesh.material );\n\n\t\t} else {\n\n\t\t\tmaterials.push( mesh.material );\n\n\t\t}\n\n\t}\n\n\treturn materials;\n\n}\n\nfunction mergeGeometryList( geometries, target, options ) {\n\n\t// If we have no geometry to merge then provide an empty geometry.\n\tif ( geometries.length === 0 ) {\n\n\t\t// if there are no geometries then just create a fake empty geometry to provide\n\t\ttarget.setIndex( null );\n\n\t\t// remove all geometry\n\t\tconst attrs = target.attributes;\n\t\tfor ( const key in attrs ) {\n\n\t\t\ttarget.deleteAttribute( key );\n\n\t\t}\n\n\t\t// create dummy attributes\n\t\tfor ( const key in options.attributes ) {\n\n\t\t\ttarget.setAttribute( options.attributes[ key ], new BufferAttribute( new Float32Array( 0 ), 4, false ) );\n\n\t\t}\n\n\t} else {\n\n\t\tmergeGeometries( geometries, options, target );\n\n\t}\n\n\t// Mark all attributes as needing an update\n\tfor ( const key in target.attributes ) {\n\n\t\ttarget.attributes[ key ].needsUpdate = true;\n\n\t}\n\n}\n\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( objects ) {\n\n\t\tthis.objects = null;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.generateMissingAttributes = true;\n\t\tthis.overwriteIndex = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Map();\n\t\tthis._geometryMergeSets = new WeakMap();\n\t\tthis._mergeOrder = [];\n\t\tthis._dummyMesh = null;\n\n\t\tthis.setObjects( objects || [] );\n\n\t}\n\n\t_getDummyMesh() {\n\n\t\t// return a consistent dummy mesh\n\t\tif ( ! this._dummyMesh ) {\n\n\t\t\tconst dummyMaterial = new MeshBasicMaterial();\n\t\t\tconst emptyGeometry = new BufferGeometry();\n\t\t\temptyGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( 9 ), 3 ) );\n\t\t\tthis._dummyMesh = new Mesh( emptyGeometry, dummyMaterial );\n\n\t\t}\n\n\t\treturn this._dummyMesh;\n\n\t}\n\n\t_getMeshes() {\n\n\t\t// iterate over only the meshes in the provided objects\n\t\tconst meshes = [];\n\t\tflatTraverseMeshes( this.objects, mesh => {\n\n\t\t\tmeshes.push( mesh );\n\n\t\t} );\n\n\t\t// Sort the geometry so it's in a reliable order\n\t\tmeshes.sort( ( a, b ) => {\n\n\t\t\tif ( a.uuid > b.uuid ) return 1;\n\t\t\tif ( a.uuid < b.uuid ) return - 1;\n\t\t\treturn 0;\n\n\t\t} );\n\n\t\tif ( meshes.length === 0 ) {\n\n\t\t\tmeshes.push( this._getDummyMesh() );\n\n\t\t}\n\n\t\treturn meshes;\n\n\t}\n\n\t_updateIntermediateGeometries() {\n\n\t\tconst { _intermediateGeometry } = this;\n\n\t\tconst meshes = this._getMeshes();\n\t\tconst unusedMeshKeys = new Set( _intermediateGeometry.keys() );\n\t\tconst convertOptions = {\n\t\t\tattributes: this.attributes,\n\t\t\tapplyWorldTransforms: this.applyWorldTransforms,\n\t\t};\n\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst meshKey = mesh.uuid;\n\t\t\tunusedMeshKeys.delete( meshKey );\n\n\t\t\t// initialize the intermediate geometry\n\t\t\t// if the mesh and source geometry have changed in such a way that they are no longer\n\t\t\t// compatible then regenerate the baked geometry from scratch\n\t\t\tlet geom = _intermediateGeometry.get( meshKey );\n\t\t\tif ( ! geom || ! geom.isCompatible( mesh, this.attributes ) ) {\n\n\t\t\t\tif ( geom ) {\n\n\t\t\t\t\tgeom.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tgeom = new BakedGeometry();\n\t\t\t\t_intermediateGeometry.set( meshKey, geom );\n\n\t\t\t}\n\n\t\t\t// transform the geometry into the intermediate buffer geometry, saving whether\n\t\t\t// or not it changed.\n\t\t\tif ( geom.updateFrom( mesh, convertOptions ) ) {\n\n\t\t\t\t// TODO: provide option for only generating the set of attributes that are present\n\t\t\t\t// and are in the attributes array\n\t\t\t\tif ( this.generateMissingAttributes ) {\n\n\t\t\t\t\tsetCommonAttributes( geom, this.attributes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tunusedMeshKeys.forEach( key => {\n\n\t\t\t_intermediateGeometry.delete( key );\n\n\t\t} );\n\n\t}\n\n\tsetObjects( objects ) {\n\n\t\tif ( Array.isArray( objects ) ) {\n\n\t\t\tthis.objects = [ ...objects ];\n\n\t\t} else {\n\n\t\t\tthis.objects = [ objects ];\n\n\t\t}\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tconst { useGroups, overwriteIndex, _intermediateGeometry, _geometryMergeSets } = this;\n\n\t\tconst meshes = this._getMeshes();\n\t\tconst skipAssigningAttributes = [];\n\t\tconst mergeGeometry = [];\n\t\tconst previousMergeInfo = _geometryMergeSets.get( targetGeometry ) || [];\n\n\t\t// update all the intermediate static geometry representations\n\t\tthis._updateIntermediateGeometries();\n\n\t\t// get the list of geometries to merge\n\t\tlet forceUpdate = false;\n\t\tif ( meshes.length !== previousMergeInfo.length ) {\n\n\t\t\tforceUpdate = true;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry.get( mesh.uuid );\n\t\t\tmergeGeometry.push( geom );\n\n\t\t\tconst info = previousMergeInfo[ i ];\n\t\t\tif ( ! info || info.uuid !== geom.uuid ) {\n\n\t\t\t\tskipAssigningAttributes.push( false );\n\t\t\t\tforceUpdate = true;\n\n\t\t\t} else if ( info.version !== geom.version ) {\n\n\t\t\t\tskipAssigningAttributes.push( false );\n\n\t\t\t} else {\n\n\t\t\t\tskipAssigningAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// If we have no geometry to merge then provide an empty geometry.\n\t\tmergeGeometryList( mergeGeometry, targetGeometry, { useGroups, forceUpdate, skipAssigningAttributes, overwriteIndex } );\n\n\t\t// force update means the attribute buffer lengths have changed\n\t\tif ( forceUpdate ) {\n\n\t\t\ttargetGeometry.dispose();\n\n\t\t}\n\n\t\t_geometryMergeSets.set( targetGeometry, mergeGeometry.map( g => ( {\n\t\t\tversion: g.version,\n\t\t\tuuid: g.uuid,\n\t\t} ) ) );\n\n\t\tlet changeType = NO_CHANGE;\n\t\tif ( forceUpdate ) changeType = GEOMETRY_REBUILT;\n\t\telse if ( skipAssigningAttributes.includes( false ) ) changeType = GEOMETRY_ADJUSTED;\n\n\t\treturn {\n\t\t\tchangeType,\n\t\t\tmaterials: getMaterials( meshes ),\n\t\t\tgeometry: targetGeometry,\n\t\t};\n\n\t}\n\n}\n", "import { BufferGeometry } from 'three';\nimport { MeshBVH, SAH } from 'three-mesh-bvh';\nimport { StaticGeometryGenerator, NO_CHANGE, GEOMETRY_ADJUSTED, GEOMETRY_REBUILT } from './utils/StaticGeometryGenerator.js';\nimport { updateMaterialIndexAttribute } from './utils/GeometryPreparationUtils.js';\n\n// collect the textures from the materials\nfunction getTextures( materials ) {\n\n\tconst textureSet = new Set();\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\tconst material = materials[ i ];\n\t\tfor ( const key in material ) {\n\n\t\t\tconst value = material[ key ];\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\ttextureSet.add( value );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn Array.from( textureSet );\n\n}\n\n// collect the lights in the scene\nfunction getLights( objects ) {\n\n\tconst lights = [];\n\tconst iesSet = new Set();\n\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\tobjects[ i ].traverse( c => {\n\n\t\t\tif ( c.visible ) {\n\n\t\t\t\tif (\n\t\t\t\t\tc.isRectAreaLight ||\n\t\t\t\t\tc.isSpotLight ||\n\t\t\t\t\tc.isPointLight ||\n\t\t\t\t\tc.isDirectionalLight\n\t\t\t\t) {\n\n\t\t\t\t\tlights.push( c );\n\n\t\t\t\t\tif ( c.iesMap ) {\n\n\t\t\t\t\t\tiesSet.add( c.iesMap );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tconst iesTextures = Array.from( iesSet ).sort( ( a, b ) => {\n\n\t\tif ( a.uuid < b.uuid ) return 1;\n\t\tif ( a.uuid > b.uuid ) return - 1;\n\t\treturn 0;\n\n\t} );\n\n\treturn { lights, iesTextures };\n\n}\n\nexport class PathTracingSceneGenerator {\n\n\tget initialized() {\n\n\t\treturn Boolean( this.bvh );\n\n\t}\n\n\tconstructor( objects ) {\n\n\t\t// options\n\t\tthis.bvhOptions = {};\n\t\tthis.attributes = [ 'position', 'normal', 'tangent', 'color', 'uv', 'uv2' ];\n\t\tthis.generateBVH = true;\n\n\t\t// state\n\t\tthis.bvh = null;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( objects );\n\t\tthis._bvhWorker = null;\n\t\tthis._pendingGenerate = null;\n\t\tthis._buildAsync = false;\n\n\t}\n\n\tsetObjects( objects ) {\n\n\t\tthis.staticGeometryGenerator.setObjects( objects );\n\n\t}\n\n\tsetBVHWorker( bvhWorker ) {\n\n\t\tthis._bvhWorker = bvhWorker;\n\n\t}\n\n\tasync generateAsync( onProgress = null ) {\n\n\t\tif ( ! this._bvhWorker ) {\n\n\t\t\tthrow new Error( 'PathTracingSceneGenerator: \"setBVHWorker\" must be called before \"generateAsync\" can be called.' );\n\n\t\t}\n\n\t\tif ( this.bvh instanceof Promise ) {\n\n\t\t\t// if a bvh is already being generated we can wait for that to finish\n\t\t\t// and build another with the latest data while sharing the results.\n\t\t\tif ( ! this._pendingGenerate ) {\n\n\t\t\t\tthis._pendingGenerate = new Promise( async () => {\n\n\t\t\t\t\tawait this.bvh;\n\t\t\t\t\tthis._pendingGenerate = null;\n\n\t\t\t\t\t// TODO: support multiple callbacks queued?\n\t\t\t\t\treturn this.generateAsync( onProgress );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn this._pendingGenerate;\n\n\t\t} else {\n\n\t\t\tthis._buildAsync = true;\n\t\t\tconst result = this.generate( onProgress );\n\t\t\tthis._buildAsync = false;\n\n\t\t\tresult.bvh = this.bvh = await result.bvh;\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\tgenerate( onProgress = null ) {\n\n\t\tconst { staticGeometryGenerator, geometry, attributes } = this;\n\t\tconst objects = staticGeometryGenerator.objects;\n\t\tstaticGeometryGenerator.attributes = attributes;\n\n\t\t// update the skeleton animations in case WebGLRenderer is not running\n\t\t// to update it.\n\t\tobjects.forEach( o => {\n\n\t\t\to.traverse( c => {\n\n\t\t\t\tif ( c.isSkinnedMesh && c.skeleton ) {\n\n\t\t\t\t\tc.skeleton.update();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t// generate the geometry\n\t\tconst result = staticGeometryGenerator.generate( geometry );\n\t\tconst materials = result.materials;\n\t\tconst textures = getTextures( materials );\n\t\tconst { lights, iesTextures } = getLights( objects );\n\n\t\tif ( result.changeType !== NO_CHANGE ) {\n\n\t\t\tupdateMaterialIndexAttribute( geometry, materials, materials );\n\n\t\t}\n\n\t\t// only generate a new bvh if the objects used have changed\n\t\tif ( this.generateBVH ) {\n\n\t\t\tif ( this.bvh instanceof Promise ) {\n\n\t\t\t\tthrow new Error( 'PathTracingSceneGenerator: BVH is already building asynchronously.' );\n\n\t\t\t}\n\n\t\t\tif ( result.changeType === GEOMETRY_REBUILT ) {\n\n\t\t\t\tconst bvhOptions = {\n\t\t\t\t\tstrategy: SAH,\n\t\t\t\t\tmaxLeafTris: 1,\n\t\t\t\t\tindirect: true,\n\t\t\t\t\tonProgress,\n\t\t\t\t\t...this.bvhOptions,\n\t\t\t\t};\n\n\t\t\t\tif ( this._buildAsync ) {\n\n\t\t\t\t\tthis.bvh = this._bvhWorker.generate( geometry, bvhOptions );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.bvh = new MeshBVH( geometry, bvhOptions );\n\n\t\t\t\t}\n\n\t\t\t} else if ( result.changeType === GEOMETRY_ADJUSTED ) {\n\n\t\t\t\tthis.bvh.refit();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\tbvhChanged: result.changeType !== NO_CHANGE,\n\t\t\tbvh: this.bvh,\n\t\t\tlights,\n\t\t\tiesTextures,\n\t\t\tgeometry,\n\t\t\tmaterials,\n\t\t\ttextures,\n\t\t\tobjects,\n\t\t};\n\n\t}\n\n}\n\nexport class DynamicPathTracingSceneGenerator extends PathTracingSceneGenerator {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tconsole.warn( 'DynamicPathTracingSceneGenerator has been deprecated and renamed to \"PathTracingSceneGenerator\".' );\n\n\t}\n\n}\n\nexport class PathTracingSceneWorker extends PathTracingSceneGenerator {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tconsole.warn( 'PathTracingSceneWorker has been deprecated and renamed to \"PathTracingSceneGenerator\".' );\n\n\t}\n\n}\n", "import {\r\n\tBufferGeometry,\r\n\tFloat32BufferAttribute,\r\n\tOrthographicCamera,\r\n\tMesh\r\n} from 'three';\r\n\r\nclass Pass {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.isPass = true;\r\n\r\n\t\t// if set to true, the pass is processed by the composer\r\n\t\tthis.enabled = true;\r\n\r\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\r\n\t\tthis.needsSwap = true;\r\n\r\n\t\t// if set to true, the pass clears its buffer before rendering\r\n\t\tthis.clear = false;\r\n\r\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\r\n\t\tthis.renderToScreen = false;\r\n\r\n\t}\r\n\r\n\tsetSize( /* width, height */ ) {}\r\n\r\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\r\n\r\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\r\n\r\n\t}\r\n\r\n\tdispose() {}\r\n\r\n}\r\n\r\n// Helper for passes that need to fill the viewport with a single quad.\r\n\r\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\r\n// https://github.com/mrdoob/three.js/pull/21358\r\n\r\nclass FullscreenTriangleGeometry extends BufferGeometry {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst _geometry = new FullscreenTriangleGeometry();\r\n\r\nclass FullScreenQuad {\r\n\r\n\tconstructor( material ) {\r\n\r\n\t\tthis._mesh = new Mesh( _geometry, material );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis._mesh.geometry.dispose();\r\n\r\n\t}\r\n\r\n\trender( renderer ) {\r\n\r\n\t\trenderer.render( this._mesh, _camera );\r\n\r\n\t}\r\n\r\n\tget material() {\r\n\r\n\t\treturn this._mesh.material;\r\n\r\n\t}\r\n\r\n\tset material( value ) {\r\n\r\n\t\tthis._mesh.material = value;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Pass, FullScreenQuad };\r\n", "import { ShaderMaterial } from 'three';\n\nexport class MaterialBase extends ShaderMaterial {\n\n\tset needsUpdate( v ) {\n\n\t\tsuper.needsUpdate = true;\n\t\tthis.dispatchEvent( {\n\n\t\t\ttype: 'recompilation',\n\n\t\t} );\n\n\t}\n\n\tconstructor( shader ) {\n\n\t\tsuper( shader );\n\n\t\tfor ( const key in this.uniforms ) {\n\n\t\t\tObject.defineProperty( this, key, {\n\n\t\t\t\tget() {\n\n\t\t\t\t\treturn this.uniforms[ key ].value;\n\n\t\t\t\t},\n\n\t\t\t\tset( v ) {\n\n\t\t\t\t\tthis.uniforms[ key ].value = v;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\t// sets the given named define value and sets \"needsUpdate\" to true if it's different\n\tsetDefine( name, value = undefined ) {\n\n\t\tif ( value === undefined || value === null ) {\n\n\t\t\tif ( name in this.defines ) {\n\n\t\t\t\tdelete this.defines[ name ];\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this.defines[ name ] !== value ) {\n\n\t\t\t\tthis.defines[ name ] = value;\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n", "import { NoBlending } from 'three';\nimport { MaterialBase } from '../MaterialBase.js';\n\nexport class BlendMaterial extends MaterialBase {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\tuniforms: {\n\n\t\t\t\ttarget1: { value: null },\n\t\t\t\ttarget2: { value: null },\n\t\t\t\topacity: { value: 1.0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tuniform sampler2D target1;\n\t\t\t\tuniform sampler2D target2;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\n\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\n\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n", "// References\n// - https://jcgt.org/published/0009/04/01/\n// - Code from https://www.shadertoy.com/view/WtGyDm\n\n// functions to generate multi-dimensions variables of the same functions\n// to support 1, 2, 3, and 4 dimensional sobol sampling.\nfunction generateSobolFunctionVariants( dim = 1 ) {\n\n\tlet type = 'uint';\n\tif ( dim > 1 ) {\n\n\t\ttype = 'uvec' + dim;\n\n\t}\n\n\treturn /* glsl */`\n\t\t${ type } sobolReverseBits( ${ type } x ) {\n\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\n\n\t\t}\n\n\t\t${ type } sobolHashCombine( uint seed, ${ type } v ) {\n\n\t\t\treturn seed ^ ( v + ${ type }( ( seed << 6 ) + ( seed >> 2 ) ) );\n\n\t\t}\n\n\t\t${ type } sobolLaineKarrasPermutation( ${ type } x, ${ type } seed ) {\n\n\t\t\tx += seed;\n\t\t\tx ^= x * 0x6c50b47cu;\n\t\t\tx ^= x * 0xb82f1e52u;\n\t\t\tx ^= x * 0xc7afe638u;\n\t\t\tx ^= x * 0x8d22f6e6u;\n\t\t\treturn x;\n\n\t\t}\n\n\t\t${ type } nestedUniformScrambleBase2( ${ type } x, ${ type } seed ) {\n\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\n\t\t\tx = sobolReverseBits( x );\n\t\t\treturn x;\n\n\t\t}\n\t`;\n\n}\n\nfunction generateSobolSampleFunctions( dim = 1 ) {\n\n\tlet utype = 'uint';\n\tlet vtype = 'float';\n\tlet num = '';\n\tlet components = '.r';\n\tlet combineValues = '1u';\n\tif ( dim > 1 ) {\n\n\t\tutype = 'uvec' + dim;\n\t\tvtype = 'vec' + dim;\n\t\tnum = dim + '';\n\t\tif ( dim === 2 ) {\n\n\t\t\tcomponents = '.rg';\n\t\t\tcombineValues = 'uvec2( 1u, 2u )';\n\n\t\t} else if ( dim === 3 ) {\n\n\t\t\tcomponents = '.rgb';\n\t\t\tcombineValues = 'uvec3( 1u, 2u, 3u )';\n\n\t\t} else {\n\n\t\t\tcomponents = '';\n\t\t\tcombineValues = 'uvec4( 1u, 2u, 3u, 4u )';\n\n\t\t}\n\n\t}\n\n\treturn /* glsl */`\n\n\t\t${ vtype } sobol${ num }( int effect ) {\n\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\n\t\t\tuint index = sobolPathIndex;\n\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\n\t\t\t${ vtype } sobol_pt = sobolGetTexturePoint( shuffled_index )${ components };\n\t\t\t${ utype } result = ${ utype }( sobol_pt * 16777216.0 );\n\n\t\t\t${ utype } seed2 = sobolHashCombine( seed, ${ combineValues } );\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\n\n\t\t\treturn SOBOL_FACTOR * ${ vtype }( result >> 8 );\n\n\t\t}\n\t`;\n\n}\n\nexport const sobol_common = /* glsl */`\n\n\t// Utils\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\n\n\t${ generateSobolFunctionVariants( 1 ) }\n\t${ generateSobolFunctionVariants( 2 ) }\n\t${ generateSobolFunctionVariants( 3 ) }\n\t${ generateSobolFunctionVariants( 4 ) }\n\n\tuint sobolHash( uint x ) {\n\n\t\t// finalizer from murmurhash3\n\t\tx ^= x >> 16;\n\t\tx *= 0x85ebca6bu;\n\t\tx ^= x >> 13;\n\t\tx *= 0xc2b2ae35u;\n\t\tx ^= x >> 16;\n\t\treturn x;\n\n\t}\n\n`;\n\nexport const sobol_point_generation = /* glsl */`\n\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\n\t);\n\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\n\n\t\tuint X = 0u;\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\n\n\t\t\tuint mask = ( index >> bit ) & 1u;\n\t\t\tX ^= mask * directions[ bit ];\n\n\t\t}\n\t\treturn X;\n\n\t}\n\n\tvec4 generateSobolPoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\treturn vec4( 0.0 );\n\n\t\t}\n\n\t\t// NOTE: this sobol \"direction\" is also available but we can't write out 5 components\n\t\t// uint x = index & 0x00ffffffu;\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\n\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\n\n\t}\n\n`;\n\nexport const sobol_functions = /* glsl */`\n\n\t// Seeds\n\tuniform sampler2D sobolTexture;\n\tuint sobolPixelIndex = 0u;\n\tuint sobolPathIndex = 0u;\n\tuint sobolBounceIndex = 0u;\n\n\tuint sobolGetSeed( uint bounce, uint effect ) {\n\n\t\treturn sobolHash(\n\t\t\tsobolHashCombine(\n\t\t\t\tsobolHashCombine(\n\t\t\t\t\tsobolHash( bounce ),\n\t\t\t\t\tsobolPixelIndex\n\t\t\t\t),\n\t\t\t\teffect\n\t\t\t)\n\t\t);\n\n\t}\n\n\tvec4 sobolGetTexturePoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\tindex = index % SOBOL_MAX_POINTS;\n\n\t\t}\n\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\n\t\tuint y = index / dim.x;\n\t\tuint x = index - y * dim.x;\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\n\t\treturn texture( sobolTexture, uv );\n\n\t}\n\n\t${ generateSobolSampleFunctions( 1 ) }\n\t${ generateSobolSampleFunctions( 2 ) }\n\t${ generateSobolSampleFunctions( 3 ) }\n\t${ generateSobolSampleFunctions( 4 ) }\n\n`;\n", "import { FloatType, NearestFilter, NoBlending, RGBAFormat, Vector2, WebGLRenderTarget } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MaterialBase } from '../materials/MaterialBase.js';\nimport { sobol_common, sobol_point_generation } from '../shader/rand/sobol.glsl.js';\n\nclass SobolNumbersMaterial extends MaterialBase {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\tuniforms: {\n\n\t\t\t\tresolution: { value: new Vector2() },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t${ sobol_common }\n\t\t\t\t${ sobol_point_generation }\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n\nexport class SobolNumberMapGenerator {\n\n\tgenerate( renderer, dimensions = 256 ) {\n\n\t\tconst target = new WebGLRenderTarget( dimensions, dimensions, {\n\n\t\t\ttype: FloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tminFilter: NearestFilter,\n\t\t\tmagFilter: NearestFilter,\n\t\t\tgenerateMipmaps: false,\n\n\t\t} );\n\n\t\tconst ogTarget = renderer.getRenderTarget();\n\t\trenderer.setRenderTarget( target );\n\n\t\tconst quad = new FullScreenQuad( new SobolNumbersMaterial() );\n\t\tquad.material.resolution.set( dimensions, dimensions );\n\t\tquad.render( renderer );\n\n\t\trenderer.setRenderTarget( ogTarget );\n\t\tquad.dispose();\n\n\t\treturn target;\n\n\t}\n\n}\n", "import { PerspectiveCamera } from 'three';\n\nexport class PhysicalCamera extends PerspectiveCamera {\n\n\tset bokehSize( size ) {\n\n\t\tthis.fStop = this.getFocalLength() / size;\n\n\t}\n\n\tget bokehSize() {\n\n\t\treturn this.getFocalLength() / this.fStop;\n\n\t}\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.fStop = 1.4;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 25;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fStop = source.fStop;\n\t\tthis.apertureBlades = source.apertureBlades;\n\t\tthis.apertureRotation = source.apertureRotation;\n\t\tthis.focusDistance = source.focusDistance;\n\t\tthis.anamorphicRatio = source.anamorphicRatio;\n\n\t\treturn this;\n\n\t}\n\n}\n", "import { PhysicalCamera } from '../objects/PhysicalCamera.js';\nexport class PhysicalCameraUniform {\n\n\tconstructor() {\n\n\t\tthis.bokehSize = 0;\n\t\tthis.apertureBlades = 0;\n\t\tthis.apertureRotation = 0;\n\t\tthis.focusDistance = 10;\n\t\tthis.anamorphicRatio = 1;\n\n\t}\n\n\tupdateFrom( camera ) {\n\n\t\tif ( camera instanceof PhysicalCamera ) {\n\n\t\t\tthis.bokehSize = camera.bokehSize;\n\t\t\tthis.apertureBlades = camera.apertureBlades;\n\t\t\tthis.apertureRotation = camera.apertureRotation;\n\t\t\tthis.focusDistance = camera.focusDistance;\n\t\t\tthis.anamorphicRatio = camera.anamorphicRatio;\n\n\t\t} else {\n\n\t\t\tthis.bokehSize = 0;\n\t\t\tthis.apertureRotation = 0;\n\t\t\tthis.apertureBlades = 0;\n\t\t\tthis.focusDistance = 10;\n\t\t\tthis.anamorphicRatio = 1;\n\n\t\t}\n\n\t}\n\n}\n", "import { DataUtils } from 'three';\n\n\nexport function toHalfFloatArray( f32Array ) {\n\n\tconst f16Array = new Uint16Array( f32Array.length );\n\tfor ( let i = 0, n = f32Array.length; i < n; ++ i ) {\n\n\t\tf16Array[ i ] = DataUtils.toHalfFloat( f32Array[ i ] );\n\n\t}\n\n\treturn f16Array;\n\n}\n", "import { DataTexture, RedFormat, LinearFilter, DataUtils, HalfFloatType, Source, RepeatWrapping, RGBAFormat, FloatType, ClampToEdgeWrapping } from 'three';\nimport { toHalfFloatArray } from '../utils/TextureUtils.js';\n\nfunction binarySearchFindClosestIndexOf( array, targetValue, offset = 0, count = array.length ) {\n\n\tlet lower = offset;\n\tlet upper = offset + count - 1;\n\n\twhile ( lower < upper ) {\n\n\t\t// calculate the midpoint for this iteration using a bitwise shift right operator to save 1 floating point multiplication\n\t\t// and 1 truncation from the double tilde operator to improve performance\n\t\t// this results in much better performance over using standard \"~ ~ ( (lower + upper) ) / 2\" to calculate the midpoint\n\t\tconst mid = ( lower + upper ) >> 1;\n\n\t\t// check if the middle array value is above or below the target and shift\n\t\t// which half of the array we're looking at\n\t\tif ( array[ mid ] < targetValue ) {\n\n\t\t\tlower = mid + 1;\n\n\t\t} else {\n\n\t\t\tupper = mid;\n\n\t\t}\n\n\t}\n\n\treturn lower - offset;\n\n}\n\nfunction colorToLuminance( r, g, b ) {\n\n\t// https://en.wikipedia.org/wiki/Relative_luminance\n\treturn 0.2126 * r + 0.7152 * g + 0.0722 * b;\n\n}\n\n// ensures the data is all floating point values and flipY is false\nfunction preprocessEnvMap( envMap, targetType = HalfFloatType ) {\n\n\tconst map = envMap.clone();\n\tmap.source = new Source( { ...map.image } );\n\tconst { width, height, data } = map.image;\n\n\t// TODO: is there a simple way to avoid cloning and adjusting the env map data here?\n\t// convert the data from half float uint 16 arrays to float arrays for cdf computation\n\tlet newData = data;\n\tif ( map.type !== targetType ) {\n\n\t\tif ( targetType === HalfFloatType ) {\n\n\t\t\tnewData = new Uint16Array( data.length );\n\n\t\t} else {\n\n\t\t\tnewData = new Float32Array( data.length );\n\n\t\t}\n\n\t\tlet maxIntValue;\n\t\tif ( data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array ) {\n\n\t\t\tmaxIntValue = 2 ** ( 8 * data.BYTES_PER_ELEMENT - 1 ) - 1;\n\n\t\t} else {\n\n\t\t\tmaxIntValue = 2 ** ( 8 * data.BYTES_PER_ELEMENT ) - 1;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\n\n\t\t\tlet v = data[ i ];\n\t\t\tif ( map.type === HalfFloatType ) {\n\n\t\t\t\tv = DataUtils.fromHalfFloat( data[ i ] );\n\n\t\t\t}\n\n\t\t\tif ( map.type !== FloatType && map.type !== HalfFloatType ) {\n\n\t\t\t\tv /= maxIntValue;\n\n\t\t\t}\n\n\t\t\tif ( targetType === HalfFloatType ) {\n\n\t\t\t\tnewData[ i ] = DataUtils.toHalfFloat( v );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmap.image.data = newData;\n\t\tmap.type = targetType;\n\n\t}\n\n\t// remove any y flipping for cdf computation\n\tif ( map.flipY ) {\n\n\t\tconst ogData = newData;\n\t\tnewData = newData.slice();\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst newY = height - y - 1;\n\t\t\t\tconst ogIndex = 4 * ( y * width + x );\n\t\t\t\tconst newIndex = 4 * ( newY * width + x );\n\n\t\t\t\tnewData[ newIndex + 0 ] = ogData[ ogIndex + 0 ];\n\t\t\t\tnewData[ newIndex + 1 ] = ogData[ ogIndex + 1 ];\n\t\t\t\tnewData[ newIndex + 2 ] = ogData[ ogIndex + 2 ];\n\t\t\t\tnewData[ newIndex + 3 ] = ogData[ ogIndex + 3 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tmap.flipY = false;\n\t\tmap.image.data = newData;\n\n\t}\n\n\treturn map;\n\n}\n\nexport class EquirectHdrInfoUniform {\n\n\tconstructor() {\n\n\t\t// Default to a white texture and associated weights so we don't\n\t\t// just render black initially.\n\t\tconst blackTex = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 0, 0, 0 ] ) ), 1, 1 );\n\t\tblackTex.type = HalfFloatType;\n\t\tblackTex.format = RGBAFormat;\n\t\tblackTex.minFilter = LinearFilter;\n\t\tblackTex.magFilter = LinearFilter;\n\t\tblackTex.wrapS = RepeatWrapping;\n\t\tblackTex.wrapT = RepeatWrapping;\n\t\tblackTex.generateMipmaps = false;\n\t\tblackTex.needsUpdate = true;\n\n\t\t// Stores a map of [0, 1] value -> cumulative importance row & pdf\n\t\t// used to sampling a random value to a relevant row to sample from\n\t\tconst marginalWeights = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 1 ] ) ), 1, 2 );\n\t\tmarginalWeights.type = HalfFloatType;\n\t\tmarginalWeights.format = RedFormat;\n\t\tmarginalWeights.minFilter = LinearFilter;\n\t\tmarginalWeights.magFilter = LinearFilter;\n\t\tmarginalWeights.generateMipmaps = false;\n\t\tmarginalWeights.needsUpdate = true;\n\n\t\t// Stores a map of [0, 1] value -> cumulative importance column & pdf\n\t\t// used to sampling a random value to a relevant pixel to sample from\n\t\tconst conditionalWeights = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 0, 1, 1 ] ) ), 2, 2 );\n\t\tconditionalWeights.type = HalfFloatType;\n\t\tconditionalWeights.format = RedFormat;\n\t\tconditionalWeights.minFilter = LinearFilter;\n\t\tconditionalWeights.magFilter = LinearFilter;\n\t\tconditionalWeights.generateMipmaps = false;\n\t\tconditionalWeights.needsUpdate = true;\n\n\t\tthis.map = blackTex;\n\t\tthis.marginalWeights = marginalWeights;\n\t\tthis.conditionalWeights = conditionalWeights;\n\t\tthis.totalSum = 0;\n\n\t\t// TODO: Add support for float or half float types here. We need to pass this into\n\t\t// the preprocess function and ensure our CDF and MDF textures are appropriately sized\n\t\t// Ideally we wouldn't upscale a bit depth if we didn't need to.\n\t\t// this.type = HalfFloatType;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.marginalWeights.dispose();\n\t\tthis.conditionalWeights.dispose();\n\t\tthis.map.dispose();\n\n\t}\n\n\tupdateFrom( hdr ) {\n\n\t\t// https://github.com/knightcrawler25/GLSL-PathTracer/blob/3c6fd9b6b3da47cd50c527eeb45845eef06c55c3/src/loaders/hdrloader.cpp\n\t\t// https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#InfiniteAreaLights\n\t\tconst map = preprocessEnvMap( hdr );\n\t\tmap.wrapS = RepeatWrapping;\n\t\tmap.wrapT = ClampToEdgeWrapping;\n\n\t\tconst { width, height, data } = map.image;\n\n\t\t// \"conditional\" = \"pixel relative to row pixels sum\"\n\t\t// \"marginal\" = \"row relative to row sum\"\n\n\t\t// track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image\n\t\tconst pdfConditional = new Float32Array( width * height );\n\t\tconst cdfConditional = new Float32Array( width * height );\n\n\t\tconst pdfMarginal = new Float32Array( height );\n\t\tconst cdfMarginal = new Float32Array( height );\n\n\t\tlet totalSumValue = 0.0;\n\t\tlet cumulativeWeightMarginal = 0.0;\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tlet cumulativeRowWeight = 0.0;\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst r = DataUtils.fromHalfFloat( data[ 4 * i + 0 ] );\n\t\t\t\tconst g = DataUtils.fromHalfFloat( data[ 4 * i + 1 ] );\n\t\t\t\tconst b = DataUtils.fromHalfFloat( data[ 4 * i + 2 ] );\n\n\t\t\t\t// the probability of the pixel being selected in this row is the\n\t\t\t\t// scale of the luminance relative to the rest of the pixels.\n\t\t\t\t// TODO: this should also account for the solid angle of the pixel when sampling\n\t\t\t\tconst weight = colorToLuminance( r, g, b );\n\t\t\t\tcumulativeRowWeight += weight;\n\t\t\t\ttotalSumValue += weight;\n\n\t\t\t\tpdfConditional[ i ] = weight;\n\t\t\t\tcdfConditional[ i ] = cumulativeRowWeight;\n\n\t\t\t}\n\n\t\t\t// can happen if the row is all black\n\t\t\tif ( cumulativeRowWeight !== 0 ) {\n\n\t\t\t\t// scale the pdf and cdf to [0.0, 1.0]\n\t\t\t\tfor ( let i = y * width, l = y * width + width; i < l; i ++ ) {\n\n\t\t\t\t\tpdfConditional[ i ] /= cumulativeRowWeight;\n\t\t\t\t\tcdfConditional[ i ] /= cumulativeRowWeight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcumulativeWeightMarginal += cumulativeRowWeight;\n\n\t\t\t// compute the marginal pdf and cdf along the height of the map.\n\t\t\tpdfMarginal[ y ] = cumulativeRowWeight;\n\t\t\tcdfMarginal[ y ] = cumulativeWeightMarginal;\n\n\t\t}\n\n\t\t// can happen if the texture is all black\n\t\tif ( cumulativeWeightMarginal !== 0 ) {\n\n\t\t\t// scale the marginal pdf and cdf to [0.0, 1.0]\n\t\t\tfor ( let i = 0, l = pdfMarginal.length; i < l; i ++ ) {\n\n\t\t\t\tpdfMarginal[ i ] /= cumulativeWeightMarginal;\n\t\t\t\tcdfMarginal[ i ] /= cumulativeWeightMarginal;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute a sorted index of distributions and the probabilities along them for both\n\t\t// the marginal and conditional data. These will be used to sample with a random number\n\t\t// to retrieve a uv value to sample in the environment map.\n\t\t// These values continually increase so it's okay to interpolate between them.\n\t\tconst marginalDataArray = new Uint16Array( height );\n\t\tconst conditionalDataArray = new Uint16Array( width * height );\n\n\t\t// we add a half texel offset so we're sampling the center of the pixel\n\t\tfor ( let i = 0; i < height; i ++ ) {\n\n\t\t\tconst dist = ( i + 1 ) / height;\n\t\t\tconst row = binarySearchFindClosestIndexOf( cdfMarginal, dist );\n\n\t\t\tmarginalDataArray[ i ] = DataUtils.toHalfFloat( ( row + 0.5 ) / height );\n\n\t\t}\n\n\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst dist = ( x + 1 ) / width;\n\t\t\t\tconst col = binarySearchFindClosestIndexOf( cdfConditional, dist, y * width, width );\n\n\t\t\t\tconditionalDataArray[ i ] = DataUtils.toHalfFloat( ( col + 0.5 ) / width );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispose();\n\n\t\tconst { marginalWeights, conditionalWeights } = this;\n\t\tmarginalWeights.image = { width: height, height: 1, data: marginalDataArray };\n\t\tmarginalWeights.needsUpdate = true;\n\n\t\tconditionalWeights.image = { width, height, data: conditionalDataArray };\n\t\tconditionalWeights.needsUpdate = true;\n\n\t\tthis.totalSum = totalSumValue;\n\t\tthis.map = map;\n\n\t}\n\n}\n", "import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, Vector3, Quaternion, Matrix4, NearestFilter } from 'three';\nimport { bufferToHash } from '../utils/bufferToHash.js';\n\nconst LIGHT_PIXELS = 6;\nconst RECT_AREA_LIGHT = 0;\nconst CIRC_AREA_LIGHT = 1;\nconst SPOT_LIGHT = 2;\nconst DIR_LIGHT = 3;\nconst POINT_LIGHT = 4;\n\nconst u = new Vector3();\nconst v = new Vector3();\nconst m = new Matrix4();\nconst worldQuaternion = new Quaternion();\nconst eye = new Vector3();\nconst target = new Vector3();\nconst up = new Vector3( 0, 1, 0 );\nexport class LightsInfoUniformStruct {\n\n\tconstructor() {\n\n\t\tconst tex = new DataTexture( new Float32Array( 4 ), 1, 1 );\n\t\ttex.format = RGBAFormat;\n\t\ttex.type = FloatType;\n\t\ttex.wrapS = ClampToEdgeWrapping;\n\t\ttex.wrapT = ClampToEdgeWrapping;\n\t\ttex.generateMipmaps = false;\n\t\ttex.minFilter = NearestFilter;\n\t\ttex.magFilter = NearestFilter;\n\n\t\tthis.tex = tex;\n\t\tthis.count = 0;\n\n\t}\n\n\tupdateFrom( lights, iesTextures = [] ) {\n\n\t\tconst tex = this.tex;\n\t\tconst pixelCount = Math.max( lights.length * LIGHT_PIXELS, 1 );\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\n\n\t\tif ( tex.image.width !== dimension ) {\n\n\t\t\ttex.dispose();\n\n\t\t\ttex.image.data = new Float32Array( dimension * dimension * 4 );\n\t\t\ttex.image.width = dimension;\n\t\t\ttex.image.height = dimension;\n\n\t\t}\n\n\t\tconst floatArray = tex.image.data;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst l = lights[ i ];\n\n\t\t\tconst baseIndex = i * LIGHT_PIXELS * 4;\n\t\t\tlet index = 0;\n\n\t\t\t// initialize to 0\n\t\t\tfor ( let p = 0; p < LIGHT_PIXELS * 4; p ++ ) {\n\n\t\t\t\tfloatArray[ baseIndex + p ] = 0;\n\n\t\t\t}\n\n\t\t\t// sample 1\n\t\t    // position\n\t\t\tl.getWorldPosition( v );\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\n\n\t\t\t// type\n\t\t\tlet type = RECT_AREA_LIGHT;\n\t\t\tif ( l.isRectAreaLight && l.isCircular ) {\n\n\t\t\t\ttype = CIRC_AREA_LIGHT;\n\n\t\t\t} else if ( l.isSpotLight ) {\n\n\t\t\t\ttype = SPOT_LIGHT;\n\n\t\t\t} else if ( l.isDirectionalLight ) {\n\n\t\t\t\ttype = DIR_LIGHT;\n\n\t\t\t} else if ( l.isPointLight ) {\n\n\t\t\t\ttype = POINT_LIGHT;\n\n\t\t\t}\n\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = type;\n\n\t\t\t// sample 2\n\t\t\t// color\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.r;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.g;\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.b;\n\n\t\t\t// intensity\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.intensity;\n\n\t\t\tl.getWorldQuaternion( worldQuaternion );\n\n\t\t\tif ( l.isRectAreaLight ) {\n\n\t\t\t\t// sample 3\n\t\t\t\t// u vector\n\t\t\t\tu.set( l.width, 0, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\n\t\t\t\tindex ++;\n\n\t\t\t\t// sample 4\n\t\t\t\t// v vector\n\t\t\t\tv.set( 0, l.height, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\n\n\t\t\t\t// area\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.cross( v ).length() * ( l.isCircular ? ( Math.PI / 4.0 ) : 1.0 );\n\n\t\t\t} else if ( l.isSpotLight ) {\n\n\t\t\t\tconst radius = l.radius || 0;\n\t\t\t\teye.setFromMatrixPosition( l.matrixWorld );\n\t\t\t\ttarget.setFromMatrixPosition( l.target.matrixWorld );\n\t\t\t\tm.lookAt( eye, target, up );\n\t\t\t\tworldQuaternion.setFromRotationMatrix( m );\n\n\t\t\t\t// sample 3\n\t\t\t\t// u vector\n\t\t\t\tu.set( 1, 0, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\n\t\t\t\tindex ++;\n\n\t\t\t\t// sample 4\n\t\t\t\t// v vector\n\t\t\t\tv.set( 0, 1, 0 ).applyQuaternion( worldQuaternion );\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\n\n\t\t\t\t// area\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.PI * radius * radius;\n\n\t\t\t\t// sample 5\n\t\t\t\t// radius\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = radius;\n\n\t\t\t\t// decay\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\n\n\t\t\t\t// distance\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\n\n\t\t\t\t// coneCos\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle );\n\n\t\t\t\t// sample 6\n\t\t\t\t// penumbraCos\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle * ( 1 - l.penumbra ) );\n\n\t\t\t\t// iesProfile\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.iesMap ? iesTextures.indexOf( l.iesMap ) : - 1;\n\n\t\t\t} else if ( l.isPointLight ) {\n\n\t\t\t\tconst worldPosition = u.setFromMatrixPosition( l.matrixWorld );\n\n\t\t\t\t// sample 3\n\t\t\t\t// u vector\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.z;\n\t\t\t\tindex ++;\n\n\t\t\t\t// sample 4\n\t\t\t\tindex += 4;\n\n\t\t\t\t// sample 5\n\t\t\t\tindex += 1;\n\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\n\n\t\t\t} else if ( l.isDirectionalLight ) {\n\n\t\t\t\tconst worldPosition = u.setFromMatrixPosition( l.matrixWorld );\n\t\t\t\tconst targetPosition = v.setFromMatrixPosition( l.target.matrixWorld );\n\t\t\t\ttarget.subVectors( worldPosition, targetPosition ).normalize();\n\n\t\t\t\t// sample 3\n\t\t\t\t// u vector\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.x;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.y;\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.count = lights.length;\n\n\t\tconst hash = bufferToHash( floatArray.buffer );\n\t\tif ( this.hash !== hash ) {\n\n\t\t\tthis.hash = hash;\n\t\t\ttex.needsUpdate = true;\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n", "import { DataArrayTexture, FloatType, RGBAFormat } from 'three';\nimport { FloatVertexAttributeTexture } from 'three-mesh-bvh';\n\nfunction copyArrayToArray( fromArray, fromStride, toArray, toStride, offset ) {\n\n\tif ( fromStride > toStride ) {\n\n\t\tthrow new Error();\n\n\t}\n\n\t// scale non-float values to their normalized range\n\tconst count = fromArray.length / fromStride;\n\tconst bpe = fromArray.constructor.BYTES_PER_ELEMENT * 8;\n\tlet maxValue = 1.0;\n\tswitch ( fromArray.constructor ) {\n\n\tcase Uint8Array:\n\tcase Uint16Array:\n\tcase Uint32Array:\n\t\tmaxValue = 2 ** bpe - 1;\n\t\tbreak;\n\n\tcase Int8Array:\n\tcase Int16Array:\n\tcase Int32Array:\n\t\tmaxValue = 2 ** ( bpe - 1 ) - 1;\n\t\tbreak;\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tconst i4 = 4 * i;\n\t\tconst is = fromStride * i;\n\t\tfor ( let j = 0; j < toStride; j ++ ) {\n\n\t\t\ttoArray[ offset + i4 + j ] = fromStride >= j + 1 ? fromArray[ is + j ] / maxValue : 0;\n\n\t\t}\n\n\t}\n\n}\n\nexport class FloatAttributeTextureArray extends DataArrayTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._textures = [];\n\t\tthis.type = FloatType;\n\t\tthis.format = RGBAFormat;\n\t\tthis.internalFormat = 'RGBA32F';\n\n\t}\n\n\tupdateAttribute( index, attr ) {\n\n\t\t// update the texture\n\t\tconst tex = this._textures[ index ];\n\t\ttex.updateFrom( attr );\n\n\t\t// ensure compatibility\n\t\tconst baseImage = tex.image;\n\t\tconst image = this.image;\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height ) {\n\n\t\t\tthrow new Error( 'FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.' );\n\n\t\t}\n\n\t\t// update the image\n\t\tconst { width, height, data } = image;\n\t\tconst length = width * height * 4;\n\t\tconst offset = length * index;\n\t\tlet itemSize = attr.itemSize;\n\t\tif ( itemSize === 3 ) {\n\n\t\t\titemSize = 4;\n\n\t\t}\n\n\t\t// copy the data\n\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\n\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tsetAttributes( attrs ) {\n\n\t\t// ensure the attribute count\n\t\tconst itemCount = attrs[ 0 ].count;\n\t\tconst attrsLength = attrs.length;\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\n\n\t\t\tif ( attrs[ i ].count !== itemCount ) {\n\n\t\t\t\tthrow new Error( 'FloatAttributeTextureArray: All attributes must have the same item count.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// initialize all textures\n\t\tconst textures = this._textures;\n\t\twhile ( textures.length < attrsLength ) {\n\n\t\t\tconst tex = new FloatVertexAttributeTexture();\n\t\t\ttextures.push( tex );\n\n\t\t}\n\n\t\twhile ( textures.length > attrsLength ) {\n\n\t\t\ttextures.pop();\n\n\t\t}\n\n\t\t// update all textures\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\n\n\t\t\ttextures[ i ].updateFrom( attrs[ i ] );\n\n\t\t}\n\n\t\t// determine if we need to create a new array\n\t\tconst baseTexture = textures[ 0 ];\n\t\tconst baseImage = baseTexture.image;\n\t\tconst image = this.image;\n\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height || baseImage.depth !== attrsLength ) {\n\n\t\t\timage.width = baseImage.width;\n\t\t\timage.height = baseImage.height;\n\t\t\timage.depth = attrsLength;\n\t\t\timage.data = new Float32Array( image.width * image.height * image.depth * 4 );\n\n\t\t}\n\n\t\t// copy the other texture data into the data array texture\n\t\tconst { data, width, height } = image;\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\n\n\t\t\tconst tex = textures[ i ];\n\t\t\tconst length = width * height * 4;\n\t\t\tconst offset = length * i;\n\n\t\t\tlet itemSize = attrs[ i ].itemSize;\n\t\t\tif ( itemSize === 3 ) {\n\n\t\t\t\titemSize = 4;\n\n\t\t\t}\n\n\t\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\n\n\t\t}\n\n\t\t// reset the texture\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\n}\n", "import { FloatAttributeTextureArray } from './FloatAttributeTextureArray.js';\n\nexport class AttributesTextureArray extends FloatAttributeTextureArray {\n\n\tupdateNormalAttribute( attr ) {\n\n\t\tthis.updateAttribute( 0, attr );\n\n\t}\n\n\tupdateTangentAttribute( attr ) {\n\n\t\tthis.updateAttribute( 1, attr );\n\n\t}\n\n\tupdateUvAttribute( attr ) {\n\n\t\tthis.updateAttribute( 2, attr );\n\n\t}\n\n\tupdateColorAttribute( attr ) {\n\n\t\tthis.updateAttribute( 3, attr );\n\n\t}\n\n\tupdateFrom( normal, tangent, uv, color ) {\n\n\t\tthis.setAttributes( [ normal, tangent, uv, color ] );\n\n\t}\n\n}\n", "function uuidSort( a, b ) {\n\n\tif ( a.uuid < b.uuid ) return 1;\n\tif ( a.uuid > b.uuid ) return - 1;\n\treturn 0;\n\n}\n\n// we must hash the texture to determine uniqueness using the encoding, as well, because the\n// when rendering each texture to the texture array they must have a consistent color space.\nexport function getTextureHash( t ) {\n\n\treturn `${ t.source.uuid }:${ t.colorSpace }`;\n\n}\n\n// reduce the set of textures to just those with a unique source while retaining\n// the order of the textures.\nfunction reduceTexturesToUniqueSources( textures ) {\n\n\tconst sourceSet = new Set();\n\tconst result = [];\n\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\tconst tex = textures[ i ];\n\t\tconst hash = getTextureHash( tex );\n\t\tif ( ! sourceSet.has( hash ) ) {\n\n\t\t\tsourceSet.add( hash );\n\t\t\tresult.push( tex );\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\nexport function getIesTextures( lights ) {\n\n\tconst textures = lights.map( l => l.iesMap || null ).filter( t => t );\n\tconst textureSet = new Set( textures );\n\treturn Array.from( textureSet ).sort( uuidSort );\n\n}\n\nexport function getTextures( materials ) {\n\n\tconst textureSet = new Set();\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\tconst material = materials[ i ];\n\t\tfor ( const key in material ) {\n\n\t\t\tconst value = material[ key ];\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\ttextureSet.add( value );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst textureArray = Array.from( textureSet );\n\treturn reduceTexturesToUniqueSources( textureArray ).sort( uuidSort );\n\n}\n\nexport function getLights( scene ) {\n\n\tconst lights = [];\n\tscene.traverse( c => {\n\n\t\tif ( c.visible ) {\n\n\t\t\tif (\n\t\t\t\tc.isRectAreaLight ||\n\t\t\t\tc.isSpotLight ||\n\t\t\t\tc.isPointLight ||\n\t\t\t\tc.isDirectionalLight\n\t\t\t) {\n\n\t\t\t\tlights.push( c );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn lights.sort( uuidSort );\n\n}\n", "import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, FrontSide, BackSide, DoubleSide, NearestFilter } from 'three';\nimport { getTextureHash } from '../core/utils/sceneUpdateUtils.js';\nimport { bufferToHash } from '../utils/bufferToHash.js';\n\nconst MATERIAL_PIXELS = 45;\nconst MATERIAL_STRIDE = MATERIAL_PIXELS * 4;\n\nclass MaterialFeatures {\n\n\tconstructor() {\n\n\t\tthis._features = {};\n\n\t}\n\n\tisUsed( feature ) {\n\n\t\treturn feature in this._features;\n\n\t}\n\n\tsetUsed( feature, used = true ) {\n\n\t\tif ( used === false ) {\n\n\t\t\tdelete this._features[ feature ];\n\n\t\t} else {\n\n\t\t\tthis._features[ feature ] = true;\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis._features = {};\n\n\t}\n\n}\n\nexport class MaterialsTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\n\n\t\tthis.format = RGBAFormat;\n\t\tthis.type = FloatType;\n\t\tthis.wrapS = ClampToEdgeWrapping;\n\t\tthis.wrapT = ClampToEdgeWrapping;\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.features = new MaterialFeatures();\n\n\t}\n\n\tupdateFrom( materials, textures ) {\n\n\t\tfunction getTexture( material, key, def = - 1 ) {\n\n\t\t\tif ( key in material && material[ key ] ) {\n\n\t\t\t\tconst hash = getTextureHash( material[ key ] );\n\t\t\t\treturn textureLookUp[ hash ];\n\n\t\t\t} else {\n\n\t\t\t\treturn def;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getField( material, key, def ) {\n\n\t\t\treturn key in material ? material[ key ] : def;\n\n\t\t}\n\n\t\tfunction writeTextureMatrixToArray( material, textureKey, array, offset ) {\n\n\t\t\tconst texture = material[ textureKey ] && material[ textureKey ].isTexture ? material[ textureKey ] : null;\n\n\t\t\t// check if texture exists\n\t\t\tif ( texture ) {\n\n\t\t\t\tif ( texture.matrixAutoUpdate ) {\n\n\t\t\t\t\ttexture.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tconst elements = texture.matrix.elements;\n\n\t\t\t\tlet i = 0;\n\n\t\t\t\t// first row\n\t\t\t\tarray[ offset + i ++ ] = elements[ 0 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 3 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 6 ];\n\t\t\t\ti ++;\n\n\t\t\t\t// second row\n\t\t\t\tarray[ offset + i ++ ] = elements[ 1 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 4 ];\n\t\t\t\tarray[ offset + i ++ ] = elements[ 7 ];\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn 8;\n\n\t\t}\n\n\t\tlet index = 0;\n\t\tconst pixelCount = materials.length * MATERIAL_PIXELS;\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) ) || 1;\n\t\tconst { image, features } = this;\n\n\t\t// index the list of textures based on shareable source\n\t\tconst textureLookUp = {};\n\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\n\n\t\t\ttextureLookUp[ getTextureHash( textures[ i ] ) ] = i;\n\n\t\t}\n\n\t\tif ( image.width !== dimension ) {\n\n\t\t\tthis.dispose();\n\n\t\t\timage.data = new Float32Array( dimension * dimension * 4 );\n\t\t\timage.width = dimension;\n\t\t\timage.height = dimension;\n\n\t\t}\n\n\t\tconst floatArray = image.data;\n\n\t\t// on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\n\t\t// can't encode texture ids that way.\n\t\t// const intArray = new Int32Array( floatArray.buffer );\n\n\t\tfeatures.reset();\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tconst m = materials[ i ];\n\n\t\t\tif ( m.isFogVolumeMaterial ) {\n\n\t\t\t\tfeatures.setUsed( 'FOG' );\n\n\t\t\t\tfor ( let j = 0; j < MATERIAL_STRIDE; j ++ ) {\n\n\t\t\t\t\tfloatArray[ index + j ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// sample 0 .rgb\n\t\t\t\tfloatArray[ index + 0 * 4 + 0 ] = m.color.r;\n\t\t\t\tfloatArray[ index + 0 * 4 + 1 ] = m.color.g;\n\t\t\t\tfloatArray[ index + 0 * 4 + 2 ] = m.color.b;\n\n\t\t\t\t// sample 2 .a\n\t\t\t\tfloatArray[ index + 2 * 4 + 3 ] = getField( m, 'emissiveIntensity', 0.0 );\n\n\t\t\t\t// sample 3 .rgb\n\t\t\t\tfloatArray[ index + 3 * 4 + 0 ] = m.emissive.r;\n\t\t\t\tfloatArray[ index + 3 * 4 + 1 ] = m.emissive.g;\n\t\t\t\tfloatArray[ index + 3 * 4 + 2 ] = m.emissive.b;\n\n\t\t\t\t// sample 13 .g\n\t\t\t\t// reusing opacity field\n\t\t\t\tfloatArray[ index + 13 * 4 + 1 ] = m.density;\n\n\t\t\t\t// side\n\t\t\t\tfloatArray[ index + 13 * 4 + 3 ] = 0.0;\n\n\t\t\t\t// sample 14 .b\n\t\t\t\tfloatArray[ index + 14 * 4 + 2 ] = 1 << 2;\n\n\t\t\t\tindex += MATERIAL_STRIDE;\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// sample 0\n\t\t\t// color\n\t\t\tfloatArray[ index ++ ] = m.color.r;\n\t\t\tfloatArray[ index ++ ] = m.color.g;\n\t\t\tfloatArray[ index ++ ] = m.color.b;\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'map' );\n\n\t\t\t// sample 1\n\t\t\t// metalness & roughness\n\t\t\tfloatArray[ index ++ ] = getField( m, 'metalness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'metalnessMap' );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'roughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'roughnessMap' );\n\n\t\t\t// sample 2\n\t\t\t// transmission & emissiveIntensity\n\t\t\t// three.js assumes a default f0 of 0.04 if no ior is provided which equates to an ior of 1.5\n\t\t\tfloatArray[ index ++ ] = getField( m, 'ior', 1.5 );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'transmission', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'transmissionMap' );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'emissiveIntensity', 0.0 );\n\n\t\t\t// sample 3\n\t\t\t// emission\n\t\t\tif ( 'emissive' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.r;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.g;\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'emissiveMap' );\n\n\t\t\t// sample 4\n\t\t\t// normals\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'normalMap' );\n\t\t\tif ( 'normalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.y;\n\n \t\t\t} else {\n\n \t\t\t\tfloatArray[ index ++ ] = 1;\n \t\t\t\tfloatArray[ index ++ ] = 1;\n\n \t\t\t}\n\n\t\t\t// clearcoat\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoat', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatMap' ); // sample 5\n\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoatRoughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatRoughnessMap' );\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatNormalMap' );\n\n\t\t\t// sample 6\n\t\t\tif ( 'clearcoatNormalScale' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.x;\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.y;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1;\n\t\t\t\tfloatArray[ index ++ ] = 1;\n\n\t\t\t}\n\n\t\t\tindex ++;\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheen', 0.0 );\n\n\t\t\t// sample 7\n\t\t\t// sheen\n\t\t\tif ( 'sheenColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenColorMap' );\n\n\t\t\t// sample 8\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheenRoughness', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenRoughnessMap' );\n\n\t\t\t// iridescence\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceMap' );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceThicknessMap' );\n\n\t\t\t// sample 9\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescence', 0.0 );\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescenceIOR', 1.3 );\n\n\t\t\tconst iridescenceThicknessRange = getField( m, 'iridescenceThicknessRange', [ 100, 400 ] );\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 0 ];\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 1 ];\n\n\t\t\t// sample 10\n\t\t\t// specular color\n\t\t\tif ( 'specularColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularColorMap' );\n\n\t\t\t// sample 11\n\t\t\t// specular intensity\n\t\t\tfloatArray[ index ++ ] = getField( m, 'specularIntensity', 1.0 );\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularIntensityMap' );\n\n\t\t\t// isThinFilm\n\t\t\tconst isThinFilm = getField( m, 'thickness', 0.0 ) === 0.0 && getField( m, 'attenuationDistance', Infinity ) === Infinity;\n\t\t\tfloatArray[ index ++ ] = Number( isThinFilm );\n\t\t\tindex ++;\n\n\t\t\t// sample 12\n\t\t\tif ( 'attenuationColor' in m ) {\n\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.r;\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.g;\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.b;\n\n\t\t\t} else {\n\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\n\n\t\t\t}\n\n\t\t\tfloatArray[ index ++ ] = getField( m, 'attenuationDistance', Infinity );\n\n\t\t\t// sample 13\n\t\t\t// alphaMap\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'alphaMap' );\n\n\t\t\t// side & matte\n\t\t\tfloatArray[ index ++ ] = m.opacity;\n\t\t\tfloatArray[ index ++ ] = m.alphaTest;\n\t\t\tif ( ! isThinFilm && m.transmission > 0.0 ) {\n\n\t\t\t\tfloatArray[ index ++ ] = 0;\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( m.side ) {\n\n\t\t\t\tcase FrontSide:\n\t\t\t\t\tfloatArray[ index ++ ] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BackSide:\n\t\t\t\t\tfloatArray[ index ++ ] = - 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DoubleSide:\n\t\t\t\t\tfloatArray[ index ++ ] = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sample 14\n\t\t\tfloatArray[ index ++ ] = Number( getField( m, 'matte', false ) ); // matte\n\t\t\tfloatArray[ index ++ ] = Number( getField( m, 'castShadow', true ) ); // shadow\n\t\t\tfloatArray[ index ++ ] = Number( m.vertexColors ) | ( Number( m.flatShading ) << 1 ); // vertexColors & flatShading\n\t\t\tfloatArray[ index ++ ] = Number( m.transparent ); // transparent\n\n\t\t\t// map transform 15\n\t\t\tindex += writeTextureMatrixToArray( m, 'map', floatArray, index );\n\n\t\t\t// metalnessMap transform 17\n\t\t\tindex += writeTextureMatrixToArray( m, 'metalnessMap', floatArray, index );\n\n\t\t\t// roughnessMap transform 19\n\t\t\tindex += writeTextureMatrixToArray( m, 'roughnessMap', floatArray, index );\n\n\t\t\t// transmissionMap transform 21\n\t\t\tindex += writeTextureMatrixToArray( m, 'transmissionMap', floatArray, index );\n\n\t\t\t// emissiveMap transform 22\n\t\t\tindex += writeTextureMatrixToArray( m, 'emissiveMap', floatArray, index );\n\n\t\t\t// normalMap transform 25\n\t\t\tindex += writeTextureMatrixToArray( m, 'normalMap', floatArray, index );\n\n\t\t\t// clearcoatMap transform 27\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatMap', floatArray, index );\n\n\t\t\t// clearcoatNormalMap transform 29\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatNormalMap', floatArray, index );\n\n\t\t\t// clearcoatRoughnessMap transform 31\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatRoughnessMap', floatArray, index );\n\n\t\t\t// sheenColorMap transform 33\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenColorMap', floatArray, index );\n\n\t\t\t// sheenRoughnessMap transform 35\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenRoughnessMap', floatArray, index );\n\n\t\t\t// iridescenceMap transform 37\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceMap', floatArray, index );\n\n\t\t\t// iridescenceThicknessMap transform 39\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceThicknessMap', floatArray, index );\n\n\t\t\t// specularColorMap transform 41\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularColorMap', floatArray, index );\n\n\t\t\t// specularIntensityMap transform 43\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularIntensityMap', floatArray, index );\n\n\t\t}\n\n\t\t// check if the contents have changed\n\t\tconst hash = bufferToHash( floatArray.buffer );\n\t\tif ( this.hash !== hash ) {\n\n\t\t\tthis.hash = hash;\n\t\t\tthis.needsUpdate = true;\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n}\n", "import {\n\tWebGLArrayRenderTarget,\n\tRGBAFormat,\n\tUnsignedByteType,\n\tColor,\n\tRepeatWrapping,\n\tLinearFilter,\n\tNoToneMapping,\n\tShaderMaterial,\n} from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\n\nconst prevColor = new Color();\nfunction getTextureHash( texture ) {\n\n\treturn texture ? `${ texture.uuid }:${ texture.version }` : null;\n\n}\n\nfunction assignOptions( target, options ) {\n\n\tfor ( const key in options ) {\n\n\t\tif ( key in target ) {\n\n\t\t\ttarget[ key ] = options[ key ];\n\n\t\t}\n\n\t}\n\n}\n\nexport class RenderTarget2DArray extends WebGLArrayRenderTarget {\n\n\tconstructor( width, height, options ) {\n\n\t\tconst textureOptions = {\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: UnsignedByteType,\n\t\t\tminFilter: LinearFilter,\n\t\t\tmagFilter: LinearFilter,\n\t\t\twrapS: RepeatWrapping,\n\t\t\twrapT: RepeatWrapping,\n\t\t\tgenerateMipmaps: false,\n\t\t\t...options,\n\t\t};\n\n\t\tsuper( width, height, 1, textureOptions );\n\n\t\t// manually assign the options because passing options into the\n\t\t// constructor does not work\n\t\tassignOptions( this.texture, textureOptions );\n\n\t\tthis.texture.setTextures = ( ...args ) => {\n\n\t\t\tthis.setTextures( ...args );\n\n\t\t};\n\n\t\tthis.hashes = [ null ];\n\n\t\tconst fsQuad = new FullScreenQuad( new CopyMaterial() );\n\t\tthis.fsQuad = fsQuad;\n\n\t}\n\n\tsetTextures( renderer, textures, width = this.width, height = this.height ) {\n\n\t\t// save previous renderer state\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevToneMapping = renderer.toneMapping;\n\t\tconst prevAlpha = renderer.getClearAlpha();\n\t\trenderer.getClearColor( prevColor );\n\n\t\t// resize the render target and ensure we don't have an empty texture\n\t\t// render target depth must be >= 1 to avoid unbound texture error on android devices\n\t\tconst depth = textures.length || 1;\n\t\tif ( width !== this.width || height !== this.height || this.depth !== depth ) {\n\n\t\t\tthis.setSize( width, height, depth );\n\t\t\tthis.hashes = new Array( depth ).fill( null );\n\n\t\t}\n\n\t\trenderer.setClearColor( 0, 0 );\n\t\trenderer.toneMapping = NoToneMapping;\n\n\t\t// render each texture into each layer of the target\n\t\tconst fsQuad = this.fsQuad;\n\t\tconst hashes = this.hashes;\n\t\tlet updated = false;\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\t\t\tconst hash = getTextureHash( texture );\n\t\t\tif ( texture && ( hashes[ i ] !== hash || texture.isWebGLRenderTarget ) ) {\n\n\t\t\t\t// revert to default texture transform before rendering\n\t\t\t\ttexture.matrixAutoUpdate = false;\n\t\t\t\ttexture.matrix.identity();\n\n\t\t\t\tfsQuad.material.map = texture;\n\n\t\t\t\trenderer.setRenderTarget( this, i );\n\t\t\t\tfsQuad.render( renderer );\n\n\t\t\t\t// restore custom texture transform\n\t\t\t\ttexture.updateMatrix();\n\t\t\t\ttexture.matrixAutoUpdate = true;\n\n\t\t\t\t// ensure textures are not updated unnecessarily\n\t\t\t\thashes[ i ] = hash;\n\t\t\t\tupdated = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// reset the renderer\n\t\tfsQuad.material.map = null;\n\t\trenderer.setClearColor( prevColor, prevAlpha );\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.toneMapping = prevToneMapping;\n\n\t\treturn updated;\n\n\t}\n\n\tdispose() {\n\n\t\tsuper.dispose();\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n\nclass CopyMaterial extends ShaderMaterial {\n\n\tget map() {\n\n\t\treturn this.uniforms.map.value;\n\n\t}\n\tset map( v ) {\n\n\t\tthis.uniforms.map.value = v;\n\n\t}\n\n\tconstructor() {\n\n\t\tsuper( {\n\t\t\tuniforms: {\n\n\t\t\t\tmap: { value: null },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUv );\n\n\t\t\t\t}\n\t\t\t`\n\t\t} );\n\n\t}\n\n}\n", "// Stratified Sampling based on implementation from hoverinc pathtracer\n// - https://github.com/hoverinc/ray-tracing-renderer\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\n\nexport function shuffle( arr, random = Math.random() ) {\n\n\tfor ( let i = arr.length - 1; i > 0; i -- ) {\n\n\t  const j = Math.floor( random() * ( i + 1 ) );\n\t  const x = arr[ i ];\n\t  arr[ i ] = arr[ j ];\n\t  arr[ j ] = x;\n\n\t}\n\n\treturn arr;\n\n}\n\n// strataCount : The number of bins per dimension\n// dimensions  : The number of dimensions to generate stratified values for\nexport class StratifiedSampler {\n\n\tconstructor( strataCount, dimensions, random = Math.random ) {\n\n\t\tconst l = strataCount ** dimensions;\n\t\tconst strata = new Uint16Array( l );\n\t\tlet index = l;\n\n\t\t// each integer represents a statum bin\n\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\tstrata[ i ] = i;\n\n\t\t}\n\n\t\tthis.samples = new Float32Array( dimensions );\n\n\t\tthis.strataCount = strataCount;\n\n\t\tthis.reset = function () {\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tstrata[ i ] = i;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t};\n\n\t\tthis.reshuffle = function () {\n\n\t\t\tindex = 0;\n\n\t\t};\n\n\t\tthis.next = function () {\n\n\t\t\tconst { samples } = this;\n\n\t\t\tif ( index >= strata.length ) {\n\n\t\t\t\tshuffle( strata, random );\n\t\t\t\tthis.reshuffle();\n\n\t\t\t}\n\n\t\t\tlet stratum = strata[ index ++ ];\n\n\t\t\tfor ( let i = 0; i < dimensions; i ++ ) {\n\n\t\t\t\tsamples[ i ] = ( stratum % strataCount + random() ) / strataCount;\n\t\t\t\tstratum = Math.floor( stratum / strataCount );\n\n\t\t\t}\n\n\t\t\treturn samples;\n\n\t\t};\n\n\t}\n\n}\n", "// Stratified Sampling based on implementation from hoverinc pathtracer\n// - https://github.com/hoverinc/ray-tracing-renderer\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\n\nimport { StratifiedSampler } from './StratifiedSampler.js';\n\n// Stratified set of data with each tuple stratified separately and combined\nexport class StratifiedSamplerCombined {\n\n\tconstructor( strataCount, listOfDimensions, random = Math.random ) {\n\n\t\tlet totalDim = 0;\n\t\tfor ( const dim of listOfDimensions ) {\n\n\t\t\ttotalDim += dim;\n\n\t\t}\n\n\t\tconst combined = new Float32Array( totalDim );\n\t\tconst strataObjs = [];\n\t\tlet offset = 0;\n\t\tfor ( const dim of listOfDimensions ) {\n\n\t\t\tconst sampler = new StratifiedSampler( strataCount, dim, random );\n\t\t\tsampler.samples = new Float32Array( combined.buffer, offset, sampler.samples.length );\n\t\t\toffset += sampler.samples.length * 4;\n\t\t\tstrataObjs.push( sampler );\n\n\t\t}\n\n\t\tthis.samples = combined;\n\n\t\tthis.strataCount = strataCount;\n\n\t\tthis.next = function () {\n\n\t\t\tfor ( const strata of strataObjs ) {\n\n\t\t\t\tstrata.next();\n\n\t\t\t}\n\n\t\t\treturn combined;\n\n\t\t};\n\n\t\tthis.reshuffle = function () {\n\n\t\t\tfor ( const strata of strataObjs ) {\n\n\t\t\t\tstrata.reshuffle();\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tfor ( const strata of strataObjs ) {\n\n\t\t\t\tstrata.reset();\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n", "import { DataTexture, FloatType, NearestFilter, RGBAFormat } from 'three';\nimport { StratifiedSamplerCombined } from './stratified/StratifiedSamplerCombined.js';\n\n// https://stackoverflow.com/questions/424292/seedable-javascript-random-number-generator\nclass RandomGenerator {\n\n\tconstructor( seed = 0 ) {\n\n\t\t// LCG using GCC's constants\n\t\tthis.m = 0x80000000; // 2**31;\n\t\tthis.a = 1103515245;\n\t\tthis.c = 12345;\n\n\t\tthis.seed = seed;\n\n\t}\n\n\tnextInt() {\n\n\t\tthis.seed = ( this.a * this.seed + this.c ) % this.m;\n\t\treturn this.seed;\n\n\t}\n\n\tnextFloat() {\n\n\t\t// returns in range [0,1]\n\t\treturn this.nextInt() / ( this.m - 1 );\n\n\t}\n\n}\n\nexport class StratifiedSamplesTexture extends DataTexture {\n\n\tconstructor( count = 1, depth = 1, strata = 8 ) {\n\n\t\tsuper( new Float32Array( 1 ), 1, 1, RGBAFormat, FloatType );\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\n\t\tthis.strata = strata;\n\t\tthis.sampler = null;\n\t\tthis.generator = new RandomGenerator();\n\t\tthis.stableNoise = false;\n\t\tthis.random = () => {\n\n\t\t\tif ( this.stableNoise ) {\n\n\t\t\t\treturn this.generator.nextFloat();\n\n\t\t\t} else {\n\n\t\t\t\treturn Math.random();\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.init( count, depth, strata );\n\n\t}\n\n\tinit( count = this.image.height, depth = this.image.width, strata = this.strata ) {\n\n\t\tconst { image } = this;\n\t\tif ( image.width === depth && image.height === count && this.sampler !== null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst dimensions = new Array( count * depth ).fill( 4 );\n\t\tconst sampler = new StratifiedSamplerCombined( strata, dimensions, this.random );\n\n\t\timage.width = depth;\n\t\timage.height = count;\n\t\timage.data = sampler.samples;\n\n\t\tthis.sampler = sampler;\n\n\t\tthis.dispose();\n\t\tthis.next();\n\n\t}\n\n\tnext() {\n\n\t\tthis.sampler.next();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\treset() {\n\n\t\tthis.sampler.reset();\n\t\tthis.generator.seed = 0;\n\n\t}\n\n}\n", "export function shuffleArray( array, random = Math.random ) {\n\n\tfor ( let i = array.length - 1; i > 0; i -- ) {\n\n\t\tconst replaceIndex = ~ ~ ( ( random() - 1e-6 ) * i );\n\t\tconst tmp = array[ i ];\n\t\tarray[ i ] = array[ replaceIndex ];\n\t\tarray[ replaceIndex ] = tmp;\n\n\t}\n\n}\n\nexport function fillWithOnes( array, count ) {\n\n\tarray.fill( 0 );\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tarray[ i ] = 1;\n\n\t}\n\n}\n", "export class BlueNoiseSamples {\n\n\tconstructor( size ) {\n\n\t\tthis.count = 0;\n\t\tthis.size = - 1;\n\t\tthis.sigma = - 1;\n\t\tthis.radius = - 1;\n\t\tthis.lookupTable = null;\n\t\tthis.score = null;\n\t\tthis.binaryPattern = null;\n\n\t\tthis.resize( size );\n\t\tthis.setSigma( 1.5 );\n\n\t}\n\n\tfindVoid() {\n\n\t\tconst { score, binaryPattern } = this;\n\n\t\tlet currValue = Infinity;\n\t\tlet currIndex = - 1;\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\n\n\t\t\tif ( binaryPattern[ i ] !== 0 ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst pScore = score[ i ];\n\t\t\tif ( pScore < currValue ) {\n\n\t\t\t\tcurrValue = pScore;\n\t\t\t\tcurrIndex = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn currIndex;\n\n\t}\n\n\tfindCluster() {\n\n\t\tconst { score, binaryPattern } = this;\n\n\t\tlet currValue = - Infinity;\n\t\tlet currIndex = - 1;\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\n\n\t\t\tif ( binaryPattern[ i ] !== 1 ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst pScore = score[ i ];\n\t\t\tif ( pScore > currValue ) {\n\n\t\t\t\tcurrValue = pScore;\n\t\t\t\tcurrIndex = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn currIndex;\n\n\t}\n\n\tsetSigma( sigma ) {\n\n\t\tif ( sigma === this.sigma ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// generate a radius in which the score will be updated under the\n\t\t// assumption that e^-10 is insignificant enough to be the border at\n\t\t// which we drop off.\n\t\tconst radius = ~ ~ ( Math.sqrt( 10 * 2 * ( sigma ** 2 ) ) + 1 );\n\t\tconst lookupWidth = 2 * radius + 1;\n\t\tconst lookupTable = new Float32Array( lookupWidth * lookupWidth );\n\t\tconst sigma2 = sigma * sigma;\n\t\tfor ( let x = - radius; x <= radius; x ++ ) {\n\n\t\t\tfor ( let y = - radius; y <= radius; y ++ ) {\n\n\t\t\t\tconst index = ( radius + y ) * lookupWidth + x + radius;\n\t\t\t\tconst dist2 = x * x + y * y;\n\t\t\t\tlookupTable[ index ] = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.lookupTable = lookupTable;\n\t\tthis.sigma = sigma;\n\t\tthis.radius = radius;\n\n\t}\n\n\tresize( size ) {\n\n\t\tif ( this.size !== size ) {\n\n\t\t\tthis.size = size;\n\t\t\tthis.score = new Float32Array( size * size );\n\t\t\tthis.binaryPattern = new Uint8Array( size * size );\n\n\t\t}\n\n\n\t}\n\n\tinvert() {\n\n\t\tconst { binaryPattern, score, size } = this;\n\n\t\tscore.fill( 0 );\n\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\n\n\t\t\tif ( binaryPattern[ i ] === 0 ) {\n\n\t\t\t\tconst y = ~ ~ ( i / size );\n\t\t\t\tconst x = i - y * size;\n\t\t\t\tthis.updateScore( x, y, 1 );\n\t\t\t\tbinaryPattern[ i ] = 1;\n\n\t\t\t} else {\n\n\t\t\t\tbinaryPattern[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateScore( x, y, multiplier ) {\n\n\t\t// TODO: Is there a way to keep track of the highest and lowest scores here to avoid have to search over\n\t\t// everything in the buffer?\n\t\tconst { size, score, lookupTable } = this;\n\n\t\t// const sigma2 = sigma * sigma;\n\t\t// const radius = Math.floor( size / 2 );\n\t\tconst radius = this.radius;\n\t\tconst lookupWidth = 2 * radius + 1;\n\t\tfor ( let px = - radius; px <= radius; px ++ ) {\n\n\t\t\tfor ( let py = - radius; py <= radius; py ++ ) {\n\n\t\t\t\t// const dist2 = px * px + py * py;\n\t\t\t\t// const value = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\n\n\t\t\t\tconst lookupIndex = ( radius + py ) * lookupWidth + px + radius;\n\t\t\t\tconst value = lookupTable[ lookupIndex ];\n\n\t\t\t\tlet sx = ( x + px );\n\t\t\t\tsx = sx < 0 ? size + sx : sx % size;\n\n\t\t\t\tlet sy = ( y + py );\n\t\t\t\tsy = sy < 0 ? size + sy : sy % size;\n\n\t\t\t\tconst sindex = sy * size + sx;\n\t\t\t\tscore[ sindex ] += multiplier * value;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\taddPointIndex( index ) {\n\n\t\tthis.binaryPattern[ index ] = 1;\n\n\t\tconst size = this.size;\n\t\tconst y = ~ ~ ( index / size );\n\t\tconst x = index - y * size;\n\t\tthis.updateScore( x, y, 1 );\n\t\tthis.count ++;\n\n\t}\n\n\tremovePointIndex( index ) {\n\n\t\tthis.binaryPattern[ index ] = 0;\n\n\t\tconst size = this.size;\n\t\tconst y = ~ ~ ( index / size );\n\t\tconst x = index - y * size;\n\t\tthis.updateScore( x, y, - 1 );\n\t\tthis.count --;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.resize( source.size );\n\t\tthis.score.set( source.score );\n\t\tthis.binaryPattern.set( source.binaryPattern );\n\t\tthis.setSigma( source.sigma );\n\t\tthis.count = source.count;\n\n\t}\n\n}\n", "import { shuffleArray, fillWithOnes } from './utils.js';\nimport { BlueNoiseSamples } from './BlueNoiseSamples.js';\n\nexport class BlueNoiseGenerator {\n\n\tconstructor() {\n\n\t\tthis.random = Math.random;\n\t\tthis.sigma = 1.5;\n\t\tthis.size = 64;\n\t\tthis.majorityPointsRatio = 0.1;\n\n\t\tthis.samples = new BlueNoiseSamples( 1 );\n\t\tthis.savedSamples = new BlueNoiseSamples( 1 );\n\n\t}\n\n\tgenerate() {\n\n\t\t// http://cv.ulichney.com/papers/1993-void-cluster.pdf\n\n\t\tconst {\n\t\t\tsamples,\n\t\t\tsavedSamples,\n\t\t\tsigma,\n\t\t\tmajorityPointsRatio,\n\t\t\tsize,\n\t\t} = this;\n\n\t\tsamples.resize( size );\n\t\tsamples.setSigma( sigma );\n\n\t\t// 1. Randomly place the minority points.\n\t\tconst pointCount = Math.floor( size * size * majorityPointsRatio );\n\t\tconst initialSamples = samples.binaryPattern;\n\n\t\tfillWithOnes( initialSamples, pointCount );\n\t\tshuffleArray( initialSamples, this.random );\n\n\t\tfor ( let i = 0, l = initialSamples.length; i < l; i ++ ) {\n\n\t\t\tif ( initialSamples[ i ] === 1 ) {\n\n\t\t\t\tsamples.addPointIndex( i );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 2. Remove minority point that is in densest cluster and place it in the largest void.\n\t\twhile ( true ) {\n\n\t\t\tconst clusterIndex = samples.findCluster();\n\t\t\tsamples.removePointIndex( clusterIndex );\n\n\t\t\tconst voidIndex = samples.findVoid();\n\t\t\tif ( clusterIndex === voidIndex ) {\n\n\t\t\t\tsamples.addPointIndex( clusterIndex );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tsamples.addPointIndex( voidIndex );\n\n\t\t}\n\n\t\t// 3. PHASE I: Assign a rank to each progressively less dense cluster point and put it\n\t\t// in the dither array.\n\t\tconst ditherArray = new Uint32Array( size * size );\n\t\tsavedSamples.copy( samples );\n\n\t\tlet rank;\n\t\trank = samples.count - 1;\n\t\twhile ( rank >= 0 ) {\n\n\t\t\tconst clusterIndex = samples.findCluster();\n\t\t\tsamples.removePointIndex( clusterIndex );\n\n\t\t\tditherArray[ clusterIndex ] = rank;\n\t\t\trank --;\n\n\t\t}\n\n\t\t// 4. PHASE II: Do the same thing for the largest voids up to half of the total pixels using\n\t\t// the initial binary pattern.\n\t\tconst totalSize = size * size;\n\t\trank = savedSamples.count;\n\t\twhile ( rank < totalSize / 2 ) {\n\n\t\t\tconst voidIndex = savedSamples.findVoid();\n\t\t\tsavedSamples.addPointIndex( voidIndex );\n\t\t\tditherArray[ voidIndex ] = rank;\n\t\t\trank ++;\n\n\t\t}\n\n\t\t// 5. PHASE III: Invert the pattern and finish out by assigning a rank to the remaining\n\t\t// and iteratively removing them.\n\t\tsavedSamples.invert();\n\n\t\twhile ( rank < totalSize ) {\n\n\t\t\tconst clusterIndex = savedSamples.findCluster();\n\t\t\tsavedSamples.removePointIndex( clusterIndex );\n\t\t\tditherArray[ clusterIndex ] = rank;\n\t\t\trank ++;\n\n\t\t}\n\n\t\treturn { data: ditherArray, maxValue: totalSize };\n\n\t}\n\n}\n", "import { DataTexture, FloatType, NearestFilter, RGBAFormat, RGFormat, RedFormat } from 'three';\nimport { BlueNoiseGenerator } from './blueNoise/BlueNoiseGenerator.js';\n\nfunction getStride( channels ) {\n\n\tif ( channels >= 3 ) {\n\n\t\treturn 4;\n\n\t} else {\n\n\t\treturn channels;\n\n\t}\n\n}\n\nfunction getFormat( channels ) {\n\n\tswitch ( channels ) {\n\n\tcase 1:\n\t\treturn RedFormat;\n\tcase 2:\n\t\treturn RGFormat;\n\tdefault:\n\t\treturn RGBAFormat;\n\n\t}\n\n}\n\nexport class BlueNoiseTexture extends DataTexture {\n\n\tconstructor( size = 64, channels = 1 ) {\n\n\t\tsuper( new Float32Array( 4 ), 1, 1, RGBAFormat, FloatType );\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\n\t\tthis.size = size;\n\t\tthis.channels = channels;\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst channels = this.channels;\n\t\tconst size = this.size;\n\t\tconst generator = new BlueNoiseGenerator();\n\t\tgenerator.channels = channels;\n\t\tgenerator.size = size;\n\n\t\tconst stride = getStride( channels );\n\t\tconst format = getFormat( stride );\n\t\tif ( this.image.width !== size || format !== this.format ) {\n\n\t\t\tthis.image.width = size;\n\t\t\tthis.image.height = size;\n\t\t\tthis.image.data = new Float32Array( ( size ** 2 ) * stride );\n\t\t\tthis.format = format;\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tconst data = this.image.data;\n\t\tfor ( let i = 0, l = channels; i < l; i ++ ) {\n\n\t\t\tconst result = generator.generate();\n\t\t\tconst bin = result.data;\n\t\t\tconst maxValue = result.maxValue;\n\n\t\t\tfor ( let j = 0, l2 = bin.length; j < l2; j ++ ) {\n\n\t\t\t\tconst value = bin[ j ] / maxValue;\n\t\t\t\tdata[ j * stride + i ] = value;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n", "export const camera_struct = /* glsl */`\n\n\tstruct PhysicalCamera {\n\n\t\tfloat focusDistance;\n\t\tfloat anamorphicRatio;\n\t\tfloat bokehSize;\n\t\tint apertureBlades;\n\t\tfloat apertureRotation;\n\n\t};\n\n`;\n", "export const equirect_struct = /* glsl */`\n\n\tstruct EquirectHdrInfo {\n\n\t\tsampler2D marginalWeights;\n\t\tsampler2D conditionalWeights;\n\t\tsampler2D map;\n\n\t\tfloat totalSum;\n\n\t};\n\n`;\n", "export const lights_struct = /* glsl */`\n\n\t#define RECT_AREA_LIGHT_TYPE 0\n\t#define CIRC_AREA_LIGHT_TYPE 1\n\t#define SPOT_LIGHT_TYPE 2\n\t#define DIR_LIGHT_TYPE 3\n\t#define POINT_LIGHT_TYPE 4\n\n\tstruct LightsInfo {\n\n\t\tsampler2D tex;\n\t\tuint count;\n\n\t};\n\n\tstruct Light {\n\n\t\tvec3 position;\n\t\tint type;\n\n\t\tvec3 color;\n\t\tfloat intensity;\n\n\t\tvec3 u;\n\t\tvec3 v;\n\t\tfloat area;\n\n\t\t// spot light fields\n\t\tfloat radius;\n\t\tfloat near;\n\t\tfloat decay;\n\t\tfloat distance;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint iesProfile;\n\n\t};\n\n\tLight readLightInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 6u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\n\t\tLight l;\n\t\tl.position = s0.rgb;\n\t\tl.type = int( round( s0.a ) );\n\n\t\tl.color = s1.rgb;\n\t\tl.intensity = s1.a;\n\n\t\tl.u = s2.rgb;\n\t\tl.v = s3.rgb;\n\t\tl.area = s3.a;\n\n\t\tif ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\t\tl.radius = s4.r;\n\t\t\tl.decay = s4.g;\n\t\t\tl.distance = s4.b;\n\t\t\tl.coneCos = s4.a;\n\n\t\t\tl.penumbraCos = s5.r;\n\t\t\tl.iesProfile = int( round( s5.g ) );\n\n\t\t} else {\n\n\t\t\tl.radius = 0.0;\n\t\t\tl.decay = 0.0;\n\t\t\tl.distance = 0.0;\n\n\t\t\tl.coneCos = 0.0;\n\t\t\tl.penumbraCos = 0.0;\n\t\t\tl.iesProfile = - 1;\n\n\t\t}\n\n\t\treturn l;\n\n\t}\n\n`;\n", "export const material_struct = /* glsl */ `\n\n\tstruct Material {\n\n\t\tvec3 color;\n\t\tint map;\n\n\t\tfloat metalness;\n\t\tint metalnessMap;\n\n\t\tfloat roughness;\n\t\tint roughnessMap;\n\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tint transmissionMap;\n\n\t\tfloat emissiveIntensity;\n\t\tvec3 emissive;\n\t\tint emissiveMap;\n\n\t\tint normalMap;\n\t\tvec2 normalScale;\n\n\t\tfloat clearcoat;\n\t\tint clearcoatMap;\n\t\tint clearcoatNormalMap;\n\t\tvec2 clearcoatNormalScale;\n\t\tfloat clearcoatRoughness;\n\t\tint clearcoatRoughnessMap;\n\n\t\tint iridescenceMap;\n\t\tint iridescenceThicknessMap;\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThicknessMinimum;\n\t\tfloat iridescenceThicknessMaximum;\n\n\t\tvec3 specularColor;\n\t\tint specularColorMap;\n\n\t\tfloat specularIntensity;\n\t\tint specularIntensityMap;\n\t\tbool thinFilm;\n\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\tint alphaMap;\n\n\t\tbool castShadow;\n\t\tfloat opacity;\n\t\tfloat alphaTest;\n\n\t\tfloat side;\n\t\tbool matte;\n\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tint sheenColorMap;\n\t\tfloat sheenRoughness;\n\t\tint sheenRoughnessMap;\n\n\t\tbool vertexColors;\n\t\tbool flatShading;\n\t\tbool transparent;\n\t\tbool fogVolume;\n\n\t\tmat3 mapTransform;\n\t\tmat3 metalnessMapTransform;\n\t\tmat3 roughnessMapTransform;\n\t\tmat3 transmissionMapTransform;\n\t\tmat3 emissiveMapTransform;\n\t\tmat3 normalMapTransform;\n\t\tmat3 clearcoatMapTransform;\n\t\tmat3 clearcoatNormalMapTransform;\n\t\tmat3 clearcoatRoughnessMapTransform;\n\t\tmat3 sheenColorMapTransform;\n\t\tmat3 sheenRoughnessMapTransform;\n\t\tmat3 iridescenceMapTransform;\n\t\tmat3 iridescenceThicknessMapTransform;\n\t\tmat3 specularColorMapTransform;\n\t\tmat3 specularIntensityMapTransform;\n\n\t};\n\n\tmat3 readTextureTransform( sampler2D tex, uint index ) {\n\n\t\tmat3 textureTransform;\n\n\t\tvec4 row1 = texelFetch1D( tex, index );\n\t\tvec4 row2 = texelFetch1D( tex, index + 1u );\n\n\t\ttextureTransform[0] = vec3(row1.r, row2.r, 0.0);\n\t\ttextureTransform[1] = vec3(row1.g, row2.g, 0.0);\n\t\ttextureTransform[2] = vec3(row1.b, row2.b, 1.0);\n\n\t\treturn textureTransform;\n\n\t}\n\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 45u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\n\t\tvec4 s7 = texelFetch1D( tex, i + 7u );\n\t\tvec4 s8 = texelFetch1D( tex, i + 8u );\n\t\tvec4 s9 = texelFetch1D( tex, i + 9u );\n\t\tvec4 s10 = texelFetch1D( tex, i + 10u );\n\t\tvec4 s11 = texelFetch1D( tex, i + 11u );\n\t\tvec4 s12 = texelFetch1D( tex, i + 12u );\n\t\tvec4 s13 = texelFetch1D( tex, i + 13u );\n\t\tvec4 s14 = texelFetch1D( tex, i + 14u );\n\n\t\tMaterial m;\n\t\tm.color = s0.rgb;\n\t\tm.map = int( round( s0.a ) );\n\n\t\tm.metalness = s1.r;\n\t\tm.metalnessMap = int( round( s1.g ) );\n\t\tm.roughness = s1.b;\n\t\tm.roughnessMap = int( round( s1.a ) );\n\n\t\tm.ior = s2.r;\n\t\tm.transmission = s2.g;\n\t\tm.transmissionMap = int( round( s2.b ) );\n\t\tm.emissiveIntensity = s2.a;\n\n\t\tm.emissive = s3.rgb;\n\t\tm.emissiveMap = int( round( s3.a ) );\n\n\t\tm.normalMap = int( round( s4.r ) );\n\t\tm.normalScale = s4.gb;\n\n\t\tm.clearcoat = s4.a;\n\t\tm.clearcoatMap = int( round( s5.r ) );\n\t\tm.clearcoatRoughness = s5.g;\n\t\tm.clearcoatRoughnessMap = int( round( s5.b ) );\n\t\tm.clearcoatNormalMap = int( round( s5.a ) );\n\t\tm.clearcoatNormalScale = s6.rg;\n\n\t\tm.sheen = s6.a;\n\t\tm.sheenColor = s7.rgb;\n\t\tm.sheenColorMap = int( round( s7.a ) );\n\t\tm.sheenRoughness = s8.r;\n\t\tm.sheenRoughnessMap = int( round( s8.g ) );\n\n\t\tm.iridescenceMap = int( round( s8.b ) );\n\t\tm.iridescenceThicknessMap = int( round( s8.a ) );\n\t\tm.iridescence = s9.r;\n\t\tm.iridescenceIor = s9.g;\n\t\tm.iridescenceThicknessMinimum = s9.b;\n\t\tm.iridescenceThicknessMaximum = s9.a;\n\n\t\tm.specularColor = s10.rgb;\n\t\tm.specularColorMap = int( round( s10.a ) );\n\n\t\tm.specularIntensity = s11.r;\n\t\tm.specularIntensityMap = int( round( s11.g ) );\n\t\tm.thinFilm = bool( s11.b );\n\n\t\tm.attenuationColor = s12.rgb;\n\t\tm.attenuationDistance = s12.a;\n\n\t\tm.alphaMap = int( round( s13.r ) );\n\n\t\tm.opacity = s13.g;\n\t\tm.alphaTest = s13.b;\n\t\tm.side = s13.a;\n\n\t\tm.matte = bool( s14.r );\n\t\tm.castShadow = bool( s14.g );\n\t\tm.vertexColors = bool( int( s14.b ) & 1 );\n\t\tm.flatShading = bool( int( s14.b ) & 2 );\n\t\tm.fogVolume = bool( int( s14.b ) & 4 );\n\t\tm.transparent = bool( s14.a );\n\n\t\tuint firstTextureTransformIdx = i + 15u;\n\n\t\t// mat3( 1.0 ) is an identity matrix\n\t\tm.mapTransform = m.map == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx );\n\t\tm.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );\n\t\tm.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );\n\t\tm.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );\n\t\tm.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );\n\t\tm.normalMapTransform = m.normalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );\n\t\tm.clearcoatMapTransform = m.clearcoatMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 12u );\n\t\tm.clearcoatNormalMapTransform = m.clearcoatNormalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 14u );\n\t\tm.clearcoatRoughnessMapTransform = m.clearcoatRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 16u );\n\t\tm.sheenColorMapTransform = m.sheenColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 18u );\n\t\tm.sheenRoughnessMapTransform = m.sheenRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 20u );\n\t\tm.iridescenceMapTransform = m.iridescenceMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 22u );\n\t\tm.iridescenceThicknessMapTransform = m.iridescenceThicknessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 24u );\n\t\tm.specularColorMapTransform = m.specularColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 26u );\n\t\tm.specularIntensityMapTransform = m.specularIntensityMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 28u );\n\n\t\treturn m;\n\n\t}\n\n`;\n", "export const surface_record_struct = /* glsl */`\n\n\tstruct SurfaceRecord {\n\n\t\t// surface type\n\t\tbool volumeParticle;\n\n\t\t// geometry\n\t\tvec3 faceNormal;\n\t\tbool frontFace;\n\t\tvec3 normal;\n\t\tmat3 normalBasis;\n\t\tmat3 normalInvBasis;\n\n\t\t// cached properties\n\t\tfloat eta;\n\t\tfloat f0;\n\n\t\t// material\n\t\tfloat roughness;\n\t\tfloat filteredRoughness;\n\t\tfloat metalness;\n\t\tvec3 color;\n\t\tvec3 emission;\n\n\t\t// transmission\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tbool thinFilm;\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\t// clearcoat\n\t\tvec3 clearcoatNormal;\n\t\tmat3 clearcoatBasis;\n\t\tmat3 clearcoatInvBasis;\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tfloat filteredClearcoatRoughness;\n\n\t\t// sheen\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\n\t\t// iridescence\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThickness;\n\n\t\t// specular\n\t\tvec3 specularColor;\n\t\tfloat specularIntensity;\n\t};\n\n\tstruct ScatterRecord {\n\t\tfloat specularPdf;\n\t\tfloat pdf;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n`;\n", "export const equirect_functions = /* glsl */`\n\n\t// samples the the given environment map in the given direction\n\tvec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {\n\n\t\treturn texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;\n\n\t}\n\n\t// gets the pdf of the given direction to sample\n\tfloat equirectDirectionPdf( vec3 direction ) {\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tfloat theta = uv.y * PI;\n\t\tfloat sinTheta = sin( theta );\n\t\tif ( sinTheta == 0.0 ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\n\n\t}\n\n\t// samples the color given env map with CDF and returns the pdf of the direction\n\tfloat sampleEquirect( vec3 direction, inout vec3 color ) {\n\n\t\tfloat totalSum = envMapInfo.totalSum;\n\t\tif ( totalSum == 0.0 ) {\n\n\t\t\tcolor = vec3( 0.0 );\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\n\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n\t// samples a direction of the envmap with color and retrieves pdf\n\tfloat sampleEquirectProbability( vec2 r, inout vec3 color, inout vec3 direction ) {\n\n\t\t// sample env map cdf\n\t\tfloat v = texture2D( envMapInfo.marginalWeights, vec2( r.x, 0.0 ) ).x;\n\t\tfloat u = texture2D( envMapInfo.conditionalWeights, vec2( r.y, v ) ).x;\n\t\tvec2 uv = vec2( u, v );\n\n\t\tvec3 derivedDirection = equirectUvToDirection( uv );\n\t\tdirection = derivedDirection;\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\n\n\t\tfloat totalSum = envMapInfo.totalSum;\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n`;\n", "export const light_sampling_functions = /* glsl */`\n\n\tfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\t\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n\t}\n\n\tfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t}\n\n\tfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\n\n\t\tfloat cosTheta = dot( posToLight, lightDir );\n\t\tfloat angle = acos( cosTheta ) / PI;\n\n\t\treturn texture2D( iesProfiles, vec3( angle, 0.0, iesProfile ) ).r;\n\n\t}\n\n\tstruct LightRecord {\n\n\t\tfloat dist;\n\t\tvec3 direction;\n\t\tfloat pdf;\n\t\tvec3 emission;\n\t\tint type;\n\n\t};\n\n\tbool intersectLightAtIndex( sampler2D lights, vec3 rayOrigin, vec3 rayDirection, uint l, inout LightRecord lightRec ) {\n\n\t\tbool didHit = false;\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\n\t\t// check for backface\n\t\tvec3 normal = normalize( cross( u, v ) );\n\t\tif ( dot( normal, rayDirection ) > 0.0 ) {\n\n\t\t\tu *= 1.0 / dot( u, u );\n\t\t\tv *= 1.0 / dot( v, v );\n\n\t\t\tfloat dist;\n\n\t\t\t// MIS / light intersection is not supported for punctual lights.\n\t\t\tif(\n\t\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\n\t\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\n\t\t\t) {\n\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\n\t\t\t\tdidHit = true;\n\t\t\t\tlightRec.dist = dist;\n\t\t\t\tlightRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\n\t\t\t\tlightRec.emission = light.color * light.intensity;\n\t\t\t\tlightRec.direction = rayDirection;\n\t\t\t\tlightRec.type = light.type;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn didHit;\n\n\t}\n\n\tLightRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tvec3 randomPos;\n\t\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\n\n\t\t\t// rectangular area light\n\t\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\n\n\t\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\n\n\t\t\t// circular area light\n\t\t\tfloat r = 0.5 * sqrt( ruv.x );\n\t\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\t\tfloat x = r * cos( theta );\n\t\t\tfloat y = r * sin( theta );\n\n\t\t\trandomPos = light.position + light.u * x + light.v * y;\n\n\t\t}\n\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tfloat dist = sqrt( lightDistSq );\n\t\tvec3 direction = toLight / dist;\n\t\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\n\n\t\tLightRecord lightRec;\n\t\tlightRec.type = light.type;\n\t\tlightRec.emission = light.color * light.intensity;\n\t\tlightRec.dist = dist;\n\t\tlightRec.direction = direction;\n\n\t\t// TODO: the denominator is potentially zero\n\t\tlightRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\n\n\t\treturn lightRec;\n\n\t}\n\n\tLightRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tfloat radius = light.radius * sqrt( ruv.x );\n\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\tfloat x = radius * cos( theta );\n\t\tfloat y = radius * sin( theta );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\t\tvec3 normal = normalize( cross( u, v ) );\n\n\t\tfloat angle = acos( light.coneCos );\n\t\tfloat angleTan = tan( angle );\n\t\tfloat startDistance = light.radius / max( angleTan, EPSILON );\n\n\t\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tfloat dist = sqrt( lightDistSq );\n\n\t\tvec3 direction = toLight / max( dist, EPSILON );\n\t\tfloat cosTheta = dot( direction, normal );\n\n\t\tfloat spotAttenuation = light.iesProfile != - 1 ?\n\t\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\n\t\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\n\n\t\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\n\t\tLightRecord lightRec;\n\t\tlightRec.type = light.type;\n\t\tlightRec.dist = dist;\n\t\tlightRec.direction = direction;\n\t\tlightRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\n\t\tlightRec.pdf = 1.0;\n\n\t\treturn lightRec;\n\n\t}\n\n\tLightRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\n\n\t\tLightRecord result;\n\n\t\t// pick a random light\n\t\tuint l = uint( ruv.x * float( lightCount ) );\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tif ( light.type == SPOT_LIGHT_TYPE ) {\n\n\t\t\tresult = randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\n\n\t\t} else if ( light.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec3 lightRay = light.u - rayOrigin;\n\t\t\tfloat lightDist = length( lightRay );\n\t\t\tfloat cutoffDistance = light.distance;\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\n\t\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\n\n\t\t\t}\n\n\t\t\tLightRecord rec;\n\t\t\trec.direction = normalize( lightRay );\n\t\t\trec.dist = length( lightRay );\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity * distanceFalloff;\n\t\t\trec.type = light.type;\n\t\t\tresult = rec;\n\n\t\t} else if ( light.type == DIR_LIGHT_TYPE ) {\n\n\t\t\tLightRecord rec;\n\t\t\trec.dist = 1e10;\n\t\t\trec.direction = light.u;\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity;\n\t\t\trec.type = light.type;\n\n\t\t\tresult = rec;\n\n\t\t} else {\n\n\t\t\t// sample the light\n\t\t\tresult = randomAreaLightSample( light, rayOrigin, ruv.yz );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n`;\n", "export const shape_sampling_functions = /* glsl */`\n\n\tvec3 sampleHemisphere( vec3 n, vec2 uv ) {\n\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\n\t\tfloat a = - 1.0 / ( sign + n.z );\n\t\tfloat b = n.x * n.y * a;\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\n\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat theta = 2.0 * PI * uv.y;\n\t\tfloat x = r * cos( theta );\n\t\tfloat y = r * sin( theta );\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\n\n\t}\n\n\tvec2 sampleTriangle( vec2 a, vec2 b, vec2 c, vec2 r ) {\n\n\t\t// get the edges of the triangle and the diagonal across the\n\t\t// center of the parallelogram\n\t\tvec2 e1 = a - b;\n\t\tvec2 e2 = c - b;\n\t\tvec2 diag = normalize( e1 + e2 );\n\n\t\t// pick the point in the parallelogram\n\t\tif ( r.x + r.y > 1.0 ) {\n\n\t\t\tr = vec2( 1.0 ) - r;\n\n\t\t}\n\n\t\treturn e1 * r.x + e2 * r.y;\n\n\t}\n\n\tvec2 sampleCircle( vec2 uv ) {\n\n\t\tfloat angle = 2.0 * PI * uv.x;\n\t\tfloat radius = sqrt( uv.y );\n\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\n\n\t}\n\n\tvec3 sampleSphere( vec2 uv ) {\n\n\t\tfloat u = ( uv.x - 0.5 ) * 2.0;\n\t\tfloat t = uv.y * PI * 2.0;\n\t\tfloat f = sqrt( 1.0 - u * u );\n\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\n\n\t}\n\n\tvec2 sampleRegularPolygon( int sides, vec3 uvw ) {\n\n\t\tsides = max( sides, 3 );\n\n\t\tvec3 r = uvw;\n\t\tfloat anglePerSegment = 2.0 * PI / float( sides );\n\t\tfloat segment = floor( float( sides ) * r.x );\n\n\t\tfloat angle1 = anglePerSegment * segment;\n\t\tfloat angle2 = angle1 + anglePerSegment;\n\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\n\t\tvec2 b = vec2( 0.0, 0.0 );\n\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\n\n\t\treturn sampleTriangle( a, b, c, r.yz );\n\n\t}\n\n\t// samples an aperture shape with the given number of sides. 0 means circle\n\tvec2 sampleAperture( int blades, vec3 uvw ) {\n\n\t\treturn blades == 0 ?\n\t\t\tsampleCircle( uvw.xy ) :\n\t\t\tsampleRegularPolygon( blades, uvw );\n\n\t}\n\n\n`;\n", "export const fresnel_functions = /* glsl */`\n\n\tbool totalInternalReflection( float cosTheta, float eta ) {\n\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\t\treturn eta * sinTheta > 1.0;\n\n\t}\n\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\n\tfloat schlickFresnel( float cosine, float f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {\n\n\t\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tfloat dielectricFresnel( float cosThetaI, float eta ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat ni = eta;\n\t\tfloat nt = 1.0;\n\n\t\t// Check for total internal reflection\n\t\tfloat sinThetaISq = 1.0f - cosThetaI * cosThetaI;\n\t\tfloat sinThetaTSq = eta * eta * sinThetaISq;\n\t\tif( sinThetaTSq >= 1.0 ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tfloat sinThetaT = sqrt( sinThetaTSq );\n\n\t\tfloat cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );\n\t\tfloat rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );\n\t\tfloat rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );\n\t\treturn ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;\n\n\t}\n\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\n\tfloat iorRatioToF0( float eta ) {\n\n\t\treturn pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );\n\n\t}\n\n\tvec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {\n\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t\t\treturn f90;\n\n\t\t}\n\n\t\treturn schlickFresnel( cosTheta, f0, f90 );\n\n\t}\n\n\t// TODO: disney fresnel was removed and replaced with this fresnel function to better align with\n\t// the glTF but is causing blown out pixels. Should be revisited\n\t// float evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {\n\n\t// \tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t// \t\treturn 1.0;\n\n\t// \t}\n\n\t// \treturn schlickFresnel( cosTheta, f0 );\n\n\t// }\n\n\t// https://schuttejoe.github.io/post/disneybsdf/\n\tfloat disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {\n\n\t\tfloat dotHV = dot( wo, wh );\n\t\tif ( totalInternalReflection( dotHV, eta ) ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tfloat dotHL = dot( wi, wh );\n\t\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );\n\t\tfloat metallicFresnel = schlickFresnel( dotHL, f0 );\n\n\t\treturn mix( dielectricFresnel, metallicFresnel, metalness );\n\n\t}\n\n`;\n", "export const math_functions = /* glsl */`\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n`;\n", "export const shape_intersection_functions = /* glsl */`\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the rectangle on that same plane.\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\n\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = p - center;\n\n\t\t\t// check if p falls inside the rectangle\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\n\n\t\t\t\tfloat a2 = dot( v, vi );\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\n\n\t\t\t\t\tdist = t;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.\n\tbool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\n\n\t\tfloat t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 hit = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = hit - position;\n\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tfloat a2 = dot( v, vi );\n\n\t\t\tif( length( vec2( a1, a2 ) ) <= 0.5 ) {\n\n\t\t\t\tdist = t;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n`;\n", "\nexport const texture_sample_functions = /*glsl */`\n\n\t// add texel fetch functions for texture arrays\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\n\n\t\tuint width = uint( textureSize( tex, 0 ).x );\n\t\tuvec2 uv;\n\t\tuv.x = index % width;\n\t\tuv.y = index / width;\n\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\n\n\t}\n\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\n\n\t\treturn\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\n\n\t}\n\n`;\n", "export const util_functions = /* glsl */`\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n`;\n", "export const pcg_functions = /* glsl */`\n\n\t// https://www.shadertoy.com/view/wltcRS\n\tuvec4 WHITE_NOISE_SEED;\n\n\tvoid rng_initialize( vec2 p, int frame ) {\n\n\t\t// white noise seed\n\t\tWHITE_NOISE_SEED = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\n\n\t}\n\n\t// https://www.pcg-random.org/\n\tvoid pcg4d( inout uvec4 v ) {\n\n\t\tv = v * 1664525u + 1013904223u;\n\t\tv.x += v.y * v.w;\n\t\tv.y += v.z * v.x;\n\t\tv.z += v.x * v.y;\n\t\tv.w += v.y * v.z;\n\t\tv = v ^ ( v >> 16u );\n\t\tv.x += v.y*v.w;\n\t\tv.y += v.z*v.x;\n\t\tv.z += v.x*v.y;\n\t\tv.w += v.y*v.z;\n\n\t}\n\n\t// returns [ 0, 1 ]\n\tfloat pcgRand() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn float( WHITE_NOISE_SEED.x ) / float( 0xffffffffu );\n\n\t}\n\n\tvec2 pcgRand2() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec2( WHITE_NOISE_SEED.xy ) / float(0xffffffffu);\n\n\t}\n\n\tvec3 pcgRand3() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec3( WHITE_NOISE_SEED.xyz ) / float( 0xffffffffu );\n\n\t}\n\n\tvec4 pcgRand4() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec4( WHITE_NOISE_SEED ) / float( 0xffffffffu );\n\n\t}\n`;\n", "export const stratified_functions = /* glsl */`\n\n\tuniform sampler2D stratifiedTexture;\n\tuniform sampler2D stratifiedOffsetTexture;\n\n\tuint sobolPixelIndex = 0u;\n\tuint sobolPathIndex = 0u;\n\tuint sobolBounceIndex = 0u;\n\tvec4 pixelSeed = vec4( 0 );\n\n\tvec4 rand4( int v ) {\n\n\t\tivec2 uv = ivec2( v, sobolBounceIndex );\n\t\tvec4 stratifiedSample = texelFetch( stratifiedTexture, uv, 0 );\n\t\treturn fract( stratifiedSample + pixelSeed.r ); // blue noise + stratified samples\n\n\t}\n\n\tvec3 rand3( int v ) {\n\n\t\treturn rand4( v ).xyz;\n\n\t}\n\n\tvec2 rand2( int v ) {\n\n\t\treturn rand4( v ).xy;\n\n\t}\n\n\tfloat rand( int v ) {\n\n\t\treturn rand4( v ).x;\n\n\t}\n\n\tvoid rng_initialize( vec2 screenCoord, int frame ) {\n\n\t\t// tile the small noise texture across the entire screen\n\t\tivec2 noiseSize = ivec2( textureSize( stratifiedOffsetTexture, 0 ) );\n\t\tivec2 pixel = ivec2( screenCoord.xy ) % noiseSize;\n\t\tvec2 pixelWidth = 1.0 / vec2( noiseSize );\n\t\tvec2 uv = vec2( pixel ) * pixelWidth + pixelWidth * 0.5;\n\n\t\t// note that using \"texelFetch\" here seems to break Android for some reason\n\t\tpixelSeed = texture( stratifiedOffsetTexture, uv );\n\n\t}\n\n`;\n", "/*\nwi     : incident vector or light vector (pointing toward the light)\nwo     : outgoing vector or view vector (pointing towards the camera)\nwh     : computed half vector from wo and wi\nEval   : Get the color and pdf for a direction\nSample : Get the direction, color, and pdf for a sample\neta    : Greek character used to denote the \"ratio of ior\"\nf0     : Amount of light reflected when looking at a surface head on - \"fresnel 0\"\nf90    : Amount of light reflected at grazing angles\n*/\n\nexport const bsdf_functions = /* glsl */`\n\n\t// diffuse\n\tfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat fl = schlickFresnel( wi.z, 0.0 );\n\t\tfloat fv = schlickFresnel( wo.z, 0.0 );\n\n\t\tfloat metalFactor = ( 1.0 - surf.metalness );\n\t\tfloat transFactor = ( 1.0 - surf.transmission );\n\t\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\n\t\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\n\t\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\n\n\t\t// TODO: subsurface approx?\n\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tfloat F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\n\t\tcolor = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\n\n\t\treturn wi.z / PI;\n\n\t}\n\n\tvec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tvec3 lightDirection = sampleSphere( rand2( 11 ) );\n\t\tlightDirection.z += 1.0;\n\t\tlightDirection = normalize( lightDirection );\n\n\t\treturn lightDirection;\n\n\t}\n\n\t// specular\n\tfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\t// if roughness is set to 0 then D === NaN which results in black pixels\n\t\tfloat metalness = surf.metalness;\n\t\tfloat roughness = surf.filteredRoughness;\n\n\t\tfloat eta = surf.eta;\n\t\tfloat f0 = surf.f0;\n\n\t\tvec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );\n\t\tvec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );\n\t\tvec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );\n\n\t\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );\n\t\tF = mix( F, iridescenceF,  surf.iridescence );\n\n\t\t// PDF\n\t\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\n\t\tfloat incidentTheta = acos( wo.z );\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\t\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );\n\n\t\tcolor = wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\t\treturn ggxPdf / ( 4.0 * dot( wo, wh ) );\n\n\t}\n\n\tvec3 specularDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\trand2( 12 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\n\t// transmission\n\t/*\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\t\tbool thinFilm = surf.thinFilm;\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\n\t\treturn ggxPDF( wo, wh, filteredRoughness ) / denom;\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( filteredRoughness ),\n\t\t\trand2( 13 )\n\t\t);\n\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\n\t\treturn normalize( lightDirection );\n\n\t}\n\t*/\n\n\t// TODO: This is just using a basic cosine-weighted specular distribution with an\n\t// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\t// PDF\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\t// float F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\n\t\t// if ( F >= 1.0 ) {\n\n\t\t// \treturn 0.0;\n\n\t\t// }\n\n\t\t// return 1.0 / ( 1.0 - F );\n\n\t\t// reverted to previous to transmission. The above was causing black pixels\n\t\tfloat eta = surf.eta;\n\t\tfloat f0 = surf.f0;\n\t\tfloat cosTheta = min( wo.z, 1.0 );\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\t\tfloat reflectance = schlickFresnel( cosTheta, f0 );\n\t\tbool cannotRefract = eta * sinTheta > 1.0;\n\t\tif ( cannotRefract ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 1.0 - reflectance );\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( rand2( 13 ) ) * roughness );\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\t\treturn normalize( lightDirection );\n\n\t}\n\n\t// clearcoat\n\tfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tfloat ior = 1.5;\n\t\tfloat f0 = iorRatioToF0( ior );\n\t\tbool frontFace = surf.frontFace;\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\n\t\tfloat eta = frontFace ? 1.0 / ior : ior;\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\n\n\t\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\n\t\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\n\n\t\t// PDF\n\t\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\t\treturn ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );\n\n\t}\n\n\tvec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\trand2( 14 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\t// sheen\n\tvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {\n\n\t\tfloat cosThetaO = saturateCos( wo.z );\n\t\tfloat cosThetaI = saturateCos( wi.z );\n\t\tfloat cosThetaH = wh.z;\n\n\t\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\n\t\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\n\n\t\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\t\tvec3 color = surf.sheenColor;\n\t\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\n\t\tcolor *= wi.z;\n\n\t\treturn color;\n\n\t}\n\n\t// bsdf\n\tvoid getLobeWeights(\n\t\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,\n\t\tinout float diffuseWeight, inout float specularWeight, inout float transmissionWeight, inout float clearcoatWeight\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\t\t// float fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tfloat fEstimate = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\n\n\t\tfloat transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );\n\t\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\n\t\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\t\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\n\t\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\n\t\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\n\n\t\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\n\t\tdiffuseWeight /= totalWeight;\n\t\tspecularWeight /= totalWeight;\n\t\ttransmissionWeight /= totalWeight;\n\t\tclearcoatWeight /= totalWeight;\n\t}\n\n\tfloat bsdfEval(\n\t\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,\n\t\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, inout float specularPdf, inout vec3 color\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\n\t\tfloat spdf = 0.0;\n\t\tfloat dpdf = 0.0;\n\t\tfloat tpdf = 0.0;\n\t\tfloat cpdf = 0.0;\n\t\tcolor = vec3( 0.0 );\n\n\t\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\n\n\t\t// diffuse\n\t\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\n\t\t\tcolor *= 1.0 - surf.transmission;\n\n\t\t}\n\n\t\t// ggx specular\n\t\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tvec3 outColor;\n\t\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\n\t\t\tcolor += outColor;\n\n\t\t}\n\n\t\t// transmission\n\t\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\n\n\t\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\n\n\t\t}\n\n\t\t// sheen\n\t\tcolor *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );\n\t\tcolor += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;\n\n\t\t// clearcoat\n\t\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\n\t\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\n\n\t\t}\n\n\t\tfloat pdf =\n\t\t\tdpdf * diffuseWeight\n\t\t\t+ spdf * specularWeight\n\t\t\t+ tpdf * transmissionWeight\n\t\t\t+ cpdf * clearcoatWeight;\n\n\t\t// retrieve specular rays for the shadows flag\n\t\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\n\n\t\treturn pdf;\n\n\t}\n\n\tfloat bsdfResult( vec3 worldWo, vec3 worldWi, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tcolor = surf.color / ( 4.0 * PI );\n\t\t\treturn 1.0 / ( 4.0 * PI );\n\n\t\t}\n\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\n\t\tvec3 wi = normalize( surf.normalInvBasis * worldWi );\n\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\n\t\tvec3 clearcoatWi = normalize( surf.clearcoatInvBasis * worldWi );\n\n\t\tvec3 wh = getHalfVector( wo, wi, surf.eta );\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat specularPdf;\n\t\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\n\n\t}\n\n\tScatterRecord bsdfSample( vec3 worldWo, SurfaceRecord surf ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tScatterRecord sampleRec;\n\t\t\tsampleRec.specularPdf = 0.0;\n\t\t\tsampleRec.pdf = 1.0 / ( 4.0 * PI );\n\t\t\tsampleRec.direction = sampleSphere( rand2( 16 ) );\n\t\t\tsampleRec.color = surf.color / ( 4.0 * PI );\n\t\t\treturn sampleRec;\n\n\t\t}\n\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\n\t\tmat3 normalBasis = surf.normalBasis;\n\t\tmat3 invBasis = surf.normalInvBasis;\n\t\tmat3 clearcoatNormalBasis = surf.clearcoatBasis;\n\t\tmat3 clearcoatInvBasis = surf.clearcoatInvBasis;\n\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\t// using normal and basically-reflected ray since we don't have proper half vector here\n\t\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat pdf[4];\n\t\tpdf[0] = diffuseWeight;\n\t\tpdf[1] = specularWeight;\n\t\tpdf[2] = transmissionWeight;\n\t\tpdf[3] = clearcoatWeight;\n\n\t\tfloat cdf[4];\n\t\tcdf[0] = pdf[0];\n\t\tcdf[1] = pdf[1] + cdf[0];\n\t\tcdf[2] = pdf[2] + cdf[1];\n\t\tcdf[3] = pdf[3] + cdf[2];\n\n\t\tif( cdf[3] != 0.0 ) {\n\n\t\t\tfloat invMaxCdf = 1.0 / cdf[3];\n\t\t\tcdf[0] *= invMaxCdf;\n\t\t\tcdf[1] *= invMaxCdf;\n\t\t\tcdf[2] *= invMaxCdf;\n\t\t\tcdf[3] *= invMaxCdf;\n\n\t\t} else {\n\n\t\t\tcdf[0] = 1.0;\n\t\t\tcdf[1] = 0.0;\n\t\t\tcdf[2] = 0.0;\n\t\t\tcdf[3] = 0.0;\n\n\t\t}\n\n\t\tvec3 wi;\n\t\tvec3 clearcoatWi;\n\n\t\tfloat r = rand( 15 );\n\t\tif ( r <= cdf[0] ) { // diffuse\n\n\t\t\twi = diffuseDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[1] ) { // specular\n\n\t\t\twi = specularDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[2] ) { // transmission / refraction\n\n\t\t\twi = transmissionDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[3] ) { // clearcoat\n\n\t\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\n\t\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\n\n\t\t}\n\n\t\tScatterRecord result;\n\t\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\n\t\tresult.direction = normalize( surf.normalBasis * wi );\n\n\t\treturn result;\n\n\t}\n\n`;\n", "export const fog_functions = /* glsl */`\n\n\t// returns the hit distance given the material density\n\tfloat intersectFogVolume( Material material, float u ) {\n\n\t\t// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums\n\t\treturn material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );\n\n\t}\n\n\tScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {\n\n\t\tScatterRecord sampleRec;\n\t\tsampleRec.specularPdf = 0.0;\n\t\tsampleRec.pdf = 1.0 / ( 2.0 * PI );\n\t\tsampleRec.direction = sampleSphere( uv );\n\t\tsampleRec.color = surf.color;\n\t\treturn sampleRec;\n\n\t}\n\n`;\n", "export const ggx_functions = /* glsl */`\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n`;\n", "export const iridescence_functions = /* glsl */`\n\n\t// XYZ to sRGB color space\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\n\tvec3 fresnel0ToIor( vec3 fresnel0 ) {\n\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n\t}\n\n\t// Conversion FO/IOR\n\tvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n\t}\n\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\n\tfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\n\n\t}\n\n\t// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\n\t\txyz /= 1.0685e-7;\n\n\t\tvec3 srgb = XYZ_TO_REC709 * xyz;\n\t\treturn srgb;\n\n\t}\n\n\t// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\t\tvec3 I;\n\n\t\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n\t\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\n\t\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\n\n\t\t// Handle TIR:\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\n\t\t\treturn vec3( 1.0 );\n\n\t\t}\n\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\n\t\t// First interface\n\t\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\n\t\tfloat R12 = schlickFresnel( cosTheta1, R0 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIor < outsideIOR ) {\n\n\t\t\tphi12 = PI;\n\n\t\t}\n\n\t\tfloat phi21 = PI - phi12;\n\n\t\t// Second interface\n\t\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\t\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\n\t\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[0] < iridescenceIor ) {\n\n\t\t\tphi23[ 0 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[1] < iridescenceIor ) {\n\n\t\t\tphi23[ 1 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[2] < iridescenceIor ) {\n\n\t\t\tphi23[ 2 ] = PI;\n\n\t\t}\n\n\t\t// Phase shift\n\t\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\n\t\t// Compound terms\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t\t// Reflectance term for m = 0 (DC term amplitude)\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\n\t\t// Reflectance term for m > 0 (pairs of diracs)\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\n\t\t}\n\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\t\treturn max( I, vec3( 0.0 ) );\n\n\t}\n\n`;\n", "export const sheen_functions = /* glsl */`\n\n\t// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetD( float cosThetaH, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat invAlpha = 1.0 / alpha;\n\n\t\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\n\t\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\n\n\t\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\n\n\t}\n\n\tfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\n\n\t\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\n\t\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\n\n\t\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\n\n\t}\n\n\tfloat velvetL( float x, float alpha ) {\n\n\t\tfloat oneMinusAlpha = 1.0 - alpha;\n\t\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\n\n\t\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\n\t\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\n\t\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\n\t\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\n\t\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\n\n\t\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\n\n\t}\n\n\t// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetLambda( float cosTheta, float alpha ) {\n\n\t\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\n\n\t}\n\n\t// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\n\n\t}\n\n\tfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\n\n\t\tcosTheta = saturate( cosTheta );\n\n\t\tfloat c = 1.0 - cosTheta;\n\t\tfloat c3 = c * c * c;\n\n\t\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\n\n\t}\n\n\tfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\t\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\n\n\t\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\n\n\t}\n\n\t// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\n\t\treturn 1.0 - maxSheenColor * eWo;\n\n\t}\n\n`;\n", "export const inside_fog_volume_function = /* glsl */`\n\n#ifndef FOG_CHECK_ITERATIONS\n#define FOG_CHECK_ITERATIONS 30\n#endif\n\n// returns whether the given material is a fog material or not\nbool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {\n\n\tuint i = materialIndex * 45u;\n\tvec4 s14 = texelFetch1D( materials, i + 14u );\n\treturn bool( int( s14.b ) & 4 );\n\n}\n\n// returns true if we're within the first fog volume we hit\nbool bvhIntersectFogVolumeHit(\n\tvec3 rayOrigin, vec3 rayDirection,\n\tusampler2D materialIndexAttribute, sampler2D materials,\n\tinout Material material\n) {\n\n\tmaterial.fogVolume = false;\n\n\tfor ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {\n\n\t\t// find nearest hit\n\t\tuvec4 faceIndices = uvec4( 0u );\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\tvec3 barycoord = vec3( 0.0 );\n\t\tfloat side = 1.0;\n\t\tfloat dist = 0.0;\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\tif ( hit ) {\n\n\t\t\t// if it's a fog volume return whether we hit the front or back face\n\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\tif ( isMaterialFogVolume( materials, materialIndex ) ) {\n\n\t\t\t\tmaterial = readMaterialInfo( materials, materialIndex );\n\t\t\t\treturn side == - 1.0;\n\n\t\t\t} else {\n\n\t\t\t\t// move the ray forward\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n`;\n", "export const attenuate_hit_function = /* glsl */`\n\n\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\n\t// returns true if a solid surface was hit\n\tbool attenuateHit(\n\t\tRenderState state,\n\t\tRay ray, float rayDist,\n\t\tout vec3 color\n\t) {\n\n\t\t// store the original bounce index so we can reset it after\n\t\tuint originalBounceIndex = sobolBounceIndex;\n\n\t\tint traversals = state.traversals;\n\t\tint transmissiveTraversals = state.transmissiveTraversals;\n\t\tbool isShadowRay = state.isShadowRay;\n\t\tMaterial fogMaterial = state.fogMaterial;\n\n\t\tvec3 startPoint = ray.origin;\n\n\t\t// hit results\n\t\tSurfaceHit surfaceHit;\n\n\t\tcolor = vec3( 1.0 );\n\n\t\tbool result = true;\n\t\tfor ( int i = 0; i < traversals; i ++ ) {\n\n\t\t\tsobolBounceIndex ++;\n\n\t\t\tint hitType = traceScene( ray, fogMaterial, surfaceHit );\n\n\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\n\t\t\t} else if ( hitType == SURFACE_HIT ) {\n\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * surfaceHit.dist );\n\t\t\t\tif ( totalDist > rayDist ) {\n\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\n\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\n\t\t\t\t// TODO: should we account for emissive surfaces here?\n\n\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\n\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t// adjust the ray to the new surface\n\t\t\t\tbool isEntering = surfaceHit.side == 1.0;\n\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\n\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\tif ( material.fogVolume ) {\n\n\t\t\t\t\tfogMaterial = material;\n\t\t\t\t\tfogMaterial.fogVolume = surfaceHit.side == 1.0;\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\n\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\n\n\t\t\t\t// albedo\n\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.vertexColors ) {\n\n\t\t\t\t\talbedo *= vertexColor;\n\n\t\t\t\t}\n\n\t\t\t\t// alphaMap\n\t\t\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t}\n\n\t\t\t\t// transmission\n\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t}\n\n\t\t\t\t// metalness\n\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t}\n\n\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\n\t\t\t\tif (\n\t\t\t\t\ttransmissionFactor < rand( 9 ) && ! (\n\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\tmaterial.side != 0.0 && surfaceHit.side == material.side\n\n\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 10 )\n\t\t\t\t\t)\n\t\t\t\t) {\n\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( surfaceHit.side == 1.0 && isEntering ) {\n\n\t\t\t\t\t// only attenuate by surface color on the way in\n\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\n\n\t\t\t\t} else if ( surfaceHit.side == - 1.0 ) {\n\n\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\n\t\t\t\t\tcolor *= transmissionAttenuation( surfaceHit.dist, material.attenuationColor, material.attenuationDistance );\n\n\t\t\t\t}\n\n\t\t\t\tbool isTransmissiveRay = dot( ray.direction, surfaceHit.faceNormal * surfaceHit.side ) < 0.0;\n\t\t\t\tif ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {\n\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// reset the bounce index\n\t\tsobolBounceIndex = originalBounceIndex;\n\t\treturn result;\n\n\t}\n\n`;\n", "export const camera_util_functions = /* glsl */`\n\n\tvec3 ndcToRayOrigin( vec2 coord ) {\n\n\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\n\t\treturn rayOrigin4.xyz / rayOrigin4.w;\n\t}\n\n\tRay getCameraRay() {\n\n\t\tvec2 ssd = vec2( 1.0 ) / resolution;\n\n\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\n\t\t// around this pixel's UV coordinate for AA\n\t\tvec2 ruv = rand2( 0 );\n\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\n\t\tRay ray;\n\n\t\t#if CAMERA_TYPE == 2\n\n\t\t\t// Equirectangular projection\n\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\n\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\n\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\n\n\t\t\tray.direction = normalize( rayDirection4.xyz );\n\t\t\tray.origin = rayOrigin4.xyz / rayOrigin4.w;\n\n\t\t#else\n\n\t\t\t// get [- 1, 1] normalized device coordinates\n\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\n\t\t\tray.origin = ndcToRayOrigin( ndc );\n\n\t\t\t#if CAMERA_TYPE == 1\n\n\t\t\t\t// Orthographic projection\n\t\t\t\tray.direction = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\n\t\t\t\tray.direction = normalize( ray.direction );\n\n\t\t\t#else\n\n\t\t\t\t// Perspective projection\n\t\t\t\tray.direction = normalize( mat3( cameraWorldMatrix ) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#if FEATURE_DOF\n\t\t{\n\n\t\t\t// depth of field\n\t\t\tvec3 focalPoint = ray.origin + normalize( ray.direction ) * physicalCamera.focusDistance;\n\n\t\t\t// get the aperture sample\n\t\t\t// if blades === 0 then we assume a circle\n\t\t\tvec3 shapeUVW= rand3( 1 );\n\t\t\tint blades = physicalCamera.apertureBlades;\n\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\n\t\t\tvec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularPolygon( blades, shapeUVW );\n\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t// rotate the aperture shape\n\t\t\tapertureSample =\n\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\n\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\n\n\t\t\t// create the new ray\n\t\t\tray.origin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\tray.direction = focalPoint - ray.origin;\n\n\t\t}\n\t\t#endif\n\n\t\tray.direction = normalize( ray.direction );\n\n\t\treturn ray;\n\n\t}\n\n`;\n", "export const direct_light_contribution_function = /*glsl*/`\n\n\tvec3 directLightContribution( vec3 worldWo, SurfaceRecord surf, RenderState state, vec3 rayOrigin ) {\n\n\t\tvec3 result = vec3( 0.0 );\n\n\t\t// uniformly pick a light or environment map\n\t\tif( lightsDenom != 0.0 && rand( 5 ) < float( lights.count ) / lightsDenom ) {\n\n\t\t\t// sample a light or environment\n\t\t\tLightRecord lightRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, rand3( 6 ) );\n\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, lightRec.direction ) < 0.0;\n\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\tlightRec.pdf = 0.0;\n\n\t\t\t}\n\n\t\t\t// check if a ray could even reach the light area\n\t\t\tRay lightRay;\n\t\t\tlightRay.origin = rayOrigin;\n\t\t\tlightRay.direction = lightRec.direction;\n\t\t\tvec3 attenuatedColor;\n\t\t\tif (\n\t\t\t\tlightRec.pdf > 0.0 &&\n\t\t\t\tisDirectionValid( lightRec.direction, surf.normal, surf.faceNormal ) &&\n\t\t\t\t! attenuateHit( state, lightRay, lightRec.dist, attenuatedColor )\n\t\t\t) {\n\n\t\t\t\t// get the material pdf\n\t\t\t\tvec3 sampleColor;\n\t\t\t\tfloat lightMaterialPdf = bsdfResult( worldWo, lightRec.direction, surf, sampleColor );\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\tfloat lightPdf = lightRec.pdf / lightsDenom;\n\t\t\t\t\tfloat misWeight = lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\n\t\t\t\t\tresult = attenuatedColor * lightRec.emission * state.throughputColor * sampleColor * misWeight / lightPdf;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( envMapInfo.totalSum != 0.0 && environmentIntensity != 0.0 ) {\n\n\t\t\t// find a sample in the environment map to include in the contribution\n\t\t\tvec3 envColor, envDirection;\n\t\t\tfloat envPdf = sampleEquirectProbability( rand2( 7 ), envColor, envDirection );\n\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\n\n\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\n\t\t\t// results so we ignore the sample in this case.\n\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, envDirection ) < 0.0;\n\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\tenvPdf = 0.0;\n\n\t\t\t}\n\n\t\t\t// check if a ray could even reach the surface\n\t\t\tRay envRay;\n\t\t\tenvRay.origin = rayOrigin;\n\t\t\tenvRay.direction = envDirection;\n\t\t\tvec3 attenuatedColor;\n\t\t\tif (\n\t\t\t\tenvPdf > 0.0 &&\n\t\t\t\tisDirectionValid( envDirection, surf.normal, surf.faceNormal ) &&\n\t\t\t\t! attenuateHit( state, envRay, INFINITY, attenuatedColor )\n\t\t\t) {\n\n\t\t\t\t// get the material pdf\n\t\t\t\tvec3 sampleColor;\n\t\t\t\tfloat envMaterialPdf = bsdfResult( worldWo, envDirection, surf, sampleColor );\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\tenvPdf /= lightsDenom;\n\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\n\t\t\t\t\tresult = attenuatedColor * environmentIntensity * envColor * state.throughputColor * sampleColor * misWeight / envPdf;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Function changed to have a single return statement to potentially help with crashes on Mac OS.\n\t\t// See issue #470\n\t\treturn result;\n\n\t}\n\n`;\n", "\nexport const get_surface_record_function = /* glsl */`\n\n\t#define SKIP_SURFACE 0\n\t#define HIT_SURFACE 1\n\tint getSurfaceRecord(\n\t\tMaterial material, SurfaceHit surfaceHit, sampler2DArray attributesArray,\n\t\tfloat accumulatedRoughness,\n\t\tinout SurfaceRecord surf\n\t) {\n\n\t\tif ( material.fogVolume ) {\n\n\t\t\tvec3 normal = vec3( 0, 0, 1 );\n\n\t\t\tSurfaceRecord fogSurface;\n\t\t\tfogSurface.volumeParticle = true;\n\t\t\tfogSurface.color = material.color;\n\t\t\tfogSurface.emission = material.emissiveIntensity * material.emissive;\n\t\t\tfogSurface.normal = normal;\n\t\t\tfogSurface.faceNormal = normal;\n\t\t\tfogSurface.clearcoatNormal = normal;\n\n\t\t\tsurf = fogSurface;\n\t\t\treturn HIT_SURFACE;\n\n\t\t}\n\n\t\t// uv coord for textures\n\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\n\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\n\n\t\t// albedo\n\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\tif ( material.map != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t}\n\n\t\tif ( material.vertexColors ) {\n\n\t\t\talbedo *= vertexColor;\n\n\t\t}\n\n\t\t// alphaMap\n\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t}\n\n\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t// and it's single sided.\n\t\t// - alpha test is disabled when it === 0\n\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\tfloat alphaTest = material.alphaTest;\n\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\tif (\n\t\t\t// material sidedness\n\t\t\tmaterial.side != 0.0 && surfaceHit.side != material.side\n\n\t\t\t// alpha test\n\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t// opacity\n\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 3 )\n\t\t) {\n\n\t\t\treturn SKIP_SURFACE;\n\n\t\t}\n\n\t\t// fetch the interpolated smooth normal\n\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\tattributesArray,\n\t\t\tATTR_NORMAL,\n\t\t\tsurfaceHit.barycoord,\n\t\t\tsurfaceHit.faceIndices.xyz\n\t\t).xyz );\n\n\t\t// roughness\n\t\tfloat roughness = material.roughness;\n\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\n\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\n\n\t\t}\n\n\t\t// metalness\n\t\tfloat metalness = material.metalness;\n\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t}\n\n\t\t// emission\n\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\n\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\n\n\t\t}\n\n\t\t// transmission\n\t\tfloat transmission = material.transmission;\n\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t}\n\n\t\t// normal\n\t\tif ( material.flatShading ) {\n\n\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\n\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\n\t\t\t// interpolated vertex normals.\n\t\t\tnormal = surfaceHit.faceNormal * surfaceHit.side;\n\n\t\t}\n\n\t\tvec3 baseNormal = normal;\n\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tsurfaceHit.barycoord,\n\t\t\t\tsurfaceHit.faceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tnormal *= surfaceHit.side;\n\n\t\t// clearcoat\n\t\tfloat clearcoat = material.clearcoat;\n\t\tif ( material.clearcoatMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\n\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\n\n\t\t}\n\n\t\t// clearcoatRoughness\n\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\n\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\n\n\t\t}\n\n\t\t// clearcoatNormal\n\t\tvec3 clearcoatNormal = baseNormal;\n\t\tif ( material.clearcoatNormalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tsurfaceHit.barycoord,\n\t\t\t\tsurfaceHit.faceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\n\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\n\t\t\t\tclearcoatNormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tclearcoatNormal *= surfaceHit.side;\n\n\t\t// sheenColor\n\t\tvec3 sheenColor = material.sheenColor;\n\t\tif ( material.sheenColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\n\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// sheenRoughness\n\t\tfloat sheenRoughness = material.sheenRoughness;\n\t\tif ( material.sheenRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\n\n\t\t}\n\n\t\t// iridescence\n\t\tfloat iridescence = material.iridescence;\n\t\tif ( material.iridescenceMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\n\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\n\n\t\t}\n\n\t\t// iridescence thickness\n\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\n\t\tif ( material.iridescenceThicknessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\n\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\n\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\n\n\t\t}\n\n\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\n\n\t\t// specular color\n\t\tvec3 specularColor = material.specularColor;\n\t\tif ( material.specularColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\n\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// specular intensity\n\t\tfloat specularIntensity = material.specularIntensity;\n\t\tif ( material.specularIntensityMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\n\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\n\n\t\t}\n\n\t\tsurf.volumeParticle = false;\n\n\t\tsurf.faceNormal = surfaceHit.faceNormal;\n\t\tsurf.normal = normal;\n\n\t\tsurf.metalness = metalness;\n\t\tsurf.color = albedo.rgb;\n\t\tsurf.emission = emission;\n\n\t\tsurf.ior = material.ior;\n\t\tsurf.transmission = transmission;\n\t\tsurf.thinFilm = material.thinFilm;\n\t\tsurf.attenuationColor = material.attenuationColor;\n\t\tsurf.attenuationDistance = material.attenuationDistance;\n\n\t\tsurf.clearcoatNormal = clearcoatNormal;\n\t\tsurf.clearcoat = clearcoat;\n\n\t\tsurf.sheen = material.sheen;\n\t\tsurf.sheenColor = sheenColor;\n\n\t\tsurf.iridescence = iridescence;\n\t\tsurf.iridescenceIor = material.iridescenceIor;\n\t\tsurf.iridescenceThickness = iridescenceThickness;\n\n\t\tsurf.specularColor = specularColor;\n\t\tsurf.specularIntensity = specularIntensity;\n\n\t\t// apply perceptual roughness factor from gltf. sheen perceptual roughness is\n\t\t// applied by its brdf function\n\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\n\t\tsurf.roughness = roughness * roughness;\n\t\tsurf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\n\t\tsurf.sheenRoughness = sheenRoughness;\n\n\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t// then we can just always assume this is a front face.\n\t\tsurf.frontFace = surfaceHit.side == 1.0 || transmission == 0.0;\n\t\tsurf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;\n\t\tsurf.f0 = iorRatioToF0( surf.eta );\n\n\t\t// Compute the filtered roughness value to use during specular reflection computations.\n\t\t// The accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\n\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t// sharp internal reflections\n\t\tsurf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );\n\t\tsurf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );\n\n\t\t// get the normal frames\n\t\tsurf.normalBasis = getBasisFromNormal( surf.normal );\n\t\tsurf.normalInvBasis = inverse( surf.normalBasis );\n\n\t\tsurf.clearcoatBasis = getBasisFromNormal( surf.clearcoatNormal );\n\t\tsurf.clearcoatInvBasis = inverse( surf.clearcoatBasis );\n\n\t\treturn HIT_SURFACE;\n\n\t}\n`;\n", "export const render_structs = /* glsl */`\n\n\tstruct Ray {\n\n\t\tvec3 origin;\n\t\tvec3 direction;\n\n\t};\n\n\tstruct SurfaceHit {\n\n\t\tuvec4 faceIndices;\n\t\tvec3 barycoord;\n\t\tvec3 faceNormal;\n\t\tfloat side;\n\t\tfloat dist;\n\n\t};\n\n\tstruct RenderState {\n\n\t\tbool firstRay;\n\t\tbool transmissiveRay;\n\t\tbool isShadowRay;\n\t\tfloat accumulatedRoughness;\n\t\tint transmissiveTraversals;\n\t\tint traversals;\n\t\tuint depth;\n\t\tvec3 throughputColor;\n\t\tMaterial fogMaterial;\n\n\t};\n\n\tRenderState initRenderState() {\n\n\t\tRenderState result;\n\t\tresult.firstRay = true;\n\t\tresult.transmissiveRay = true;\n\t\tresult.isShadowRay = false;\n\t\tresult.accumulatedRoughness = 0.0;\n\t\tresult.transmissiveTraversals = 0;\n\t\tresult.traversals = 0;\n\t\tresult.throughputColor = vec3( 1.0 );\n\t\tresult.depth = 0u;\n\t\tresult.fogMaterial.fogVolume = false;\n\t\treturn result;\n\n\t}\n\n`;\n", "export const trace_scene_function = /* glsl */`\n\n\t#define NO_HIT 0\n\t#define SURFACE_HIT 1\n\t#define LIGHT_HIT 2\n\t#define FOG_HIT 3\n\n\t// Passing the global variable 'lights' into this function caused shader program errors.\n\t// So global variables like 'lights' and 'bvh' were moved out of the function parameters.\n\t// For more information, refer to: https://github.com/gkjohnson/three-gpu-pathtracer/pull/457\n\tint traceScene(\n\t\tRay ray, Material fogMaterial, inout SurfaceHit surfaceHit\n\t) {\n\n\t\tint result = NO_HIT;\n\t\tbool hit = bvhIntersectFirstHit( bvh, ray.origin, ray.direction, surfaceHit.faceIndices, surfaceHit.faceNormal, surfaceHit.barycoord, surfaceHit.side, surfaceHit.dist );\n\n\t\t#if FEATURE_FOG\n\n\t\tif ( fogMaterial.fogVolume ) {\n\n\t\t\t// offset the distance so we don't run into issues with particles on the same surface\n\t\t\t// as other objects\n\t\t\tfloat particleDist = intersectFogVolume( fogMaterial, rand( 1 ) );\n\t\t\tif ( particleDist + RAY_OFFSET < surfaceHit.dist ) {\n\n\t\t\t\tsurfaceHit.side = 1.0;\n\t\t\t\tsurfaceHit.faceNormal = normalize( - ray.direction );\n\t\t\t\tsurfaceHit.dist = particleDist;\n\t\t\t\treturn FOG_HIT;\n\n\t\t\t}\n\n\t\t}\n\n\t\t#endif\n\n\t\tif ( hit ) {\n\n\t\t\tresult = SURFACE_HIT;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n`;\n", "import { ClampToEdgeWrapping, HalfFloatType, Matrix4, Vector2 } from 'three';\nimport { MaterialBase } from '../MaterialBase.js';\nimport {\n\tMeshBVHUniformStruct, UIntVertexAttributeTexture,\n\tBVHShaderGLSL,\n} from 'three-mesh-bvh';\n\n// uniforms\nimport { PhysicalCameraUniform } from '../../uniforms/PhysicalCameraUniform.js';\nimport { EquirectHdrInfoUniform } from '../../uniforms/EquirectHdrInfoUniform.js';\nimport { LightsInfoUniformStruct } from '../../uniforms/LightsInfoUniformStruct.js';\nimport { AttributesTextureArray } from '../../uniforms/AttributesTextureArray.js';\nimport { MaterialsTexture } from '../../uniforms/MaterialsTexture.js';\nimport { RenderTarget2DArray } from '../../uniforms/RenderTarget2DArray.js';\nimport { StratifiedSamplesTexture } from '../../uniforms/StratifiedSamplesTexture.js';\nimport { BlueNoiseTexture } from '../../textures/BlueNoiseTexture.js';\n\n// general glsl\nimport * as StructsGLSL from '../../shader/structs/index.js';\nimport * as SamplingGLSL from '../../shader/sampling/index.js';\nimport * as CommonGLSL from '../../shader/common/index.js';\nimport * as RandomGLSL from '../../shader/rand/index.js';\nimport * as BSDFGLSL from '../../shader/bsdf/index.js';\nimport * as PTBVHGLSL from '../../shader/bvh/index.js';\n\n// path tracer glsl\nimport * as RenderGLSL from './glsl/index.js';\n\nexport class PhysicalPathTracingMaterial extends MaterialBase {\n\n\tonBeforeRender() {\n\n\t\tthis.setDefine( 'FEATURE_DOF', this.physicalCamera.bokehSize === 0 ? 0 : 1 );\n\t\tthis.setDefine( 'FEATURE_BACKGROUND_MAP', this.backgroundMap ? 1 : 0 );\n\t\tthis.setDefine( 'FEATURE_FOG', this.materials.features.isUsed( 'FOG' ) ? 1 : 0 );\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false,\n\n\t\t\tdefines: {\n\t\t\t\tFEATURE_MIS: 1,\n\t\t\t\tFEATURE_RUSSIAN_ROULETTE: 1,\n\t\t\t\tFEATURE_DOF: 1,\n\t\t\t\tFEATURE_BACKGROUND_MAP: 0,\n\t\t\t\tFEATURE_FOG: 1,\n\n\t\t\t\t// 0 = PCG\n\t\t\t\t// 1 = Sobol\n\t\t\t\t// 2 = Stratified List\n\t\t\t\tRANDOM_TYPE: 2,\n\n\t\t\t\t// 0 = Perspective\n\t\t\t\t// 1 = Orthographic\n\t\t\t\t// 2 = Equirectangular\n\t\t\t\tCAMERA_TYPE: 0,\n\n\t\t\t\tDEBUG_MODE: 0,\n\n\t\t\t\tATTR_NORMAL: 0,\n\t\t\t\tATTR_TANGENT: 1,\n\t\t\t\tATTR_UV: 2,\n\t\t\t\tATTR_COLOR: 3,\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\t// path trace uniforms\n\t\t\t\tresolution: { value: new Vector2() },\n\t\t\t\topacity: { value: 1 },\n\t\t\t\tbounces: { value: 10 },\n\t\t\t\ttransmissiveBounces: { value: 10 },\n\t\t\t\tfilterGlossyFactor: { value: 0 },\n\n\t\t\t\t// camera uniforms\n\t\t\t\tphysicalCamera: { value: new PhysicalCameraUniform() },\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\n\n\t\t\t\t// scene uniforms\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\n\t\t\t\tattributesArray: { value: new AttributesTextureArray() },\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\n\t\t\t\tmaterials: { value: new MaterialsTexture() },\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\n\n\t\t\t\t// light uniforms\n\t\t\t\tlights: { value: new LightsInfoUniformStruct() },\n\t\t\t\tiesProfiles: { value: new RenderTarget2DArray( 360, 180, {\n\t\t\t\t\ttype: HalfFloatType,\n\t\t\t\t\twrapS: ClampToEdgeWrapping,\n\t\t\t\t\twrapT: ClampToEdgeWrapping,\n\t\t\t\t} ).texture },\n\t\t\t\tenvironmentIntensity: { value: 1.0 },\n\t\t\t\tenvironmentRotation: { value: new Matrix4() },\n\t\t\t\tenvMapInfo: { value: new EquirectHdrInfoUniform() },\n\n\t\t\t\t// background uniforms\n\t\t\t\tbackgroundBlur: { value: 0.0 },\n\t\t\t\tbackgroundMap: { value: null },\n\t\t\t\tbackgroundAlpha: { value: 1.0 },\n\t\t\t\tbackgroundIntensity: { value: 1.0 },\n\t\t\t\tbackgroundRotation: { value: new Matrix4() },\n\n\t\t\t\t// randomness uniforms\n\t\t\t\tseed: { value: 0 },\n\t\t\t\tsobolTexture: { value: null },\n\t\t\t\tstratifiedTexture: { value: new StratifiedSamplesTexture() },\n\t\t\t\tstratifiedOffsetTexture: { value: new BlueNoiseTexture( 64, 1 ) },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\t\t\t\t#define INFINITY 1e20\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\n\t\t\t\t// bvh intersection\n\t\t\t\t${ BVHShaderGLSL.common_functions }\n\t\t\t\t${ BVHShaderGLSL.bvh_struct_definitions }\n\t\t\t\t${ BVHShaderGLSL.bvh_ray_functions }\n\n\t\t\t\t// uniform structs\n\t\t\t\t${ StructsGLSL.camera_struct }\n\t\t\t\t${ StructsGLSL.lights_struct }\n\t\t\t\t${ StructsGLSL.equirect_struct }\n\t\t\t\t${ StructsGLSL.material_struct }\n\t\t\t\t${ StructsGLSL.surface_record_struct }\n\n\t\t\t\t// random\n\t\t\t\t#if RANDOM_TYPE == 2 \t// Stratified List\n\n\t\t\t\t\t${ RandomGLSL.stratified_functions }\n\n\t\t\t\t#elif RANDOM_TYPE == 1 \t// Sobol\n\n\t\t\t\t\t${ RandomGLSL.pcg_functions }\n\t\t\t\t\t${ RandomGLSL.sobol_common }\n\t\t\t\t\t${ RandomGLSL.sobol_functions }\n\n\t\t\t\t\t#define rand(v) sobol(v)\n\t\t\t\t\t#define rand2(v) sobol2(v)\n\t\t\t\t\t#define rand3(v) sobol3(v)\n\t\t\t\t\t#define rand4(v) sobol4(v)\n\n\t\t\t\t#else \t\t\t\t\t// PCG\n\n\t\t\t\t${ RandomGLSL.pcg_functions }\n\n\t\t\t\t\t// Using the sobol functions seems to break the the compiler on MacOS\n\t\t\t\t\t// - specifically the \"sobolReverseBits\" function.\n\t\t\t\t\tuint sobolPixelIndex = 0u;\n\t\t\t\t\tuint sobolPathIndex = 0u;\n\t\t\t\t\tuint sobolBounceIndex = 0u;\n\n\t\t\t\t\t#define rand(v) pcgRand()\n\t\t\t\t\t#define rand2(v) pcgRand2()\n\t\t\t\t\t#define rand3(v) pcgRand3()\n\t\t\t\t\t#define rand4(v) pcgRand4()\n\n\t\t\t\t#endif\n\n\t\t\t\t// common\n\t\t\t\t${ CommonGLSL.texture_sample_functions }\n\t\t\t\t${ CommonGLSL.fresnel_functions }\n\t\t\t\t${ CommonGLSL.util_functions }\n\t\t\t\t${ CommonGLSL.math_functions }\n\t\t\t\t${ CommonGLSL.shape_intersection_functions }\n\n\t\t\t\t// environment\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\n\t\t\t\tuniform mat4 environmentRotation;\n\t\t\t\tuniform float environmentIntensity;\n\n\t\t\t\t// lighting\n\t\t\t\tuniform sampler2DArray iesProfiles;\n\t\t\t\tuniform LightsInfo lights;\n\n\t\t\t\t// background\n\t\t\t\tuniform float backgroundBlur;\n\t\t\t\tuniform float backgroundAlpha;\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\tuniform sampler2D backgroundMap;\n\t\t\t\tuniform mat4 backgroundRotation;\n\t\t\t\tuniform float backgroundIntensity;\n\n\t\t\t\t#endif\n\n\t\t\t\t// camera\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\t#if FEATURE_DOF\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\t// geometry\n\t\t\t\tuniform sampler2DArray attributesArray;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform sampler2D materials;\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tuniform BVH bvh;\n\n\t\t\t\t// path tracer\n\t\t\t\tuniform int bounces;\n\t\t\t\tuniform int transmissiveBounces;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\n\t\t\t\t// image\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t// globals\n\t\t\t\tmat3 envRotation3x3;\n\t\t\t\tmat3 invEnvRotation3x3;\n\t\t\t\tfloat lightsDenom;\n\n\t\t\t\t// sampling\n\t\t\t\t${ SamplingGLSL.shape_sampling_functions }\n\t\t\t\t${ SamplingGLSL.equirect_functions }\n\t\t\t\t${ SamplingGLSL.light_sampling_functions }\n\n\t\t\t\t${ PTBVHGLSL.inside_fog_volume_function }\n\t\t\t\t${ BSDFGLSL.ggx_functions }\n\t\t\t\t${ BSDFGLSL.sheen_functions }\n\t\t\t\t${ BSDFGLSL.iridescence_functions }\n\t\t\t\t${ BSDFGLSL.fog_functions }\n\t\t\t\t${ BSDFGLSL.bsdf_functions }\n\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\n\n\t\t\t\t\treturn clamp(\n\t\t\t\t\t\tmax(\n\t\t\t\t\t\t\troughness,\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t1.0\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\n\n\t\t\t\t\tvec3 sampleDir = sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur;\n\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\t\tsampleDir = normalize( mat3( backgroundRotation ) * direction + sampleDir );\n\t\t\t\t\treturn backgroundIntensity * sampleEquirectColor( backgroundMap, sampleDir );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\tsampleDir = normalize( envRotation3x3 * direction + sampleDir );\n\t\t\t\t\treturn environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t\t${ RenderGLSL.render_structs }\n\t\t\t\t${ RenderGLSL.camera_util_functions }\n\t\t\t\t${ RenderGLSL.trace_scene_function }\n\t\t\t\t${ RenderGLSL.attenuate_hit_function }\n\t\t\t\t${ RenderGLSL.direct_light_contribution_function }\n\t\t\t\t${ RenderGLSL.get_surface_record_function }\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// init\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) | uint( gl_FragCoord.y );\n\t\t\t\t\tsobolPathIndex = uint( seed );\n\n\t\t\t\t\t// get camera ray\n\t\t\t\t\tRay ray = getCameraRay();\n\n\t\t\t\t\t// inverse environment rotation\n\t\t\t\t\tenvRotation3x3 = mat3( environmentRotation );\n\t\t\t\t\tinvEnvRotation3x3 = inverse( envRotation3x3 );\n\t\t\t\t\tlightsDenom =\n\t\t\t\t\t\t( environmentIntensity == 0.0 || envMapInfo.totalSum == 0.0 ) && lights.count != 0u ?\n\t\t\t\t\t\t\tfloat( lights.count ) :\n\t\t\t\t\t\t\tfloat( lights.count + 1u );\n\n\t\t\t\t\t// final color\n\t\t\t\t\tgl_FragColor = vec4( 0, 0, 0, 1 );\n\n\t\t\t\t\t// surface results\n\t\t\t\t\tSurfaceHit surfaceHit;\n\t\t\t\t\tScatterRecord scatterRec;\n\n\t\t\t\t\t// path tracing state\n\t\t\t\t\tRenderState state = initRenderState();\n\t\t\t\t\tstate.transmissiveTraversals = transmissiveBounces;\n\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\tstate.fogMaterial.fogVolume = bvhIntersectFogVolumeHit(\n\t\t\t\t\t\tray.origin, - ray.direction,\n\t\t\t\t\t\tmaterialIndexAttribute, materials,\n\t\t\t\t\t\tstate.fogMaterial\n\t\t\t\t\t);\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfor ( int i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tsobolBounceIndex ++;\n\n\t\t\t\t\t\tstate.depth ++;\n\t\t\t\t\t\tstate.traversals = bounces - i;\n\t\t\t\t\t\tstate.firstRay = i == 0 && state.transmissiveTraversals == transmissiveBounces;\n\n\t\t\t\t\t\tint hitType = traceScene( ray, state.fogMaterial, surfaceHit );\n\n\t\t\t\t\t\t// check if we intersect any lights and accumulate the light contribution\n\t\t\t\t\t\t// TODO: we can add support for light surface rendering in the else condition if we\n\t\t\t\t\t\t// add the ability to toggle visibility of the the light\n\t\t\t\t\t\tif ( ! state.firstRay && ! state.transmissiveRay ) {\n\n\t\t\t\t\t\t\tLightRecord lightRec;\n\t\t\t\t\t\t\tfloat lightDist = hitType == NO_HIT ? INFINITY : surfaceHit.dist;\n\t\t\t\t\t\t\tfor ( uint i = 0u; i < lights.count; i ++ ) {\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tintersectLightAtIndex( lights.tex, ray.origin, ray.direction, i, lightRec ) &&\n\t\t\t\t\t\t\t\t\tlightRec.dist < lightDist\n\t\t\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t\t// weight the contribution\n\t\t\t\t\t\t\t\t\t// NOTE: Only area lights are supported for forward sampling and can be hit\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, lightRec.pdf / lightsDenom );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\n\n\t\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hitType == NO_HIT ) {\n\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( ray.direction, rand2( 2 ) ) * state.throughputColor;\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\n\t\t\t\t\t\t\t\tvec3 envColor;\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirect( envRotation3x3 * ray.direction, envColor );\n\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\n\n\t\t\t\t\t\t\t\t// and weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, envPdf );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * state.throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\n\t\t\t\t\t\t\t\t\tsampleEquirectColor( envMapInfo.map, envRotation3x3 * ray.direction ) *\n\t\t\t\t\t\t\t\t\tstate.throughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\t\t\t\tmaterial = state.fogMaterial;\n\t\t\t\t\t\t\tstate.accumulatedRoughness += 0.2;\n\n\t\t\t\t\t\t} else if ( material.fogVolume ) {\n\n\t\t\t\t\t\t\tstate.fogMaterial = material;\n\t\t\t\t\t\t\tstate.fogMaterial.fogVolume = surfaceHit.side == 1.0;\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// early out if this is a matte material\n\t\t\t\t\t\tif ( material.matte && state.firstRay ) {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\n\t\t\t\t\t\t// then skip it\n\t\t\t\t\t\tif ( ! material.castShadow && state.isShadowRay ) {\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSurfaceRecord surf;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgetSurfaceRecord(\n\t\t\t\t\t\t\t\tmaterial, surfaceHit, attributesArray, state.accumulatedRoughness,\n\t\t\t\t\t\t\t\tsurf\n\t\t\t\t\t\t\t) == SKIP_SURFACE\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscatterRec = bsdfSample( - ray.direction, surf );\n\t\t\t\t\t\tstate.isShadowRay = scatterRec.specularPdf < rand( 4 );\n\n\t\t\t\t\t\tbool isBelowSurface = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal ) < 0.0;\n\t\t\t\t\t\tvec3 hitPoint = stepRayOrigin( ray.origin, ray.direction, isBelowSurface ? - surf.faceNormal : surf.faceNormal, surfaceHit.dist );\n\n\t\t\t\t\t\t// next event estimation\n\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\tgl_FragColor.rgb += directLightContribution( - ray.direction, surf, state, hitPoint );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\t// TODO: handle transmissive surfaces\n\t\t\t\t\t\tif ( ! surf.volumeParticle && ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( - ray.direction + scatterRec.direction );\n\t\t\t\t\t\t\tstate.accumulatedRoughness += max(\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.normal ) ) ),\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.clearcoatNormal ) ) )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tstate.transmissiveRay = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate emissive color\n\t\t\t\t\t\tgl_FragColor.rgb += ( surf.emission * state.throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( scatterRec.pdf <= 0.0 || ! isDirectionValid( scatterRec.direction, surf.normal, surf.faceNormal ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we're bouncing around the inside a transmissive material then decrement\n\t\t\t\t\t\t// perform this separate from a bounce\n\t\t\t\t\t\tbool isTransmissiveRay = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal * surfaceHit.side ) < 0.0;\n\t\t\t\t\t\tif ( ( isTransmissiveRay || isBelowSurface ) && state.transmissiveTraversals > 0 ) {\n\n\t\t\t\t\t\t\tstate.transmissiveTraversals --;\n\t\t\t\t\t\t\ti --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// handle throughput color transformation\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\n\t\t\t\t\t\tif ( ! surf.frontFace ) {\n\n\t\t\t\t\t\t\tstate.throughputColor *= transmissionAttenuation( surfaceHit.dist, surf.attenuationColor, surf.attenuationDistance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#if FEATURE_RUSSIAN_ROULETTE\n\n\t\t\t\t\t\t// russian roulette path termination\n\t\t\t\t\t\t// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf\n\t\t\t\t\t\tuint minBounces = 3u;\n\t\t\t\t\t\tfloat depthProb = float( state.depth < minBounces );\n\n\t\t\t\t\t\tfloat rrProb = luminance( state.throughputColor * scatterRec.color / scatterRec.pdf );\n\t\t\t\t\t\trrProb /= luminance( state.throughputColor );\n\t\t\t\t\t\trrProb = sqrt( rrProb );\n\t\t\t\t\t\trrProb = max( rrProb, depthProb );\n\t\t\t\t\t\trrProb = min( rrProb, 1.0 );\n\t\t\t\t\t\tif ( rand( 8 ) > rrProb ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// perform sample clamping here to avoid bright pixels\n\t\t\t\t\t\tstate.throughputColor *= min( 1.0 / rrProb, 20.0 );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// adjust the throughput and discard and exit if we find discard the sample if there are any NaNs\n\t\t\t\t\t\tstate.throughputColor *= scatterRec.color / scatterRec.pdf;\n\t\t\t\t\t\tif ( any( isnan( state.throughputColor ) ) || any( isinf( state.throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// prepare for next ray\n\t\t\t\t\t\tray.direction = scatterRec.direction;\n\t\t\t\t\t\tray.origin = hitPoint;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t\t#if DEBUG_MODE == 1\n\n\t\t\t\t\t// output the number of rays checked in the path and number of\n\t\t\t\t\t// transmissive rays encountered.\n\t\t\t\t\tgl_FragColor.rgb = vec3(\n\t\t\t\t\t\tfloat( state.depth ),\n\t\t\t\t\t\ttransmissiveBounces - state.transmissiveTraversals,\n\t\t\t\t\t\t0.0\n\t\t\t\t\t);\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n", "import { RGBAFormat, FloatType, Color, Vector2, WebGLRenderTarget, NoBlending, NormalBlending, Vector4, NearestFilter } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { BlendMaterial } from '../materials/fullscreen/BlendMaterial.js';\nimport { SobolNumberMapGenerator } from '../utils/SobolNumberMapGenerator.js';\nimport { PhysicalPathTracingMaterial } from '../materials/pathtracing/PhysicalPathTracingMaterial.js';\n\nfunction* renderTask() {\n\n\tconst {\n\t\t_renderer,\n\t\t_fsQuad,\n\t\t_blendQuad,\n\t\t_primaryTarget,\n\t\t_blendTargets,\n\t\t_sobolTarget,\n\t\t_subframe,\n\t\talpha,\n\t\tmaterial,\n\t} = this;\n\tconst _ogScissor = new Vector4();\n\tconst _ogViewport = new Vector4();\n\n\tconst blendMaterial = _blendQuad.material;\n\tlet [ blendTarget1, blendTarget2 ] = _blendTargets;\n\n\twhile ( true ) {\n\n\t\tif ( alpha ) {\n\n\t\t\tblendMaterial.opacity = this._opacityFactor / ( this.samples + 1 );\n\t\t\tmaterial.blending = NoBlending;\n\t\t\tmaterial.opacity = 1;\n\n\t\t} else {\n\n\t\t\tmaterial.opacity = this._opacityFactor / ( this.samples + 1 );\n\t\t\tmaterial.blending = NormalBlending;\n\n\t\t}\n\n\t\tconst [ subX, subY, subW, subH ] = _subframe;\n\n\t\tconst w = _primaryTarget.width;\n\t\tconst h = _primaryTarget.height;\n\t\tmaterial.resolution.set( w * subW, h * subH );\n\t\tmaterial.sobolTexture = _sobolTarget.texture;\n\t\tmaterial.stratifiedTexture.init( 20, material.bounces + material.transmissiveBounces + 5 );\n\t\tmaterial.stratifiedTexture.next();\n\t\tmaterial.seed ++;\n\n\t\tconst tilesX = this.tiles.x || 1;\n\t\tconst tilesY = this.tiles.y || 1;\n\t\tconst totalTiles = tilesX * tilesY;\n\n\t\tconst pxSubW = Math.ceil( w * subW );\n\t\tconst pxSubH = Math.ceil( h * subH );\n\t\tconst pxSubX = Math.floor( subX * w );\n\t\tconst pxSubY = Math.floor( subY * h );\n\n\t\tconst pxTileW = Math.ceil( pxSubW / tilesX );\n\t\tconst pxTileH = Math.ceil( pxSubH / tilesY );\n\n\t\tfor ( let y = 0; y < tilesY; y ++ ) {\n\n\t\t\tfor ( let x = 0; x < tilesX; x ++ ) {\n\n\t\t\t\t// store og state\n\t\t\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\t\t\tconst ogAutoClear = _renderer.autoClear;\n\t\t\t\tconst ogScissorTest = _renderer.getScissorTest();\n\t\t\t\t_renderer.getScissor( _ogScissor );\n\t\t\t\t_renderer.getViewport( _ogViewport );\n\n\t\t\t\tlet tx = x;\n\t\t\t\tlet ty = y;\n\t\t\t\tif ( ! this.stableTiles ) {\n\n\t\t\t\t\tconst tileIndex = ( this._currentTile ) % ( tilesX * tilesY );\n\t\t\t\t\ttx = tileIndex % tilesX;\n\t\t\t\t\tty = ~ ~ ( tileIndex / tilesX );\n\n\t\t\t\t\tthis._currentTile = tileIndex + 1;\n\n\t\t\t\t}\n\n\t\t\t\t// set the scissor and the viewport on the render target\n\t\t\t\t// note that when using the webgl renderer set viewport the device pixel ratio\n\t\t\t\t// is multiplied into the field causing some pixels to not be rendered\n\t\t\t\tconst reverseTy = tilesY - ty - 1;\n\t\t\t\t_primaryTarget.scissor.set(\n\t\t\t\t\tpxSubX + tx * pxTileW,\n\t\t\t\t\tpxSubY + reverseTy * pxTileH,\n\t\t\t\t\tMath.min( pxTileW, pxSubW - tx * pxTileW ),\n\t\t\t\t\tMath.min( pxTileH, pxSubH - reverseTy * pxTileH ),\n\t\t\t\t);\n\n\t\t\t\t_primaryTarget.viewport.set(\n\t\t\t\t\tpxSubX,\n\t\t\t\t\tpxSubY,\n\t\t\t\t\tpxSubW,\n\t\t\t\t\tpxSubH,\n\t\t\t\t);\n\n\t\t\t\t// three.js renderer takes values relative to the current pixel ratio\n\t\t\t\t_renderer.setRenderTarget( _primaryTarget );\n\t\t\t\t_renderer.setScissorTest( true );\n\n\t\t\t\t_renderer.autoClear = false;\n\t\t\t\t_fsQuad.render( _renderer );\n\n\t\t\t\t// reset original renderer state\n\t\t\t\t_renderer.setViewport( _ogViewport );\n\t\t\t\t_renderer.setScissor( _ogScissor );\n\t\t\t\t_renderer.setScissorTest( ogScissorTest );\n\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\t\t\t\t_renderer.autoClear = ogAutoClear;\n\n\t\t\t\t// swap and blend alpha targets\n\t\t\t\tif ( alpha ) {\n\n\t\t\t\t\tblendMaterial.target1 = blendTarget1.texture;\n\t\t\t\t\tblendMaterial.target2 = _primaryTarget.texture;\n\n\t\t\t\t\t_renderer.setRenderTarget( blendTarget2 );\n\t\t\t\t\t_blendQuad.render( _renderer );\n\t\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tthis.samples += ( 1 / totalTiles );\n\n\t\t\t\t// round the samples value if we've finished the tiles\n\t\t\t\tif ( x === tilesX - 1 && y === tilesY - 1 ) {\n\n\t\t\t\t\tthis.samples = Math.round( this.samples );\n\n\t\t\t\t}\n\n\t\t\t\tyield;\n\n\t\t\t}\n\n\t\t}\n\n\t\t[ blendTarget1, blendTarget2 ] = [ blendTarget2, blendTarget1 ];\n\n\t}\n\n}\n\nconst ogClearColor = new Color();\nexport class PathTracingRenderer {\n\n\tget material() {\n\n\t\treturn this._fsQuad.material;\n\n\t}\n\n\tset material( v ) {\n\n\t\tthis._fsQuad.material.removeEventListener( 'recompilation', this._compileFunction );\n\t\tv.addEventListener( 'recompilation', this._compileFunction );\n\n\t\tthis._fsQuad.material = v;\n\n\t}\n\n\tget target() {\n\n\t\treturn this._alpha ? this._blendTargets[ 1 ] : this._primaryTarget;\n\n\t}\n\n\tset alpha( v ) {\n\n\t\tif ( this._alpha === v ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( ! v ) {\n\n\t\t\tthis._blendTargets[ 0 ].dispose();\n\t\t\tthis._blendTargets[ 1 ].dispose();\n\n\t\t}\n\n\t\tthis._alpha = v;\n\t\tthis.reset();\n\n\t}\n\n\tget alpha() {\n\n\t\treturn this._alpha;\n\n\t}\n\n\tget isCompiling() {\n\n\t\treturn Boolean( this._compilePromise );\n\n\t}\n\n\tconstructor( renderer ) {\n\n\t\tthis.camera = null;\n\t\tthis.tiles = new Vector2( 3, 3 );\n\n\t\tthis.stableNoise = false;\n\t\tthis.stableTiles = true;\n\n\t\tthis.samples = 0;\n\t\tthis._subframe = new Vector4( 0, 0, 1, 1 );\n\t\tthis._opacityFactor = 1.0;\n\t\tthis._renderer = renderer;\n\t\tthis._alpha = false;\n\t\tthis._fsQuad = new FullScreenQuad( new PhysicalPathTracingMaterial() );\n\t\tthis._blendQuad = new FullScreenQuad( new BlendMaterial() );\n\t\tthis._task = null;\n\t\tthis._currentTile = 0;\n\t\tthis._compilePromise = null;\n\n\t\tthis._sobolTarget = new SobolNumberMapGenerator().generate( renderer );\n\n\t\tthis._primaryTarget = new WebGLRenderTarget( 1, 1, {\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: FloatType,\n\t\t\tmagFilter: NearestFilter,\n\t\t\tminFilter: NearestFilter,\n\t\t} );\n\t\tthis._blendTargets = [\n\t\t\tnew WebGLRenderTarget( 1, 1, {\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: FloatType,\n\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\tminFilter: NearestFilter,\n\t\t\t} ),\n\t\t\tnew WebGLRenderTarget( 1, 1, {\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: FloatType,\n\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\tminFilter: NearestFilter,\n\t\t\t} ),\n\t\t];\n\n\t\t// function for listening to for triggered compilation so we can wait for compilation to finish\n\t\t// before starting to render\n\t\tthis._compileFunction = () => {\n\n\t\t\tconst promise = this.compileMaterial( this._fsQuad._mesh );\n\t\t\tpromise.then( () => {\n\n\t\t\t\tif ( this._compilePromise === promise ) {\n\n\t\t\t\t\tthis._compilePromise = null;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tthis._compilePromise = promise;\n\n\t\t};\n\n\t\tthis.material.addEventListener( 'recompilation', this._compileFunction );\n\n\t}\n\n\tcompileMaterial() {\n\n\t\treturn this._renderer.compileAsync( this._fsQuad._mesh );\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tconst { material } = this;\n\t\tmaterial.cameraWorldMatrix.copy( camera.matrixWorld );\n\t\tmaterial.invProjectionMatrix.copy( camera.projectionMatrixInverse );\n\t\tmaterial.physicalCamera.updateFrom( camera );\n\n\t\t// Perspective camera (default)\n\t\tlet cameraType = 0;\n\n\t\t// An orthographic projection matrix will always have the bottom right element == 1\n\t\t// And a perspective projection matrix will always have the bottom right element == 0\n\t\tif ( camera.projectionMatrix.elements[ 15 ] > 0 ) {\n\n\t\t\t// Orthographic\n\t\t\tcameraType = 1;\n\n\t\t}\n\n\t\tif ( camera.isEquirectCamera ) {\n\n\t\t\t// Equirectangular\n\t\t\tcameraType = 2;\n\n\t\t}\n\n\t\tmaterial.setDefine( 'CAMERA_TYPE', cameraType );\n\n\t\tthis.camera = camera;\n\n\t}\n\n\tsetSize( w, h ) {\n\n\t\tw = Math.ceil( w );\n\t\th = Math.ceil( h );\n\n\t\tif ( this._primaryTarget.width === w && this._primaryTarget.height === h ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._primaryTarget.setSize( w, h );\n\t\tthis._blendTargets[ 0 ].setSize( w, h );\n\t\tthis._blendTargets[ 1 ].setSize( w, h );\n\t\tthis.reset();\n\n\t}\n\n\tgetSize( target ) {\n\n\t\ttarget.x = this._primaryTarget.width;\n\t\ttarget.y = this._primaryTarget.height;\n\n\t}\n\n\tdispose() {\n\n\t\tthis._primaryTarget.dispose();\n\t\tthis._blendTargets[ 0 ].dispose();\n\t\tthis._blendTargets[ 1 ].dispose();\n\t\tthis._sobolTarget.dispose();\n\n\t\tthis._fsQuad.dispose();\n\t\tthis._blendQuad.dispose();\n\t\tthis._task = null;\n\n\t}\n\n\treset() {\n\n\t\tconst { _renderer, _primaryTarget, _blendTargets } = this;\n\t\tconst ogRenderTarget = _renderer.getRenderTarget();\n\t\tconst ogClearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.getClearColor( ogClearColor );\n\n\t\t_renderer.setRenderTarget( _primaryTarget );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setRenderTarget( _blendTargets[ 0 ] );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setRenderTarget( _blendTargets[ 1 ] );\n\t\t_renderer.setClearColor( 0, 0 );\n\t\t_renderer.clearColor();\n\n\t\t_renderer.setClearColor( ogClearColor, ogClearAlpha );\n\t\t_renderer.setRenderTarget( ogRenderTarget );\n\n\t\tthis.samples = 0;\n\t\tthis._task = null;\n\n\t\tthis.material.stratifiedTexture.stableNoise = this.stableNoise;\n\t\tif ( this.stableNoise ) {\n\n\t\t\tthis.material.seed = 0;\n\t\t\tthis.material.stratifiedTexture.reset();\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\t// ensure we've updated our defines before rendering so we can ensure we\n\t\t// can wait for compilation to finish\n\t\tthis.material.onBeforeRender();\n\t\tif ( this.isCompiling ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( ! this._task ) {\n\n\t\t\tthis._task = renderTask.call( this );\n\n\t\t}\n\n\t\tthis._task.next();\n\n\t}\n\n}\n", "import {\n\tClampToEdgeWrapping,\n\tColor,\n\tDataTexture,\n\tEquirectangularReflectionMapping,\n\tLinearFilter,\n\tRepeatWrapping,\n\tRGBAFormat,\n\tSpherical,\n\tVector2,\n\tFloatType\n} from 'three';\n\nconst _uv = new Vector2();\nconst _coord = new Vector2();\nconst _polar = new Spherical();\nconst _color = new Color();\nexport class ProceduralEquirectTexture extends DataTexture {\n\n\tconstructor( width = 512, height = 512 ) {\n\n\t\tsuper(\n\t\t\tnew Float32Array( width * height * 4 ),\n\t\t\twidth, height, RGBAFormat, FloatType, EquirectangularReflectionMapping,\n\t\t\tRepeatWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter,\n\t\t);\n\n\t\tthis.generationCallback = null;\n\n\t}\n\n\tupdate() {\n\n\t\tthis.dispose();\n\t\tthis.needsUpdate = true;\n\n\t\tconst { data, width, height } = this.image;\n\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\t_coord.set( width, height );\n\n\t\t\t\t_uv.set( x / width, y / height );\n\t\t\t\t_uv.x -= 0.5;\n\t\t\t\t_uv.y = 1.0 - _uv.y;\n\n\t\t\t\t_polar.theta = _uv.x * 2.0 * Math.PI;\n\t\t\t\t_polar.phi = _uv.y * Math.PI;\n\t\t\t\t_polar.radius = 1.0;\n\n\t\t\t\tthis.generationCallback( _polar, _uv, _coord, _color );\n\n\t\t\t\tconst i = y * width + x;\n\t\t\t\tconst i4 = 4 * i;\n\t\t\t\tdata[ i4 + 0 ] = ( _color.r );\n\t\t\t\tdata[ i4 + 1 ] = ( _color.g );\n\t\t\t\tdata[ i4 + 2 ] = ( _color.b );\n\t\t\t\tdata[ i4 + 3 ] = ( 1.0 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\t\tthis.generationCallback = other.generationCallback;\n\t\treturn this;\n\n\t}\n\n}\n", "import { Color, Vector3 } from 'three';\nimport { ProceduralEquirectTexture } from './ProceduralEquirectTexture.js';\n\nconst _direction = new Vector3();\nexport class GradientEquirectTexture extends ProceduralEquirectTexture {\n\n\tconstructor( resolution = 512 ) {\n\n\t\tsuper( resolution, resolution );\n\n\t\tthis.topColor = new Color().set( 0xffffff );\n\t\tthis.bottomColor = new Color().set( 0x000000 );\n\t\tthis.exponent = 2;\n\t\tthis.generationCallback = ( polar, uv, coord, color ) => {\n\n\t\t\t_direction.setFromSpherical( polar );\n\n\t\t\tconst t = _direction.y * 0.5 + 0.5;\n\t\t\tcolor.lerpColors( this.bottomColor, this.topColor, t ** this.exponent );\n\n\t\t};\n\n\t}\n\n\tcopy( other ) {\n\n\t\tsuper.copy( other );\n\n\t\tthis.topColor.copy( other.topColor );\n\t\tthis.bottomColor.copy( other.bottomColor );\n\t\treturn this;\n\n\t}\n\n}\n", "import { ShaderMaterial } from 'three';\n\n// Material that tone maps a texture before performing interpolation to prevent\n// unexpected high values during texture stretching interpolation.\n// Emulates browser image stretching\nexport class ClampedInterpolationMaterial extends ShaderMaterial {\n\n\tget map() {\n\n\t\treturn this.uniforms.map.value;\n\n\t}\n\n\tset map( v ) {\n\n\t\tthis.uniforms.map.value = v;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tif ( this.uniforms ) {\n\n\t\t\tthis.uniforms.opacity.value = v;\n\n\t\t}\n\n\t}\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\t\t\tuniforms: {\n\n\t\t\t\tmap: { value: null },\n\t\t\t\topacity: { value: 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform float opacity;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvec4 clampedTexelFatch( sampler2D map, ivec2 px, int lod ) {\n\n\t\t\t\t\tvec4 res = texelFetch( map, ivec2( px.x, px.y ), 0 );\n\n\t\t\t\t\t#if defined( TONE_MAPPING )\n\n\t\t\t\t\tres.xyz = toneMapping( res.xyz );\n\n\t\t\t\t\t#endif\n\n\t\t\t  \t\treturn linearToOutputTexel( res );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec2 size = vec2( textureSize( map, 0 ) );\n\t\t\t\t\tvec2 pxUv = vUv * size;\n\t\t\t\t\tvec2 pxCurr = floor( pxUv );\n\t\t\t\t\tvec2 pxFrac = fract( pxUv ) - 0.5;\n\t\t\t\t\tvec2 pxOffset;\n\t\t\t\t\tpxOffset.x = pxFrac.x > 0.0 ? 1.0 : - 1.0;\n\t\t\t\t\tpxOffset.y = pxFrac.y > 0.0 ? 1.0 : - 1.0;\n\n\t\t\t\t\tvec2 pxNext = clamp( pxOffset + pxCurr, vec2( 0.0 ), size - 1.0 );\n\t\t\t\t\tvec2 alpha = abs( pxFrac );\n\n\t\t\t\t\tvec4 p1 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxCurr.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tvec4 p2 = mix(\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxNext.y ), 0 ),\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxNext.y ), 0 ),\n\t\t\t\t\t\talpha.x\n\t\t\t\t\t);\n\n\t\t\t\t\tgl_FragColor = mix( p1, p2, alpha.y );\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n", "import {\n\tDataTexture,\n\tDataUtils,\n\tEquirectangularReflectionMapping,\n\tFloatType,\n\tHalfFloatType,\n\tLinearFilter,\n\tLinearMipMapLinearFilter,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tShaderMaterial,\n\tWebGLRenderTarget,\n} from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport * as CommonGLSL from '../shader/common/index.js';\n\nclass CubeToEquirectMaterial extends ShaderMaterial {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tflipEnvMap: { value: - 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\t\tuniform samplerCube envMap;\n\t\t\t\tuniform float flipEnvMap;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${ CommonGLSL.util_functions }\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\trayDirection.x *= flipEnvMap;\n\t\t\t\t\tgl_FragColor = textureCube( envMap, rayDirection );\n\n\t\t\t\t}`\n\t\t} );\n\n\t\tthis.depthWrite = false;\n\t\tthis.depthTest = false;\n\n\t}\n\n}\n\nexport class CubeToEquirectGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._quad = new FullScreenQuad( new CubeToEquirectMaterial() );\n\n\t}\n\n\tgenerate( source, width = null, height = null ) {\n\n\t\tif ( ! source.isCubeTexture ) {\n\n\t\t\tthrow new Error( 'CubeToEquirectMaterial: Source can only be cube textures.' );\n\n\t\t}\n\n\t\tconst image = source.images[ 0 ];\n\t\tconst renderer = this._renderer;\n\t\tconst quad = this._quad;\n\n\t\t// determine the dimensions if not provided\n\t\tif ( width === null ) {\n\n\t\t\twidth = 4 * image.height;\n\n\t\t}\n\n\t\tif ( height === null ) {\n\n\t\t\theight = 2 * image.height;\n\n\t\t}\n\n\t\tconst target = new WebGLRenderTarget( width, height, {\n\t\t\ttype: FloatType,\n\t\t\tcolorSpace: image.colorSpace,\n\t\t} );\n\n\t\t// prep the cube map data\n\t\tconst imageHeight = image.height;\n\t\tconst maxMip = Math.log2( imageHeight ) - 2;\n\t\tconst texelHeight = 1.0 / imageHeight;\n\t\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\t\tquad.material.defines.CUBEUV_MAX_MIP = `${ maxMip }.0`;\n\t\tquad.material.defines.CUBEUV_TEXEL_WIDTH = texelWidth;\n\t\tquad.material.defines.CUBEUV_TEXEL_HEIGHT = texelHeight;\n\t\tquad.material.uniforms.envMap.value = source;\n\t\tquad.material.uniforms.flipEnvMap.value = source.isRenderTargetTexture ? 1 : - 1;\n\t\tquad.material.needsUpdate = true;\n\n\t\t// save state and render the contents\n\t\tconst currentTarget = renderer.getRenderTarget();\n\t\tconst currentAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = true;\n\t\trenderer.setRenderTarget( target );\n\t\tquad.render( renderer );\n\t\trenderer.setRenderTarget( currentTarget );\n\t\trenderer.autoClear = currentAutoClear;\n\n\t\t// read the data back\n\t\tconst buffer = new Uint16Array( width * height * 4 );\n\t\tconst readBuffer = new Float32Array( width * height * 4 );\n\t\trenderer.readRenderTargetPixels( target, 0, 0, width, height, readBuffer );\n\t\ttarget.dispose();\n\n\t\tfor ( let i = 0, l = readBuffer.length; i < l; i ++ ) {\n\n\t\t\tbuffer[ i ] = DataUtils.toHalfFloat( readBuffer[ i ] );\n\n\t\t}\n\n\t\t// produce the data texture\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, HalfFloatType );\n\t\tresult.minFilter = LinearMipMapLinearFilter;\n\t\tresult.magFilter = LinearFilter;\n\t\tresult.wrapS = RepeatWrapping;\n\t\tresult.wrapT = RepeatWrapping;\n\t\tresult.mapping = EquirectangularReflectionMapping;\n\t\tresult.needsUpdate = true;\n\n\t\treturn result;\n\n\t}\n\n\tdispose() {\n\n\t\tthis._quad.dispose();\n\n\t}\n\n}\n", "import { PerspectiveCamera, Scene, Vector2, Clock, NormalBlending, NoBlending, AdditiveBlending } from 'three';\nimport { PathTracingSceneGenerator } from './PathTracingSceneGenerator.js';\nimport { PathTracingRenderer } from './PathTracingRenderer.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { GradientEquirectTexture } from '../textures/GradientEquirectTexture.js';\nimport { getIesTextures, getLights, getTextures } from './utils/sceneUpdateUtils.js';\nimport { ClampedInterpolationMaterial } from '../materials/fullscreen/ClampedInterpolationMaterial.js';\nimport { CubeToEquirectGenerator } from '../utils/CubeToEquirectGenerator.js';\n\nfunction supportsFloatBlending( renderer ) {\n\n\treturn renderer.extensions.get( 'EXT_float_blend' );\n\n}\n\nconst _resolution = new Vector2();\nexport class WebGLPathTracer {\n\n\tget multipleImportanceSampling() {\n\n\t\treturn Boolean( this._pathTracer.material.defines.FEATURE_MIS );\n\n\t}\n\n\tset multipleImportanceSampling( v ) {\n\n\t\tthis._pathTracer.material.setDefine( 'FEATURE_MIS', v ? 1 : 0 );\n\n\t}\n\n\tget transmissiveBounces() {\n\n\t\treturn this._pathTracer.material.transmissiveBounces;\n\n\t}\n\n\tset transmissiveBounces( v ) {\n\n\t\tthis._pathTracer.material.transmissiveBounces = v;\n\n\t}\n\n\tget bounces() {\n\n\t\treturn this._pathTracer.material.bounces;\n\n\t}\n\n\tset bounces( v ) {\n\n\t\tthis._pathTracer.material.bounces = v;\n\n\t}\n\n\tget filterGlossyFactor() {\n\n\t\treturn this._pathTracer.material.filterGlossyFactor;\n\n\t}\n\n\tset filterGlossyFactor( v ) {\n\n\t\tthis._pathTracer.material.filterGlossyFactor = v;\n\n\t}\n\n\tget samples() {\n\n\t\treturn this._pathTracer.samples;\n\n\t}\n\n\tget target() {\n\n\t\treturn this._pathTracer.target;\n\n\t}\n\n\tget tiles() {\n\n\t\treturn this._pathTracer.tiles;\n\n\t}\n\n\tget stableNoise() {\n\n\t\treturn this._pathTracer.stableNoise;\n\n\t}\n\n\tset stableNoise( v ) {\n\n\t\tthis._pathTracer.stableNoise = v;\n\n\t}\n\n\tget isCompiling() {\n\n\t\treturn Boolean( this._pathTracer.isCompiling );\n\n\t}\n\n\tconstructor( renderer ) {\n\n\t\t// members\n\t\tthis._renderer = renderer;\n\t\tthis._generator = new PathTracingSceneGenerator();\n\t\tthis._pathTracer = new PathTracingRenderer( renderer );\n\t\tthis._queueReset = false;\n\t\tthis._clock = new Clock();\n\t\tthis._compilePromise = null;\n\n\t\tthis._lowResPathTracer = new PathTracingRenderer( renderer );\n\t\tthis._lowResPathTracer.tiles.set( 1, 1 );\n\t\tthis._quad = new FullScreenQuad( new ClampedInterpolationMaterial( {\n\t\t\tmap: null,\n\t\t\ttransparent: true,\n\t\t\tblending: NoBlending,\n\n\t\t\tpremultipliedAlpha: renderer.getContextAttributes().premultipliedAlpha,\n\t\t} ) );\n\t\tthis._materials = null;\n\n\t\tthis._previousEnvironment = null;\n\t\tthis._previousBackground = null;\n\t\tthis._internalBackground = null;\n\n\t\t// options\n\t\tthis.renderDelay = 100;\n\t\tthis.minSamples = 5;\n\t\tthis.fadeDuration = 500;\n\t\tthis.enablePathTracing = true;\n\t\tthis.pausePathTracing = false;\n\t\tthis.dynamicLowRes = false;\n\t\tthis.lowResScale = 0.25;\n\t\tthis.renderScale = 1;\n\t\tthis.synchronizeRenderSize = true;\n\t\tthis.rasterizeScene = true;\n\t\tthis.renderToCanvas = true;\n\t\tthis.textureSize = new Vector2( 1024, 1024 );\n\t\tthis.rasterizeSceneCallback = ( scene, camera ) => {\n\n\t\t\tthis._renderer.render( scene, camera );\n\n\t\t};\n\n\t\tthis.renderToCanvasCallback = ( target, renderer, quad ) => {\n\n\t\t\tconst currentAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\t\t\tquad.render( renderer );\n\t\t\trenderer.autoClear = currentAutoClear;\n\n\t\t};\n\n\t\t// initialize the scene so it doesn't fail\n\t\tthis.setScene( new Scene(), new PerspectiveCamera() );\n\n\t}\n\n\tsetBVHWorker( worker ) {\n\n\t\tthis._generator.setBVHWorker( worker );\n\n\t}\n\n\tsetScene( scene, camera, options = {} ) {\n\n\t\tscene.updateMatrixWorld( true );\n\t\tcamera.updateMatrixWorld();\n\n\t\tconst generator = this._generator;\n\t\tgenerator.setObjects( scene );\n\n\t\tif ( this._buildAsync ) {\n\n\t\t\treturn generator.generateAsync( options.onProgress ).then( result => {\n\n\t\t\t\treturn this._updateFromResults( scene, camera, result );\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tconst result = generator.generate();\n\t\t\treturn this._updateFromResults( scene, camera, result );\n\n\t\t}\n\n\t}\n\n\tsetSceneAsync( ...args ) {\n\n\t\tthis._buildAsync = true;\n\t\tconst result = this.setScene( ...args );\n\t\tthis._buildAsync = false;\n\n\t\treturn result;\n\n\t}\n\n\tsetCamera( camera ) {\n\n\t\tthis.camera = camera;\n\t\tthis.updateCamera();\n\n\t}\n\n\tupdateCamera() {\n\n\t\tconst camera = this.camera;\n\t\tcamera.updateMatrixWorld();\n\n\t\tthis._pathTracer.setCamera( camera );\n\t\tthis._lowResPathTracer.setCamera( camera );\n\t\tthis.reset();\n\n\t}\n\n\tupdateMaterials() {\n\n\t\tconst material = this._pathTracer.material;\n\t\tconst renderer = this._renderer;\n\t\tconst materials = this._materials;\n\t\tconst textureSize = this.textureSize;\n\n\t\t// reduce texture sources here - we don't want to do this in the\n\t\t// textures array because we need to pass the textures array into the\n\t\t// material target\n\t\tconst textures = getTextures( materials );\n\t\tmaterial.textures.setTextures( renderer, textures, textureSize.x, textureSize.y );\n\t\tmaterial.materials.updateFrom( materials, textures );\n\t\tthis.reset();\n\n\t}\n\n\tupdateLights() {\n\n\t\tconst scene = this.scene;\n\t\tconst renderer = this._renderer;\n\t\tconst material = this._pathTracer.material;\n\n\t\tconst lights = getLights( scene );\n\t\tconst iesTextures = getIesTextures( lights );\n\t\tmaterial.lights.updateFrom( lights, iesTextures );\n\t\tmaterial.iesProfiles.setTextures( renderer, iesTextures );\n\t\tthis.reset();\n\n\t}\n\n\tupdateEnvironment() {\n\n\t\tconst scene = this.scene;\n\t\tconst material = this._pathTracer.material;\n\n\t\tif ( this._internalBackground ) {\n\n\t\t\tthis._internalBackground.dispose();\n\t\t\tthis._internalBackground = null;\n\n\t\t}\n\n\t\t// update scene background\n\t\tmaterial.backgroundBlur = scene.backgroundBlurriness;\n\t\tmaterial.backgroundIntensity = scene.backgroundIntensity ?? 1;\n\t\tmaterial.backgroundRotation.makeRotationFromEuler( scene.backgroundRotation ).invert();\n\t\tif ( scene.background === null ) {\n\n\t\t\tmaterial.backgroundMap = null;\n\t\t\tmaterial.backgroundAlpha = 0;\n\n\t\t} else if ( scene.background.isColor ) {\n\n\t\t\tthis._colorBackground = this._colorBackground || new GradientEquirectTexture( 16 );\n\n\t\t\tconst colorBackground = this._colorBackground;\n\t\t\tif ( ! colorBackground.topColor.equals( scene.background ) ) {\n\n\t\t\t\t// set the texture color\n\t\t\t\tcolorBackground.topColor.set( scene.background );\n\t\t\t\tcolorBackground.bottomColor.set( scene.background );\n\t\t\t\tcolorBackground.update();\n\n\t\t\t}\n\n\t\t\t// assign to material\n\t\t\tmaterial.backgroundMap = colorBackground;\n\t\t\tmaterial.backgroundAlpha = 1;\n\n\t\t} else if ( scene.background.isCubeTexture ) {\n\n\t\t\tif ( scene.background !== this._previousBackground ) {\n\n\t\t\t\tconst background = new CubeToEquirectGenerator( this._renderer ).generate( scene.background );\n\t\t\t\tthis._internalBackground = background;\n\t\t\t\tmaterial.backgroundMap = background;\n\t\t\t\tmaterial.backgroundAlpha = 1;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmaterial.backgroundMap = scene.background;\n\t\t\tmaterial.backgroundAlpha = 1;\n\n\t\t}\n\n\t\t// update scene environment\n\t\tmaterial.environmentIntensity = scene.environmentIntensity ?? 1;\n\t\tmaterial.environmentRotation.makeRotationFromEuler( scene.environmentRotation ).invert();\n\t\tif ( this._previousEnvironment !== scene.environment ) {\n\n\t\t\tif ( scene.environment !== null ) {\n\n\t\t\t\tif ( scene.environment.isCubeTexture ) {\n\n\t\t\t\t\tconst environment = new CubeToEquirectGenerator( this._renderer ).generate( scene.environment );\n\t\t\t\t\tmaterial.envMapInfo.updateFrom( environment );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// TODO: Consider setting this to the highest supported bit depth by checking for\n\t\t\t\t\t// OES_texture_float_linear or OES_texture_half_float_linear. Requires changes to\n\t\t\t\t\t// the equirect uniform\n\t\t\t\t\tmaterial.envMapInfo.updateFrom( scene.environment );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.environmentIntensity = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._previousEnvironment = scene.environment;\n\t\tthis._previousBackground = scene.background;\n\t\tthis.reset();\n\n\t}\n\n\t_updateFromResults( scene, camera, results ) {\n\n\t\tconst {\n\t\t\tmaterials,\n\t\t\tgeometry,\n\t\t\tbvh,\n\t\t\tbvhChanged,\n\t\t} = results;\n\n\t\tthis._materials = materials;\n\n\t\tconst pathTracer = this._pathTracer;\n\t\tconst material = pathTracer.material;\n\n\t\tif ( bvhChanged ) {\n\n\t\t\tmaterial.bvh.updateFrom( bvh );\n\t\t\tmaterial.attributesArray.updateFrom(\n\t\t\t\tgeometry.attributes.normal,\n\t\t\t\tgeometry.attributes.tangent,\n\t\t\t\tgeometry.attributes.uv,\n\t\t\t\tgeometry.attributes.color,\n\t\t\t);\n\n\t\t\tmaterial.materialIndexAttribute.updateFrom( geometry.attributes.materialIndex );\n\n\t\t}\n\n\t\t// save previously used items\n\t\tthis._previousScene = scene;\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.updateCamera();\n\t\tthis.updateMaterials();\n\t\tthis.updateEnvironment();\n\t\tthis.updateLights();\n\n\t\treturn results;\n\n\t}\n\n\trenderSample() {\n\n\t\tconst lowResPathTracer = this._lowResPathTracer;\n\t\tconst pathTracer = this._pathTracer;\n\t\tconst renderer = this._renderer;\n\t\tconst clock = this._clock;\n\t\tconst quad = this._quad;\n\n\t\tthis._updateScale();\n\n\t\tif ( this._queueReset ) {\n\n\t\t\tpathTracer.reset();\n\t\t\tlowResPathTracer.reset();\n\t\t\tthis._queueReset = false;\n\n\t\t\tquad.material.opacity = 0;\n\t\t\tclock.start();\n\n\t\t}\n\n\t\t// render the path tracing sample after enough time has passed\n\t\tconst delta = clock.getDelta() * 1e3;\n\t\tconst elapsedTime = clock.getElapsedTime() * 1e3;\n\t\tif ( ! this.pausePathTracing && this.enablePathTracing && this.renderDelay <= elapsedTime && ! this.isCompiling ) {\n\n\t\t\tpathTracer.update();\n\n\t\t}\n\n\t\t// when alpha is enabled we use a manual blending system rather than\n\t\t// rendering with a blend function\n\t\tpathTracer.alpha = pathTracer.material.backgroundAlpha !== 1 || ! supportsFloatBlending( renderer );\n\t\tlowResPathTracer.alpha = pathTracer.alpha;\n\n\t\tif ( this.renderToCanvas ) {\n\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst minSamples = this.minSamples;\n\n\t\t\tif ( elapsedTime >= this.renderDelay && this.samples >= this.minSamples ) {\n\n\t\t\t\tif ( this.fadeDuration !== 0 ) {\n\n\t\t\t\t\tquad.material.opacity = Math.min( quad.material.opacity + delta / this.fadeDuration, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tquad.material.opacity = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render the fallback if we haven't rendered enough samples, are paused, or are occluded\n\t\t\tif ( ! this.enablePathTracing || this.samples < minSamples || quad.material.opacity < 1 ) {\n\n\t\t\t\tif ( this.dynamicLowRes && ! this.isCompiling ) {\n\n\t\t\t\t\tif ( lowResPathTracer.samples < 1 ) {\n\n\t\t\t\t\t\tlowResPathTracer.material = pathTracer.material;\n\t\t\t\t\t\tlowResPathTracer.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst currentOpacity = quad.material.opacity;\n\t\t\t\t\tquad.material.opacity = 1 - quad.material.opacity;\n\t\t\t\t\tquad.material.map = lowResPathTracer.target.texture;\n\t\t\t\t\tquad.render( renderer );\n\t\t\t\t\tquad.material.opacity = currentOpacity;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! this.dynamicLowRes && this.rasterizeScene || this.dynamicLowRes && this.isCompiling ) {\n\n\t\t\t\t\tthis.rasterizeSceneCallback( this.scene, this.camera );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif ( this.enablePathTracing && quad.material.opacity > 0 ) {\n\n\t\t\t\tif ( quad.material.opacity < 1 ) {\n\n\t\t\t\t\t// use additive blending when the low res texture is rendered so we can fade the\n\t\t\t\t\t// background out while the full res fades in\n\t\t\t\t\tquad.material.blending = this.dynamicLowRes ? AdditiveBlending : NormalBlending;\n\n\t\t\t\t}\n\n\t\t\t\tquad.material.map = pathTracer.target.texture;\n\t\t\t\tthis.renderToCanvasCallback( pathTracer.target, renderer, quad );\n\t\t\t\tquad.material.blending = NoBlending;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis._queueReset = true;\n\t\tthis._pathTracer.samples = 0;\n\n\t}\n\n\tdispose() {\n\n\t\tthis._renderQuad.dispose();\n\t\tthis._renderQuad.material.dispose();\n\t\tthis._pathTracer.dispose();\n\n\t}\n\n\t_updateScale() {\n\n\t\t// update the path tracer scale if it has changed\n\t\tif ( this.synchronizeRenderSize ) {\n\n\t\t\tthis._renderer.getDrawingBufferSize( _resolution );\n\n\t\t\tconst w = Math.floor( this.renderScale * _resolution.x );\n\t\t\tconst h = Math.floor( this.renderScale * _resolution.y );\n\n\t\t\tthis._pathTracer.getSize( _resolution );\n\t\t\tif ( _resolution.x !== w || _resolution.y !== h ) {\n\n\t\t\t\tconst lowResScale = this.lowResScale;\n\t\t\t\tthis._pathTracer.setSize( w, h );\n\t\t\t\tthis._lowResPathTracer.setSize( Math.floor( w * lowResScale ), Math.floor( h * lowResScale ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n", "import { Camera } from 'three';\n\nexport class EquirectCamera extends Camera {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isEquirectCamera = true;\n\n\t}\n\n}\n", "import { SpotLight } from 'three';\n\nexport class PhysicalSpotLight extends SpotLight {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.iesMap = null;\n\t\tthis.radius = 0;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.iesMap = source.iesMap;\n\t\tthis.radius = source.radius;\n\n\t\treturn this;\n\n\t}\n\n}\n", "import { RectAreaLight } from 'three';\n\nexport class ShapedAreaLight extends RectAreaLight {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\t\tthis.isCircular = false;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.isCircular = source.isCircular;\n\n\t\treturn this;\n\n\t}\n\n}\n", "import { WebGLRenderTarget, RGBAFormat, HalfFloatType, PMREMGenerator, DataTexture, EquirectangularReflectionMapping, FloatType, DataUtils } from 'three';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { MaterialBase } from '../materials/MaterialBase.js';\nimport * as CommonGLSL from '../shader/common/index.js';\n\nclass PMREMCopyMaterial extends MaterialBase {\n\n\tconstructor() {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tenvMap: { value: null },\n\t\t\t\tblur: { value: 0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${ CommonGLSL.util_functions }\n\n\t\t\t\tuniform sampler2D envMap;\n\t\t\t\tuniform float blur;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t} );\n\n\t}\n\n}\n\nexport class BlurredEnvMapGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.pmremGenerator = new PMREMGenerator( renderer );\n\t\tthis.copyQuad = new FullScreenQuad( new PMREMCopyMaterial() );\n\t\tthis.renderTarget = new WebGLRenderTarget( 1, 1, { type: FloatType, format: RGBAFormat } );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.pmremGenerator.dispose();\n\t\tthis.copyQuad.dispose();\n\t\tthis.renderTarget.dispose();\n\n\t}\n\n\tgenerate( texture, blur ) {\n\n\t\tconst { pmremGenerator, renderTarget, copyQuad, renderer } = this;\n\n\t\t// get the pmrem target\n\t\tconst pmremTarget = pmremGenerator.fromEquirectangular( texture );\n\n\t\t// set up the material\n\t\tconst { width, height } = texture.image;\n\t\trenderTarget.setSize( width, height );\n\t\tcopyQuad.material.envMap = pmremTarget.texture;\n\t\tcopyQuad.material.blur = blur;\n\n\t\t// render\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\n\t\tconst prevClear = renderer.autoClear;\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = true;\n\t\tcopyQuad.render( renderer );\n\n\t\trenderer.setRenderTarget( prevRenderTarget );\n\t\trenderer.autoClear = prevClear;\n\n\t\t// read the data back\n\t\tconst buffer = new Uint16Array( width * height * 4 );\n\t\tconst readBuffer = new Float32Array( width * height * 4 );\n\t\trenderer.readRenderTargetPixels( renderTarget, 0, 0, width, height, readBuffer );\n\n\t\tfor ( let i = 0, l = readBuffer.length; i < l; i ++ ) {\n\n\t\t\tbuffer[ i ] = DataUtils.toHalfFloat( readBuffer[ i ] );\n\n\t\t}\n\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, HalfFloatType );\n\t\tresult.minFilter = texture.minFilter;\n\t\tresult.magFilter = texture.magFilter;\n\t\tresult.wrapS = texture.wrapS;\n\t\tresult.wrapT = texture.wrapT;\n\t\tresult.mapping = EquirectangularReflectionMapping;\n\t\tresult.needsUpdate = true;\n\n\t\t// dispose of the now unneeded target\n\t\tpmremTarget.dispose();\n\n\t\treturn result;\n\n\t}\n\n}\n", "import { NoBlending } from 'three';\nimport { MaterialBase } from '../MaterialBase.js';\n\nexport class DenoiseMaterial extends MaterialBase {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tblending: NoBlending,\n\n\t\t\ttransparent: false,\n\n\t\t\tdepthWrite: false,\n\n\t\t\tdepthTest: false,\n\n\t\t\tdefines: {\n\n\t\t\t\tUSE_SLIDER: 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsigma: { value: 5.0 },\n\t\t\t\tthreshold: { value: 0.03 },\n\t\t\t\tkSigma: { value: 1.0 },\n\n\t\t\t\tmap: { value: null },\n\t\t\t\topacity: { value: 1 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t\t\t//  Copyright (c) 2018-2019 Michele Morrone\n\t\t\t\t//  All rights reserved.\n\t\t\t\t//\n\t\t\t\t//  https://michelemorrone.eu - https://BrutPitt.com\n\t\t\t\t//\n\t\t\t\t//  me@michelemorrone.eu - brutpitt@gmail.com\n\t\t\t\t//  twitter: @BrutPitt - github: BrutPitt\n\t\t\t\t//\n\t\t\t\t//  https://github.com/BrutPitt/glslSmartDeNoise/\n\t\t\t\t//\n\t\t\t\t//  This software is distributed under the terms of the BSD 2-Clause license\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tuniform float sigma;\n\t\t\t\tuniform float threshold;\n\t\t\t\tuniform float kSigma;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439\n\t\t\t\t#define INV_PI 0.31830988618379067153776752674503\n\n\t\t\t\t// Parameters:\n\t\t\t\t//\t sampler2D tex\t - sampler image / texture\n\t\t\t\t//\t vec2 uv\t\t   - actual fragment coord\n\t\t\t\t//\t float sigma  >  0 - sigma Standard Deviation\n\t\t\t\t//\t float kSigma >= 0 - sigma coefficient\n\t\t\t\t//\t\t kSigma * sigma  -->  radius of the circular kernel\n\t\t\t\t//\t float threshold   - edge sharpening threshold\n\t\t\t\tvec4 smartDeNoise( sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold ) {\n\n\t\t\t\t\tfloat radius = round( kSigma * sigma );\n\t\t\t\t\tfloat radQ = radius * radius;\n\n\t\t\t\t\tfloat invSigmaQx2 = 0.5 / ( sigma * sigma );\n\t\t\t\t\tfloat invSigmaQx2PI = INV_PI * invSigmaQx2;\n\n\t\t\t\t\tfloat invThresholdSqx2 = 0.5 / ( threshold * threshold );\n\t\t\t\t\tfloat invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;\n\n\t\t\t\t\tvec4 centrPx = texture2D( tex, uv );\n\t\t\t\t\tcentrPx.rgb *= centrPx.a;\n\n\t\t\t\t\tfloat zBuff = 0.0;\n\t\t\t\t\tvec4 aBuff = vec4( 0.0 );\n\t\t\t\t\tvec2 size = vec2( textureSize( tex, 0 ) );\n\n\t\t\t\t\tvec2 d;\n\t\t\t\t\tfor ( d.x = - radius; d.x <= radius; d.x ++ ) {\n\n\t\t\t\t\t\tfloat pt = sqrt( radQ - d.x * d.x );\n\n\t\t\t\t\t\tfor ( d.y = - pt; d.y <= pt; d.y ++ ) {\n\n\t\t\t\t\t\t\tfloat blurFactor = exp( - dot( d, d ) * invSigmaQx2 ) * invSigmaQx2PI;\n\n\t\t\t\t\t\t\tvec4 walkPx = texture2D( tex, uv + d / size );\n\t\t\t\t\t\t\twalkPx.rgb *= walkPx.a;\n\n\t\t\t\t\t\t\tvec4 dC = walkPx - centrPx;\n\t\t\t\t\t\t\tfloat deltaFactor = exp( - dot( dC.rgba, dC.rgba ) * invThresholdSqx2 ) * invThresholdSqrt2PI * blurFactor;\n\n\t\t\t\t\t\t\tzBuff += deltaFactor;\n\t\t\t\t\t\t\taBuff += deltaFactor * walkPx;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn aBuff / zBuff;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = smartDeNoise( map, vec2( vUv.x, vUv.y ), sigma, kSigma, threshold );\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n}\n", "import { Color, MeshStandardMaterial } from 'three';\n\nexport class FogVolumeMaterial extends MeshStandardMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( params );\n\n\t\tthis.isFogVolumeMaterial = true;\n\n\t\tthis.density = 0.015;\n\t\tthis.emissive = new Color();\n\t\tthis.emissiveIntensity = 0.0;\n\t\tthis.opacity = 0.15;\n\t\tthis.transparent = true;\n\t\tthis.roughness = 1.0;\n\t\tthis.metalness = 0.0;\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n"],
  "mappings": "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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACDzC,IAAM;AAAA;AAAA,EAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAhC,IAAM;AAAA;AAAA,EAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAnC,IAAM;AAAA;AAAA,EAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAxC,IAAM;AAAA;AAAA,EAA+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACArC,IAAM;AAAA;AAAA,EAAqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACA3C,IAAM;AAAA;AAAA,EAAqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACA3C,IAAM;AAAA;AAAA,EAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACApC,IAAM;AAAA;AAAA,EAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAjC,IAAM;AAAA;AAAA,EAAyC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACC/C,IAAM;AAAA;AAAA,EAAoC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACD1C,IAAM;AAAA;AAAA,EAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAjC,IAAM;AAAA;AAAA,EAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAhC,IAAM;AAAA;AAAA,EAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACWvC,IAAM;AAAA;AAAA,EAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACXjC,IAAM;AAAA;AAAA,EAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAhC,IAAM;AAAA;AAAA,EAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAhC,IAAM;AAAA;AAAA,EAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAxC,IAAM;AAAA;AAAA,EAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAlC,IAAM;AAAA;AAAA,EAAuC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACA7C,IAAM;AAAA;AAAA,EAAmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAzC,IAAM;AAAA;AAAA,EAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAxC,IAAM;AAAA;AAAA,EAA6C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCnD,IAAM;AAAA;AAAA,EAAwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACD9C,IAAM;AAAA;AAAA,EAA2B;AAAA;AAAA;AAAA;AAA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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAsS5C,CAAE;AAEF,SAAK,UAAW,UAAW;AAAA,EAE5B;AAED;;;AC3kBA,UAAU,aAAa;AAEtB,QAAM;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,IAAI;AACJ,QAAM,aAAa,IAAI,QAAQ;AAC/B,QAAM,cAAc,IAAI,QAAQ;AAEhC,QAAM,gBAAgB,WAAW;AACjC,MAAI,CAAE,cAAc,YAAa,IAAI;AAErC,SAAQ,MAAO;AAEd,QAAK,OAAQ;AAEZ,oBAAc,UAAU,KAAK,kBAAmB,KAAK,UAAU;AAC/D,eAAS,WAAW;AACpB,eAAS,UAAU;AAAA,IAEpB,OAAO;AAEN,eAAS,UAAU,KAAK,kBAAmB,KAAK,UAAU;AAC1D,eAAS,WAAW;AAAA,IAErB;AAEA,UAAM,CAAE,MAAM,MAAM,MAAM,IAAK,IAAI;AAEnC,UAAM,IAAI,eAAe;AACzB,UAAM,IAAI,eAAe;AACzB,aAAS,WAAW,IAAK,IAAI,MAAM,IAAI,IAAK;AAC5C,aAAS,eAAe,aAAa;AACrC,aAAS,kBAAkB,KAAM,IAAI,SAAS,UAAU,SAAS,sBAAsB,CAAE;AACzF,aAAS,kBAAkB,KAAK;AAChC,aAAS;AAET,UAAM,SAAS,KAAK,MAAM,KAAK;AAC/B,UAAM,SAAS,KAAK,MAAM,KAAK;AAC/B,UAAM,aAAa,SAAS;AAE5B,UAAM,SAAS,KAAK,KAAM,IAAI,IAAK;AACnC,UAAM,SAAS,KAAK,KAAM,IAAI,IAAK;AACnC,UAAM,SAAS,KAAK,MAAO,OAAO,CAAE;AACpC,UAAM,SAAS,KAAK,MAAO,OAAO,CAAE;AAEpC,UAAM,UAAU,KAAK,KAAM,SAAS,MAAO;AAC3C,UAAM,UAAU,KAAK,KAAM,SAAS,MAAO;AAE3C,aAAU,IAAI,GAAG,IAAI,QAAQ,KAAO;AAEnC,eAAU,IAAI,GAAG,IAAI,QAAQ,KAAO;AAGnC,cAAM,iBAAiB,UAAU,gBAAgB;AACjD,cAAM,cAAc,UAAU;AAC9B,cAAM,gBAAgB,UAAU,eAAe;AAC/C,kBAAU,WAAY,UAAW;AACjC,kBAAU,YAAa,WAAY;AAEnC,YAAI,KAAK;AACT,YAAI,KAAK;AACT,YAAK,CAAE,KAAK,aAAc;AAEzB,gBAAM,YAAc,KAAK,gBAAmB,SAAS;AACrD,eAAK,YAAY;AACjB,eAAK,CAAE,EAAI,YAAY;AAEvB,eAAK,eAAe,YAAY;AAAA,QAEjC;AAKA,cAAM,YAAY,SAAS,KAAK;AAChC,uBAAe,QAAQ;AAAA,UACtB,SAAS,KAAK;AAAA,UACd,SAAS,YAAY;AAAA,UACrB,KAAK,IAAK,SAAS,SAAS,KAAK,OAAQ;AAAA,UACzC,KAAK,IAAK,SAAS,SAAS,YAAY,OAAQ;AAAA,QACjD;AAEA,uBAAe,SAAS;AAAA,UACvB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAGA,kBAAU,gBAAiB,cAAe;AAC1C,kBAAU,eAAgB,IAAK;AAE/B,kBAAU,YAAY;AACtB,gBAAQ,OAAQ,SAAU;AAG1B,kBAAU,YAAa,WAAY;AACnC,kBAAU,WAAY,UAAW;AACjC,kBAAU,eAAgB,aAAc;AACxC,kBAAU,gBAAiB,cAAe;AAC1C,kBAAU,YAAY;AAGtB,YAAK,OAAQ;AAEZ,wBAAc,UAAU,aAAa;AACrC,wBAAc,UAAU,eAAe;AAEvC,oBAAU,gBAAiB,YAAa;AACxC,qBAAW,OAAQ,SAAU;AAC7B,oBAAU,gBAAiB,cAAe;AAAA,QAE3C;AAEA,aAAK,WAAa,IAAI;AAGtB,YAAK,MAAM,SAAS,KAAK,MAAM,SAAS,GAAI;AAE3C,eAAK,UAAU,KAAK,MAAO,KAAK,OAAQ;AAAA,QAEzC;AAEA;AAAA,MAED;AAAA,IAED;AAEA,KAAE,cAAc,YAAa,IAAI,CAAE,cAAc,YAAa;AAAA,EAE/D;AAED;AAEA,IAAM,eAAe,IAAI,MAAM;AACxB,IAAM,sBAAN,MAA0B;AAAA,EAEhC,IAAI,WAAW;AAEd,WAAO,KAAK,QAAQ;AAAA,EAErB;AAAA,EAEA,IAAI,SAAUC,IAAI;AAEjB,SAAK,QAAQ,SAAS,oBAAqB,iBAAiB,KAAK,gBAAiB;AAClF,IAAAA,GAAE,iBAAkB,iBAAiB,KAAK,gBAAiB;AAE3D,SAAK,QAAQ,WAAWA;AAAA,EAEzB;AAAA,EAEA,IAAI,SAAS;AAEZ,WAAO,KAAK,SAAS,KAAK,cAAe,CAAE,IAAI,KAAK;AAAA,EAErD;AAAA,EAEA,IAAI,MAAOA,IAAI;AAEd,QAAK,KAAK,WAAWA,IAAI;AAExB;AAAA,IAED;AAEA,QAAK,CAAEA,IAAI;AAEV,WAAK,cAAe,CAAE,EAAE,QAAQ;AAChC,WAAK,cAAe,CAAE,EAAE,QAAQ;AAAA,IAEjC;AAEA,SAAK,SAASA;AACd,SAAK,MAAM;AAAA,EAEZ;AAAA,EAEA,IAAI,QAAQ;AAEX,WAAO,KAAK;AAAA,EAEb;AAAA,EAEA,IAAI,cAAc;AAEjB,WAAO,QAAS,KAAK,eAAgB;AAAA,EAEtC;AAAA,EAEA,YAAa,UAAW;AAEvB,SAAK,SAAS;AACd,SAAK,QAAQ,IAAI,QAAS,GAAG,CAAE;AAE/B,SAAK,cAAc;AACnB,SAAK,cAAc;AAEnB,SAAK,UAAU;AACf,SAAK,YAAY,IAAI,QAAS,GAAG,GAAG,GAAG,CAAE;AACzC,SAAK,iBAAiB;AACtB,SAAK,YAAY;AACjB,SAAK,SAAS;AACd,SAAK,UAAU,IAAI,eAAgB,IAAI,4BAA4B,CAAE;AACrE,SAAK,aAAa,IAAI,eAAgB,IAAI,cAAc,CAAE;AAC1D,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,kBAAkB;AAEvB,SAAK,eAAe,IAAI,wBAAwB,EAAE,SAAU,QAAS;AAErE,SAAK,iBAAiB,IAAI,kBAAmB,GAAG,GAAG;AAAA,MAClD,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,WAAW;AAAA,MACX,WAAW;AAAA,IACZ,CAAE;AACF,SAAK,gBAAgB;AAAA,MACpB,IAAI,kBAAmB,GAAG,GAAG;AAAA,QAC5B,QAAQ;AAAA,QACR,MAAM;AAAA,QACN,WAAW;AAAA,QACX,WAAW;AAAA,MACZ,CAAE;AAAA,MACF,IAAI,kBAAmB,GAAG,GAAG;AAAA,QAC5B,QAAQ;AAAA,QACR,MAAM;AAAA,QACN,WAAW;AAAA,QACX,WAAW;AAAA,MACZ,CAAE;AAAA,IACH;AAIA,SAAK,mBAAmB,MAAM;AAE7B,YAAM,UAAU,KAAK,gBAAiB,KAAK,QAAQ,KAAM;AACzD,cAAQ,KAAM,MAAM;AAEnB,YAAK,KAAK,oBAAoB,SAAU;AAEvC,eAAK,kBAAkB;AAAA,QAExB;AAAA,MAED,CAAE;AAEF,WAAK,kBAAkB;AAAA,IAExB;AAEA,SAAK,SAAS,iBAAkB,iBAAiB,KAAK,gBAAiB;AAAA,EAExE;AAAA,EAEA,kBAAkB;AAEjB,WAAO,KAAK,UAAU,aAAc,KAAK,QAAQ,KAAM;AAAA,EAExD;AAAA,EAEA,UAAW,QAAS;AAEnB,UAAM,EAAE,SAAS,IAAI;AACrB,aAAS,kBAAkB,KAAM,OAAO,WAAY;AACpD,aAAS,oBAAoB,KAAM,OAAO,uBAAwB;AAClE,aAAS,eAAe,WAAY,MAAO;AAG3C,QAAI,aAAa;AAIjB,QAAK,OAAO,iBAAiB,SAAU,EAAG,IAAI,GAAI;AAGjD,mBAAa;AAAA,IAEd;AAEA,QAAK,OAAO,kBAAmB;AAG9B,mBAAa;AAAA,IAEd;AAEA,aAAS,UAAW,eAAe,UAAW;AAE9C,SAAK,SAAS;AAAA,EAEf;AAAA,EAEA,QAAS,GAAG,GAAI;AAEf,QAAI,KAAK,KAAM,CAAE;AACjB,QAAI,KAAK,KAAM,CAAE;AAEjB,QAAK,KAAK,eAAe,UAAU,KAAK,KAAK,eAAe,WAAW,GAAI;AAE1E;AAAA,IAED;AAEA,SAAK,eAAe,QAAS,GAAG,CAAE;AAClC,SAAK,cAAe,CAAE,EAAE,QAAS,GAAG,CAAE;AACtC,SAAK,cAAe,CAAE,EAAE,QAAS,GAAG,CAAE;AACtC,SAAK,MAAM;AAAA,EAEZ;AAAA,EAEA,QAASC,SAAS;AAEjB,IAAAA,QAAO,IAAI,KAAK,eAAe;AAC/B,IAAAA,QAAO,IAAI,KAAK,eAAe;AAAA,EAEhC;AAAA,EAEA,UAAU;AAET,SAAK,eAAe,QAAQ;AAC5B,SAAK,cAAe,CAAE,EAAE,QAAQ;AAChC,SAAK,cAAe,CAAE,EAAE,QAAQ;AAChC,SAAK,aAAa,QAAQ;AAE1B,SAAK,QAAQ,QAAQ;AACrB,SAAK,WAAW,QAAQ;AACxB,SAAK,QAAQ;AAAA,EAEd;AAAA,EAEA,QAAQ;AAEP,UAAM,EAAE,WAAW,gBAAgB,cAAc,IAAI;AACrD,UAAM,iBAAiB,UAAU,gBAAgB;AACjD,UAAM,eAAe,UAAU,cAAc;AAC7C,cAAU,cAAe,YAAa;AAEtC,cAAU,gBAAiB,cAAe;AAC1C,cAAU,cAAe,GAAG,CAAE;AAC9B,cAAU,WAAW;AAErB,cAAU,gBAAiB,cAAe,CAAE,CAAE;AAC9C,cAAU,cAAe,GAAG,CAAE;AAC9B,cAAU,WAAW;AAErB,cAAU,gBAAiB,cAAe,CAAE,CAAE;AAC9C,cAAU,cAAe,GAAG,CAAE;AAC9B,cAAU,WAAW;AAErB,cAAU,cAAe,cAAc,YAAa;AACpD,cAAU,gBAAiB,cAAe;AAE1C,SAAK,UAAU;AACf,SAAK,QAAQ;AAEb,SAAK,SAAS,kBAAkB,cAAc,KAAK;AACnD,QAAK,KAAK,aAAc;AAEvB,WAAK,SAAS,OAAO;AACrB,WAAK,SAAS,kBAAkB,MAAM;AAAA,IAEvC;AAAA,EAED;AAAA,EAEA,SAAS;AAIR,SAAK,SAAS,eAAe;AAC7B,QAAK,KAAK,aAAc;AAEvB;AAAA,IAED;AAEA,QAAK,CAAE,KAAK,OAAQ;AAEnB,WAAK,QAAQ,WAAW,KAAM,IAAK;AAAA,IAEpC;AAEA,SAAK,MAAM,KAAK;AAAA,EAEjB;AAED;;;ACtYA,IAAM,MAAM,IAAI,QAAQ;AACxB,IAAM,SAAS,IAAI,QAAQ;AAC3B,IAAM,SAAS,IAAI,UAAU;AAC7B,IAAM,SAAS,IAAI,MAAM;AAClB,IAAM,4BAAN,cAAwC,YAAY;AAAA,EAE1D,YAAa,QAAQ,KAAK,SAAS,KAAM;AAExC;AAAA,MACC,IAAI,aAAc,QAAQ,SAAS,CAAE;AAAA,MACrC;AAAA,MAAO;AAAA,MAAQ;AAAA,MAAY;AAAA,MAAW;AAAA,MACtC;AAAA,MAAgB;AAAA,MAAqB;AAAA,MAAc;AAAA,IACpD;AAEA,SAAK,qBAAqB;AAAA,EAE3B;AAAA,EAEA,SAAS;AAER,SAAK,QAAQ;AACb,SAAK,cAAc;AAEnB,UAAM,EAAE,MAAM,OAAO,OAAO,IAAI,KAAK;AACrC,aAAU,IAAI,GAAG,IAAI,OAAO,KAAO;AAElC,eAAU,IAAI,GAAG,IAAI,QAAQ,KAAO;AAEnC,eAAO,IAAK,OAAO,MAAO;AAE1B,YAAI,IAAK,IAAI,OAAO,IAAI,MAAO;AAC/B,YAAI,KAAK;AACT,YAAI,IAAI,IAAM,IAAI;AAElB,eAAO,QAAQ,IAAI,IAAI,IAAM,KAAK;AAClC,eAAO,MAAM,IAAI,IAAI,KAAK;AAC1B,eAAO,SAAS;AAEhB,aAAK,mBAAoB,QAAQ,KAAK,QAAQ,MAAO;AAErD,cAAM,IAAI,IAAI,QAAQ;AACtB,cAAM,KAAK,IAAI;AACf,aAAM,KAAK,CAAE,IAAM,OAAO;AAC1B,aAAM,KAAK,CAAE,IAAM,OAAO;AAC1B,aAAM,KAAK,CAAE,IAAM,OAAO;AAC1B,aAAM,KAAK,CAAE,IAAM;AAAA,MAEpB;AAAA,IAED;AAAA,EAED;AAAA,EAEA,KAAM,OAAQ;AAEb,UAAM,KAAM,KAAM;AAClB,SAAK,qBAAqB,MAAM;AAChC,WAAO;AAAA,EAER;AAED;;;ACvEA,IAAM,aAAa,IAAI,QAAQ;AACxB,IAAM,0BAAN,cAAsC,0BAA0B;AAAA,EAEtE,YAAa,aAAa,KAAM;AAE/B,UAAO,YAAY,UAAW;AAE9B,SAAK,WAAW,IAAI,MAAM,EAAE,IAAK,QAAS;AAC1C,SAAK,cAAc,IAAI,MAAM,EAAE,IAAK,CAAS;AAC7C,SAAK,WAAW;AAChB,SAAK,qBAAqB,CAAE,OAAO,IAAI,OAAO,UAAW;AAExD,iBAAW,iBAAkB,KAAM;AAEnC,YAAM,IAAI,WAAW,IAAI,MAAM;AAC/B,YAAM,WAAY,KAAK,aAAa,KAAK,UAAU,KAAK,KAAK,QAAS;AAAA,IAEvE;AAAA,EAED;AAAA,EAEA,KAAM,OAAQ;AAEb,UAAM,KAAM,KAAM;AAElB,SAAK,SAAS,KAAM,MAAM,QAAS;AACnC,SAAK,YAAY,KAAM,MAAM,WAAY;AACzC,WAAO;AAAA,EAER;AAED;;;AC7BO,IAAM,+BAAN,cAA2C,eAAe;AAAA,EAEhE,IAAI,MAAM;AAET,WAAO,KAAK,SAAS,IAAI;AAAA,EAE1B;AAAA,EAEA,IAAI,IAAKC,IAAI;AAEZ,SAAK,SAAS,IAAI,QAAQA;AAAA,EAE3B;AAAA,EAEA,IAAI,UAAU;AAEb,WAAO,KAAK,SAAS,QAAQ;AAAA,EAE9B;AAAA,EAEA,IAAI,QAASA,IAAI;AAEhB,QAAK,KAAK,UAAW;AAEpB,WAAK,SAAS,QAAQ,QAAQA;AAAA,IAE/B;AAAA,EAED;AAAA,EAEA,YAAa,QAAS;AAErB,UAAO;AAAA,MACN,UAAU;AAAA,QAET,KAAK,EAAE,OAAO,KAAK;AAAA,QACnB,SAAS,EAAE,OAAO,EAAE;AAAA,MAErB;AAAA,MAEA;AAAA;AAAA,QAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAUxB;AAAA;AAAA,QAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkD3B,CAAE;AAEF,SAAK,UAAW,MAAO;AAAA,EAExB;AAED;;;AC/FA,IAAM,yBAAN,cAAqC,eAAe;AAAA,EAEnD,cAAc;AAEb,UAAO;AAAA,MAEN,UAAU;AAAA,QAET,QAAQ,EAAE,OAAO,KAAK;AAAA,QACtB,YAAY,EAAE,OAAO,GAAI;AAAA,MAE1B;AAAA,MAEA;AAAA;AAAA,QAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASxB;AAAA;AAAA,QAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAUX,cAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAS/B,CAAE;AAEF,SAAK,aAAa;AAClB,SAAK,YAAY;AAAA,EAElB;AAED;AAEO,IAAM,0BAAN,MAA8B;AAAA,EAEpC,YAAa,UAAW;AAEvB,SAAK,YAAY;AACjB,SAAK,QAAQ,IAAI,eAAgB,IAAI,uBAAuB,CAAE;AAAA,EAE/D;AAAA,EAEA,SAAU,QAAQ,QAAQ,MAAM,SAAS,MAAO;AAE/C,QAAK,CAAE,OAAO,eAAgB;AAE7B,YAAM,IAAI,MAAO,2DAA4D;AAAA,IAE9E;AAEA,UAAM,QAAQ,OAAO,OAAQ,CAAE;AAC/B,UAAM,WAAW,KAAK;AACtB,UAAM,OAAO,KAAK;AAGlB,QAAK,UAAU,MAAO;AAErB,cAAQ,IAAI,MAAM;AAAA,IAEnB;AAEA,QAAK,WAAW,MAAO;AAEtB,eAAS,IAAI,MAAM;AAAA,IAEpB;AAEA,UAAMC,UAAS,IAAI,kBAAmB,OAAO,QAAQ;AAAA,MACpD,MAAM;AAAA,MACN,YAAY,MAAM;AAAA,IACnB,CAAE;AAGF,UAAM,cAAc,MAAM;AAC1B,UAAM,SAAS,KAAK,KAAM,WAAY,IAAI;AAC1C,UAAM,cAAc,IAAM;AAC1B,UAAM,aAAa,KAAQ,IAAI,KAAK,IAAK,KAAK,IAAK,GAAG,MAAO,GAAG,IAAI,EAAG;AAEvE,SAAK,SAAS,QAAQ,iBAAiB,GAAI,MAAO;AAClD,SAAK,SAAS,QAAQ,qBAAqB;AAC3C,SAAK,SAAS,QAAQ,sBAAsB;AAC5C,SAAK,SAAS,SAAS,OAAO,QAAQ;AACtC,SAAK,SAAS,SAAS,WAAW,QAAQ,OAAO,wBAAwB,IAAI;AAC7E,SAAK,SAAS,cAAc;AAG5B,UAAM,gBAAgB,SAAS,gBAAgB;AAC/C,UAAM,mBAAmB,SAAS;AAClC,aAAS,YAAY;AACrB,aAAS,gBAAiBA,OAAO;AACjC,SAAK,OAAQ,QAAS;AACtB,aAAS,gBAAiB,aAAc;AACxC,aAAS,YAAY;AAGrB,UAAM,SAAS,IAAI,YAAa,QAAQ,SAAS,CAAE;AACnD,UAAM,aAAa,IAAI,aAAc,QAAQ,SAAS,CAAE;AACxD,aAAS,uBAAwBA,SAAQ,GAAG,GAAG,OAAO,QAAQ,UAAW;AACzE,IAAAA,QAAO,QAAQ;AAEf,aAAU,IAAI,GAAG,IAAI,WAAW,QAAQ,IAAI,GAAG,KAAO;AAErD,aAAQ,CAAE,IAAI,UAAU,YAAa,WAAY,CAAE,CAAE;AAAA,IAEtD;AAGA,UAAM,SAAS,IAAI,YAAa,QAAQ,OAAO,QAAQ,YAAY,aAAc;AACjF,WAAO,YAAY;AACnB,WAAO,YAAY;AACnB,WAAO,QAAQ;AACf,WAAO,QAAQ;AACf,WAAO,UAAU;AACjB,WAAO,cAAc;AAErB,WAAO;AAAA,EAER;AAAA,EAEA,UAAU;AAET,SAAK,MAAM,QAAQ;AAAA,EAEpB;AAED;;;ACrJA,SAAS,sBAAuB,UAAW;AAE1C,SAAO,SAAS,WAAW,IAAK,iBAAkB;AAEnD;AAEA,IAAM,cAAc,IAAI,QAAQ;AACzB,IAAM,kBAAN,MAAsB;AAAA,EAE5B,IAAI,6BAA6B;AAEhC,WAAO,QAAS,KAAK,YAAY,SAAS,QAAQ,WAAY;AAAA,EAE/D;AAAA,EAEA,IAAI,2BAA4BC,IAAI;AAEnC,SAAK,YAAY,SAAS,UAAW,eAAeA,KAAI,IAAI,CAAE;AAAA,EAE/D;AAAA,EAEA,IAAI,sBAAsB;AAEzB,WAAO,KAAK,YAAY,SAAS;AAAA,EAElC;AAAA,EAEA,IAAI,oBAAqBA,IAAI;AAE5B,SAAK,YAAY,SAAS,sBAAsBA;AAAA,EAEjD;AAAA,EAEA,IAAI,UAAU;AAEb,WAAO,KAAK,YAAY,SAAS;AAAA,EAElC;AAAA,EAEA,IAAI,QAASA,IAAI;AAEhB,SAAK,YAAY,SAAS,UAAUA;AAAA,EAErC;AAAA,EAEA,IAAI,qBAAqB;AAExB,WAAO,KAAK,YAAY,SAAS;AAAA,EAElC;AAAA,EAEA,IAAI,mBAAoBA,IAAI;AAE3B,SAAK,YAAY,SAAS,qBAAqBA;AAAA,EAEhD;AAAA,EAEA,IAAI,UAAU;AAEb,WAAO,KAAK,YAAY;AAAA,EAEzB;AAAA,EAEA,IAAI,SAAS;AAEZ,WAAO,KAAK,YAAY;AAAA,EAEzB;AAAA,EAEA,IAAI,QAAQ;AAEX,WAAO,KAAK,YAAY;AAAA,EAEzB;AAAA,EAEA,IAAI,cAAc;AAEjB,WAAO,KAAK,YAAY;AAAA,EAEzB;AAAA,EAEA,IAAI,YAAaA,IAAI;AAEpB,SAAK,YAAY,cAAcA;AAAA,EAEhC;AAAA,EAEA,IAAI,cAAc;AAEjB,WAAO,QAAS,KAAK,YAAY,WAAY;AAAA,EAE9C;AAAA,EAEA,YAAa,UAAW;AAGvB,SAAK,YAAY;AACjB,SAAK,aAAa,IAAI,0BAA0B;AAChD,SAAK,cAAc,IAAI,oBAAqB,QAAS;AACrD,SAAK,cAAc;AACnB,SAAK,SAAS,IAAI,MAAM;AACxB,SAAK,kBAAkB;AAEvB,SAAK,oBAAoB,IAAI,oBAAqB,QAAS;AAC3D,SAAK,kBAAkB,MAAM,IAAK,GAAG,CAAE;AACvC,SAAK,QAAQ,IAAI,eAAgB,IAAI,6BAA8B;AAAA,MAClE,KAAK;AAAA,MACL,aAAa;AAAA,MACb,UAAU;AAAA,MAEV,oBAAoB,SAAS,qBAAqB,EAAE;AAAA,IACrD,CAAE,CAAE;AACJ,SAAK,aAAa;AAElB,SAAK,uBAAuB;AAC5B,SAAK,sBAAsB;AAC3B,SAAK,sBAAsB;AAG3B,SAAK,cAAc;AACnB,SAAK,aAAa;AAClB,SAAK,eAAe;AACpB,SAAK,oBAAoB;AACzB,SAAK,mBAAmB;AACxB,SAAK,gBAAgB;AACrB,SAAK,cAAc;AACnB,SAAK,cAAc;AACnB,SAAK,wBAAwB;AAC7B,SAAK,iBAAiB;AACtB,SAAK,iBAAiB;AACtB,SAAK,cAAc,IAAI,QAAS,MAAM,IAAK;AAC3C,SAAK,yBAAyB,CAAE,OAAO,WAAY;AAElD,WAAK,UAAU,OAAQ,OAAO,MAAO;AAAA,IAEtC;AAEA,SAAK,yBAAyB,CAAEC,SAAQC,WAAU,SAAU;AAE3D,YAAM,mBAAmBA,UAAS;AAClC,MAAAA,UAAS,YAAY;AACrB,WAAK,OAAQA,SAAS;AACtB,MAAAA,UAAS,YAAY;AAAA,IAEtB;AAGA,SAAK,SAAU,IAAI,MAAM,GAAG,IAAI,kBAAkB,CAAE;AAAA,EAErD;AAAA,EAEA,aAAc,QAAS;AAEtB,SAAK,WAAW,aAAc,MAAO;AAAA,EAEtC;AAAA,EAEA,SAAU,OAAO,QAAQ,UAAU,CAAC,GAAI;AAEvC,UAAM,kBAAmB,IAAK;AAC9B,WAAO,kBAAkB;AAEzB,UAAM,YAAY,KAAK;AACvB,cAAU,WAAY,KAAM;AAE5B,QAAK,KAAK,aAAc;AAEvB,aAAO,UAAU,cAAe,QAAQ,UAAW,EAAE,KAAM,YAAU;AAEpE,eAAO,KAAK,mBAAoB,OAAO,QAAQ,MAAO;AAAA,MAEvD,CAAE;AAAA,IAEH,OAAO;AAEN,YAAM,SAAS,UAAU,SAAS;AAClC,aAAO,KAAK,mBAAoB,OAAO,QAAQ,MAAO;AAAA,IAEvD;AAAA,EAED;AAAA,EAEA,iBAAkB,MAAO;AAExB,SAAK,cAAc;AACnB,UAAM,SAAS,KAAK,SAAU,GAAG,IAAK;AACtC,SAAK,cAAc;AAEnB,WAAO;AAAA,EAER;AAAA,EAEA,UAAW,QAAS;AAEnB,SAAK,SAAS;AACd,SAAK,aAAa;AAAA,EAEnB;AAAA,EAEA,eAAe;AAEd,UAAM,SAAS,KAAK;AACpB,WAAO,kBAAkB;AAEzB,SAAK,YAAY,UAAW,MAAO;AACnC,SAAK,kBAAkB,UAAW,MAAO;AACzC,SAAK,MAAM;AAAA,EAEZ;AAAA,EAEA,kBAAkB;AAEjB,UAAM,WAAW,KAAK,YAAY;AAClC,UAAM,WAAW,KAAK;AACtB,UAAM,YAAY,KAAK;AACvB,UAAM,cAAc,KAAK;AAKzB,UAAM,WAAWC,aAAa,SAAU;AACxC,aAAS,SAAS,YAAa,UAAU,UAAU,YAAY,GAAG,YAAY,CAAE;AAChF,aAAS,UAAU,WAAY,WAAW,QAAS;AACnD,SAAK,MAAM;AAAA,EAEZ;AAAA,EAEA,eAAe;AAEd,UAAM,QAAQ,KAAK;AACnB,UAAM,WAAW,KAAK;AACtB,UAAM,WAAW,KAAK,YAAY;AAElC,UAAM,SAASC,WAAW,KAAM;AAChC,UAAM,cAAc,eAAgB,MAAO;AAC3C,aAAS,OAAO,WAAY,QAAQ,WAAY;AAChD,aAAS,YAAY,YAAa,UAAU,WAAY;AACxD,SAAK,MAAM;AAAA,EAEZ;AAAA,EAEA,oBAAoB;AAEnB,UAAM,QAAQ,KAAK;AACnB,UAAM,WAAW,KAAK,YAAY;AAElC,QAAK,KAAK,qBAAsB;AAE/B,WAAK,oBAAoB,QAAQ;AACjC,WAAK,sBAAsB;AAAA,IAE5B;AAGA,aAAS,iBAAiB,MAAM;AAChC,aAAS,sBAAsB,MAAM,uBAAuB;AAC5D,aAAS,mBAAmB,sBAAuB,MAAM,kBAAmB,EAAE,OAAO;AACrF,QAAK,MAAM,eAAe,MAAO;AAEhC,eAAS,gBAAgB;AACzB,eAAS,kBAAkB;AAAA,IAE5B,WAAY,MAAM,WAAW,SAAU;AAEtC,WAAK,mBAAmB,KAAK,oBAAoB,IAAI,wBAAyB,EAAG;AAEjF,YAAM,kBAAkB,KAAK;AAC7B,UAAK,CAAE,gBAAgB,SAAS,OAAQ,MAAM,UAAW,GAAI;AAG5D,wBAAgB,SAAS,IAAK,MAAM,UAAW;AAC/C,wBAAgB,YAAY,IAAK,MAAM,UAAW;AAClD,wBAAgB,OAAO;AAAA,MAExB;AAGA,eAAS,gBAAgB;AACzB,eAAS,kBAAkB;AAAA,IAE5B,WAAY,MAAM,WAAW,eAAgB;AAE5C,UAAK,MAAM,eAAe,KAAK,qBAAsB;AAEpD,cAAM,aAAa,IAAI,wBAAyB,KAAK,SAAU,EAAE,SAAU,MAAM,UAAW;AAC5F,aAAK,sBAAsB;AAC3B,iBAAS,gBAAgB;AACzB,iBAAS,kBAAkB;AAAA,MAE5B;AAAA,IAED,OAAO;AAEN,eAAS,gBAAgB,MAAM;AAC/B,eAAS,kBAAkB;AAAA,IAE5B;AAGA,aAAS,uBAAuB,MAAM,wBAAwB;AAC9D,aAAS,oBAAoB,sBAAuB,MAAM,mBAAoB,EAAE,OAAO;AACvF,QAAK,KAAK,yBAAyB,MAAM,aAAc;AAEtD,UAAK,MAAM,gBAAgB,MAAO;AAEjC,YAAK,MAAM,YAAY,eAAgB;AAEtC,gBAAM,cAAc,IAAI,wBAAyB,KAAK,SAAU,EAAE,SAAU,MAAM,WAAY;AAC9F,mBAAS,WAAW,WAAY,WAAY;AAAA,QAE7C,OAAO;AAKN,mBAAS,WAAW,WAAY,MAAM,WAAY;AAAA,QAEnD;AAAA,MAED,OAAO;AAEN,iBAAS,uBAAuB;AAAA,MAEjC;AAAA,IAED;AAEA,SAAK,uBAAuB,MAAM;AAClC,SAAK,sBAAsB,MAAM;AACjC,SAAK,MAAM;AAAA,EAEZ;AAAA,EAEA,mBAAoB,OAAO,QAAQ,SAAU;AAE5C,UAAM;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACD,IAAI;AAEJ,SAAK,aAAa;AAElB,UAAM,aAAa,KAAK;AACxB,UAAM,WAAW,WAAW;AAE5B,QAAK,YAAa;AAEjB,eAAS,IAAI,WAAY,GAAI;AAC7B,eAAS,gBAAgB;AAAA,QACxB,SAAS,WAAW;AAAA,QACpB,SAAS,WAAW;AAAA,QACpB,SAAS,WAAW;AAAA,QACpB,SAAS,WAAW;AAAA,MACrB;AAEA,eAAS,uBAAuB,WAAY,SAAS,WAAW,aAAc;AAAA,IAE/E;AAGA,SAAK,iBAAiB;AACtB,SAAK,QAAQ;AACb,SAAK,SAAS;AAEd,SAAK,aAAa;AAClB,SAAK,gBAAgB;AACrB,SAAK,kBAAkB;AACvB,SAAK,aAAa;AAElB,WAAO;AAAA,EAER;AAAA,EAEA,eAAe;AAEd,UAAM,mBAAmB,KAAK;AAC9B,UAAM,aAAa,KAAK;AACxB,UAAM,WAAW,KAAK;AACtB,UAAM,QAAQ,KAAK;AACnB,UAAM,OAAO,KAAK;AAElB,SAAK,aAAa;AAElB,QAAK,KAAK,aAAc;AAEvB,iBAAW,MAAM;AACjB,uBAAiB,MAAM;AACvB,WAAK,cAAc;AAEnB,WAAK,SAAS,UAAU;AACxB,YAAM,MAAM;AAAA,IAEb;AAGA,UAAM,QAAQ,MAAM,SAAS,IAAI;AACjC,UAAM,cAAc,MAAM,eAAe,IAAI;AAC7C,QAAK,CAAE,KAAK,oBAAoB,KAAK,qBAAqB,KAAK,eAAe,eAAe,CAAE,KAAK,aAAc;AAEjH,iBAAW,OAAO;AAAA,IAEnB;AAIA,eAAW,QAAQ,WAAW,SAAS,oBAAoB,KAAK,CAAE,sBAAuB,QAAS;AAClG,qBAAiB,QAAQ,WAAW;AAEpC,QAAK,KAAK,gBAAiB;AAE1B,YAAMF,YAAW,KAAK;AACtB,YAAM,aAAa,KAAK;AAExB,UAAK,eAAe,KAAK,eAAe,KAAK,WAAW,KAAK,YAAa;AAEzE,YAAK,KAAK,iBAAiB,GAAI;AAE9B,eAAK,SAAS,UAAU,KAAK,IAAK,KAAK,SAAS,UAAU,QAAQ,KAAK,cAAc,CAAE;AAAA,QAExF,OAAO;AAEN,eAAK,SAAS,UAAU;AAAA,QAEzB;AAAA,MAED;AAGA,UAAK,CAAE,KAAK,qBAAqB,KAAK,UAAU,cAAc,KAAK,SAAS,UAAU,GAAI;AAEzF,YAAK,KAAK,iBAAiB,CAAE,KAAK,aAAc;AAE/C,cAAK,iBAAiB,UAAU,GAAI;AAEnC,6BAAiB,WAAW,WAAW;AACvC,6BAAiB,OAAO;AAAA,UAEzB;AAEA,gBAAM,iBAAiB,KAAK,SAAS;AACrC,eAAK,SAAS,UAAU,IAAI,KAAK,SAAS;AAC1C,eAAK,SAAS,MAAM,iBAAiB,OAAO;AAC5C,eAAK,OAAQA,SAAS;AACtB,eAAK,SAAS,UAAU;AAAA,QAEzB;AAEA,YAAK,CAAE,KAAK,iBAAiB,KAAK,kBAAkB,KAAK,iBAAiB,KAAK,aAAc;AAE5F,eAAK,uBAAwB,KAAK,OAAO,KAAK,MAAO;AAAA,QAEtD;AAAA,MAED;AAGA,UAAK,KAAK,qBAAqB,KAAK,SAAS,UAAU,GAAI;AAE1D,YAAK,KAAK,SAAS,UAAU,GAAI;AAIhC,eAAK,SAAS,WAAW,KAAK,gBAAgB,mBAAmB;AAAA,QAElE;AAEA,aAAK,SAAS,MAAM,WAAW,OAAO;AACtC,aAAK,uBAAwB,WAAW,QAAQA,WAAU,IAAK;AAC/D,aAAK,SAAS,WAAW;AAAA,MAE1B;AAAA,IAED;AAAA,EAED;AAAA,EAEA,QAAQ;AAEP,SAAK,cAAc;AACnB,SAAK,YAAY,UAAU;AAAA,EAE5B;AAAA,EAEA,UAAU;AAET,SAAK,YAAY,QAAQ;AACzB,SAAK,YAAY,SAAS,QAAQ;AAClC,SAAK,YAAY,QAAQ;AAAA,EAE1B;AAAA,EAEA,eAAe;AAGd,QAAK,KAAK,uBAAwB;AAEjC,WAAK,UAAU,qBAAsB,WAAY;AAEjD,YAAM,IAAI,KAAK,MAAO,KAAK,cAAc,YAAY,CAAE;AACvD,YAAM,IAAI,KAAK,MAAO,KAAK,cAAc,YAAY,CAAE;AAEvD,WAAK,YAAY,QAAS,WAAY;AACtC,UAAK,YAAY,MAAM,KAAK,YAAY,MAAM,GAAI;AAEjD,cAAM,cAAc,KAAK;AACzB,aAAK,YAAY,QAAS,GAAG,CAAE;AAC/B,aAAK,kBAAkB,QAAS,KAAK,MAAO,IAAI,WAAY,GAAG,KAAK,MAAO,IAAI,WAAY,CAAE;AAAA,MAE9F;AAAA,IAED;AAAA,EAED;AAED;;;AC3gBO,IAAM,iBAAN,cAA6B,OAAO;AAAA,EAE1C,cAAc;AAEb,UAAM;AAEN,SAAK,mBAAmB;AAAA,EAEzB;AAED;;;ACVO,IAAM,oBAAN,cAAgC,UAAU;AAAA,EAEhD,eAAgB,MAAO;AAEtB,UAAO,GAAG,IAAK;AAEf,SAAK,SAAS;AACd,SAAK,SAAS;AAAA,EAEf;AAAA,EAEA,KAAM,QAAQ,WAAY;AAEzB,UAAM,KAAM,QAAQ,SAAU;AAE9B,SAAK,SAAS,OAAO;AACrB,SAAK,SAAS,OAAO;AAErB,WAAO;AAAA,EAER;AAED;;;ACtBO,IAAM,kBAAN,cAA8B,cAAc;AAAA,EAElD,eAAgB,MAAO;AAEtB,UAAO,GAAG,IAAK;AACf,SAAK,aAAa;AAAA,EAEnB;AAAA,EAEA,KAAM,QAAQ,WAAY;AAEzB,UAAM,KAAM,QAAQ,SAAU;AAE9B,SAAK,aAAa,OAAO;AAEzB,WAAO;AAAA,EAER;AAED;;;AChBA,IAAM,oBAAN,cAAgC,aAAa;AAAA,EAE5C,cAAc;AAEb,UAAO;AAAA,MAEN,UAAU;AAAA,QAET,QAAQ,EAAE,OAAO,KAAK;AAAA,QACtB,MAAM,EAAE,OAAO,EAAE;AAAA,MAElB;AAAA,MAEA;AAAA;AAAA,QAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAUxB;AAAA;AAAA,QAA0B;AAAA;AAAA;AAAA;AAAA;AAAA,MAKX,cAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAc/B,CAAE;AAAA,EAEH;AAED;AAEO,IAAM,yBAAN,MAA6B;AAAA,EAEnC,YAAa,UAAW;AAEvB,SAAK,WAAW;AAChB,SAAK,iBAAiB,IAAI,eAAgB,QAAS;AACnD,SAAK,WAAW,IAAI,eAAgB,IAAI,kBAAkB,CAAE;AAC5D,SAAK,eAAe,IAAI,kBAAmB,GAAG,GAAG,EAAE,MAAM,WAAW,QAAQ,WAAW,CAAE;AAAA,EAE1F;AAAA,EAEA,UAAU;AAET,SAAK,eAAe,QAAQ;AAC5B,SAAK,SAAS,QAAQ;AACtB,SAAK,aAAa,QAAQ;AAAA,EAE3B;AAAA,EAEA,SAAU,SAAS,MAAO;AAEzB,UAAM,EAAE,gBAAgB,cAAc,UAAU,SAAS,IAAI;AAG7D,UAAM,cAAc,eAAe,oBAAqB,OAAQ;AAGhE,UAAM,EAAE,OAAO,OAAO,IAAI,QAAQ;AAClC,iBAAa,QAAS,OAAO,MAAO;AACpC,aAAS,SAAS,SAAS,YAAY;AACvC,aAAS,SAAS,OAAO;AAGzB,UAAM,mBAAmB,SAAS,gBAAgB;AAClD,UAAM,YAAY,SAAS;AAE3B,aAAS,gBAAiB,YAAa;AACvC,aAAS,YAAY;AACrB,aAAS,OAAQ,QAAS;AAE1B,aAAS,gBAAiB,gBAAiB;AAC3C,aAAS,YAAY;AAGrB,UAAM,SAAS,IAAI,YAAa,QAAQ,SAAS,CAAE;AACnD,UAAM,aAAa,IAAI,aAAc,QAAQ,SAAS,CAAE;AACxD,aAAS,uBAAwB,cAAc,GAAG,GAAG,OAAO,QAAQ,UAAW;AAE/E,aAAU,IAAI,GAAG,IAAI,WAAW,QAAQ,IAAI,GAAG,KAAO;AAErD,aAAQ,CAAE,IAAI,UAAU,YAAa,WAAY,CAAE,CAAE;AAAA,IAEtD;AAEA,UAAM,SAAS,IAAI,YAAa,QAAQ,OAAO,QAAQ,YAAY,aAAc;AACjF,WAAO,YAAY,QAAQ;AAC3B,WAAO,YAAY,QAAQ;AAC3B,WAAO,QAAQ,QAAQ;AACvB,WAAO,QAAQ,QAAQ;AACvB,WAAO,UAAU;AACjB,WAAO,cAAc;AAGrB,gBAAY,QAAQ;AAEpB,WAAO;AAAA,EAER;AAED;;;ACvHO,IAAM,kBAAN,cAA8B,aAAa;AAAA,EAEjD,YAAa,YAAa;AAEzB,UAAO;AAAA,MAEN,UAAU;AAAA,MAEV,aAAa;AAAA,MAEb,YAAY;AAAA,MAEZ,WAAW;AAAA,MAEX,SAAS;AAAA,QAER,YAAY;AAAA,MAEb;AAAA,MAEA,UAAU;AAAA,QAET,OAAO,EAAE,OAAO,EAAI;AAAA,QACpB,WAAW,EAAE,OAAO,KAAK;AAAA,QACzB,QAAQ,EAAE,OAAO,EAAI;AAAA,QAErB,KAAK,EAAE,OAAO,KAAK;AAAA,QACnB,SAAS,EAAE,OAAO,EAAE;AAAA,MAErB;AAAA,MAEA;AAAA;AAAA,QAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAaxB;AAAA;AAAA,QAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA4F3B,CAAE;AAEF,SAAK,UAAW,UAAW;AAAA,EAE5B;AAED;;;AC/IO,IAAM,oBAAN,cAAgC,qBAAqB;AAAA,EAE3D,YAAa,QAAS;AAErB,UAAO,MAAO;AAEd,SAAK,sBAAsB;AAE3B,SAAK,UAAU;AACf,SAAK,WAAW,IAAI,MAAM;AAC1B,SAAK,oBAAoB;AACzB,SAAK,UAAU;AACf,SAAK,cAAc;AACnB,SAAK,YAAY;AACjB,SAAK,YAAY;AAEjB,SAAK,UAAW,MAAO;AAAA,EAExB;AAED;",
  "names": ["target", "target", "target", "leftBounds", "uint16Array", "uint32Array", "offset", "count", "areIntersecting", "closestPointLineToLine", "temp1", "temp2", "closestPointsSegmentToSegment", "sphereIntersectTriangle", "triangle", "target", "matrix", "v", "triangle", "closestPointToPoint", "target", "float32Array", "uint16Array", "uint32Array", "nodeIndex32", "nodeIndex16", "temp", "target", "ray", "ray", "triangle", "uint32Array", "uint16Array", "float32Array", "_traverse", "byteOffset", "ray", "ray", "triangle", "ray", "float32Array", "uint16Array", "uint32Array", "ray", "float32Array", "uint16Array", "uint32Array", "float32Array", "uint16Array", "uint32Array", "obb", "obb2", "temp1", "triangle", "triangle2", "uint32Array", "uint16Array", "float32Array", "_traverse", "byteOffset", "ray", "_raycast", "float32Array", "uint16Array", "uint32Array", "_xyzFields", "ray", "_raycastFirst", "float32Array", "uint16Array", "uint32Array", "boundingBox", "triangle", "triangle2", "invertedMat", "obb", "obb2", "_intersectsGeometry", "float32Array", "uint16Array", "uint32Array", "tempMatrix", "obb", "obb2", "temp1", "temp2", "temp3", "temp4", "triangle", "triangle2", "obb", "uint32Array", "uint16Array", "_traverse", "ray", "triangle", "triangle2", "box", "target", "boundingBox", "_box1", "_box2", "target", "uint16Array", "uint32Array", "float32Array", "target", "temp", "target", "l", "_positionVector", "_normalVector", "_tangentVector", "_tangentVector4", "_morphVector", "_temp", "_skinIndex", "_skinWeight", "_matrix", "_boneMatrix", "target", "matrix", "target", "v", "target", "v", "l", "getTextures", "getLights", "hash", "m", "getTextureHash", "target", "v", "v", "target", "v", "target", "v", "target", "renderer", "getTextures", "getLights"]
}
